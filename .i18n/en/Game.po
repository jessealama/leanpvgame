msgid ""
msgstr "Project-Id-Version: Game v4.26.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-19\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#. ยง0: `x โ insertSorted x l`
#. ยง1: `l`
#: Game.Levels.ProofsInTypes.L08_Victory
msgid "ยง0 for any list ยง1"
msgstr "ยง0 for any list ยง1"

#. ยง0: `Sorted`
#. ยง1: `List Nat`
#. ยง2: ```lean
#. @[simp] def Sorted : List Nat โ Prop
#.   | []          => True
#.   | [_]         => True
#.   | x :: y :: ys => x โค y โง Sorted (y :: ys)
#. ```
#. ยง3: `x :: y :: ys`
#. ยง4: `x โค y`
#. ยง5: `y :: ys`
#. ยง6: `simp [Sorted] at h`
#. ยง7: `simp [Sorted] at h`
#. ยง8: `h : Sorted (x :: y :: ys)`
#. ยง9: `h : x โค y โง Sorted (y :: ys)`
#. ยง10: `.1`
#. ยง11: `โง`
#: Game.Levels.ProofsInTypes.L05_Sorted
msgid "A **predicate on lists** can encode an invariant. Here is ยง0 for ยง1:\n"
"\n"
"ยง2\n"
"\n"
"- An empty list is trivially sorted.\n"
"- A singleton list is trivially sorted.\n"
"- A list ยง3 is sorted iff ยง4 and ยง5 is sorted.\n"
"\n"
"The tactic ยง6 unfolds the predicate **inside a hypothesis**.\n"
"After ยง7 where ยง8,\n"
"the hypothesis becomes ยง9.\n"
"Then ยง10 extracts the left part of ยง11."
msgstr "A **predicate on lists** can encode an invariant. Here is ยง0 for ยง1:\n"
"\n"
"ยง2\n"
"\n"
"- An empty list is trivially sorted.\n"
"- A singleton list is trivially sorted.\n"
"- A list ยง3 is sorted iff ยง4 and ยง5 is sorted.\n"
"\n"
"The tactic ยง6 unfolds the predicate **inside a hypothesis**.\n"
"After ยง7 where ยง8,\n"
"the hypothesis becomes ยง9.\n"
"Then ยง10 extracts the left part of ยง11."

#. ยง0: `native_decide`
#. ยง1: `isPrime`
#. ยง2: `isPrime`
#. ยง3: `myGcd`
#. ยง4: `myGcd`
#: Game.Levels.FirstProofs.L07_Primality
msgid "ยง0 compiled ยง1 to native code and **evaluated** each value\n"
"and verify the result. Since ยง2 is a computable function (using ยง3),\n"
"Lean can do this automatically โ no manual proof steps needed.\n"
"\n"
"The same ยง4 you proved correct in levels 4โ5 powers this verification.\n"
"This is **program verification in action**: prove your building blocks correct,\n"
"then compose them into larger verified programs.\n"
"\n"
"**Congratulations โ you've completed World 1!**\n"
"\n"
"Continue to World 2 to learn how to write complete functional specifications."
msgstr "ยง0 compiled ยง1 to native code and **evaluated** each value\n"
"and verify the result. Since ยง2 is a computable function (using ยง3),\n"
"Lean can do this automatically โ no manual proof steps needed.\n"
"\n"
"The same ยง4 you proved correct in levels 4โ5 powers this verification.\n"
"This is **program verification in action**: prove your building blocks correct,\n"
"then compose them into larger verified programs.\n"
"\n"
"**Congratulations โ you've completed World 1!**\n"
"\n"
"Continue to World 2 to learn how to write complete functional specifications."

#: Game.Levels.FirstProofs.L04_GcdBase
msgid "GCD Base Case"
msgstr "GCD Base Case"

#: Game.Levels.FirstProofs
msgid "First Proofs"
msgstr "First Proofs"

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ๐"
msgstr "intermediate goal solved! ๐"

#: Game.Levels.PurePrograms.L07_Expr
msgid "Evaluate an expression to an integer."
msgstr "Evaluate an expression to an integer."

#. ยง0: `foldr (ยท :: ยท) [] l = l`
#. ยง1: `myFoldr`
#: Game.Levels.PurePrograms.L03_MyFoldr
msgid "ยง0 โ folding cons and nil over a list reconstructs the list.\n"
"This is called the **foldr identity law**, and it shows that ยง1 is the\n"
"most general way to process a list."
msgstr "ยง0 โ folding cons and nil over a list reconstructs the list.\n"
"This is called the **foldr identity law**, and it shows that ยง1 is the\n"
"most general way to process a list."

#. ยง0: `intro n m h`
#. ยง1: `grind [double]`
#. ยง2: `grind`
#. ยง3: `double`
#: Game.Levels.AutomationPower.L03_Grind
msgid "After ยง0, try ยง1.\n"
"This tells ยง2 to unfold ยง3 and then use arithmetic to finish."
msgstr "After ยง0, try ยง1.\n"
"This tells ยง2 to unfold ยง3 and then use arithmetic to finish."

#. ยง0: `{x : T // P x}`
#. ยง1: `Fin n`
#. ยง2: `< n`
#: Game.Levels.ProofsInTypes
msgid "**Welcome to World 4: Proofs Packed in Types!**\n"
"\n"
"In Worlds 1โ3 we proved *theorems about programs*.\n"
"In this world, we go further: we pack those proofs *inside the types themselves*.\n"
"\n"
"The result: values whose types **guarantee** correctness.\n"
"The compiler becomes the verifier โ incorrect code simply won't compile.\n"
"\n"
"**New ideas in this world**:\n"
"- **Subtypes** ยง0 โ values bundled with their proof\n"
"- **ยง1** โ natural numbers that are provably ยง2\n"
"- **Proof-carrying functions** โ types that enforce pre/postconditions\n"
"- **Invariant-preserving structures** โ data structures that *cannot* violate their invariants"
msgstr "**Welcome to World 4: Proofs Packed in Types!**\n"
"\n"
"In Worlds 1โ3 we proved *theorems about programs*.\n"
"In this world, we go further: we pack those proofs *inside the types themselves*.\n"
"\n"
"The result: values whose types **guarantee** correctness.\n"
"The compiler becomes the verifier โ incorrect code simply won't compile.\n"
"\n"
"**New ideas in this world**:\n"
"- **Subtypes** ยง0 โ values bundled with their proof\n"
"- **ยง1** โ natural numbers that are provably ยง2\n"
"- **Proof-carrying functions** โ types that enforce pre/postconditions\n"
"- **Invariant-preserving structures** โ data structures that *cannot* violate their invariants"

#. ยง0: `simp [double]`
#: Game.Levels.FirstProofs.L01_Double
msgid "Now ยง0 will unfold the definition and close the goal."
msgstr "Now ยง0 will unfold the definition and close the goal."

#. ยง0: `mvcgen`
#: Game.Levels.ImperativeBoss.L01_Stub
msgid "This world is under construction.\n"
"\n"
"**World 8: Imperative Boss** is the final challenge: verify a complete imperative\n"
"algorithm using loop invariants and the ยง0 framework. This is where\n"
"everything comes together โ functional specs, termination, data invariants,\n"
"and Hoare logic โ applied to real imperative code.\n"
"\n"
"Check back soon!"
msgstr "This world is under construction.\n"
"\n"
"**World 8: Imperative Boss** is the final challenge: verify a complete imperative\n"
"algorithm using loop invariants and the ยง0 framework. This is where\n"
"everything comes together โ functional specs, termination, data invariants,\n"
"and Hoare logic โ applied to real imperative code.\n"
"\n"
"Check back soon!"

#. ยง0: `{n : Nat // n % 2 = 0}`
#: Game.Levels.ProofsInTypes.L01_Subtype
msgid "Subtype of even natural numbers: ยง0"
msgstr "Subtype of even natural numbers: ยง0"

#. ยง0: `intro h`
#. ยง1: `h : myGcd a b = 1`
#. ยง2: `exact h`
#: Game.Levels.FirstProofs.L06_Coprime
msgid "The backward direction: ยง0 gives ยง1. Use ยง2."
msgstr "The backward direction: ยง0 gives ยง1. Use ยง2."

#: Game
msgid "## About this Game\n"
"\n"
"**Program Verification Game** teaches formal program verification using Lean 4.\n"
"\n"
"The curriculum covers an 8-world progression from basic functional proofs\n"
"through imperative verification with loop invariants.\n"
"\n"
"**Version**: 0.1.0 (World 1 complete; Worlds 2โ8 coming soon)\n"
"\n"
"**Source**: https://github.com/your-org/pvgame"
msgstr "## About this Game\n"
"\n"
"**Program Verification Game** teaches formal program verification using Lean 4.\n"
"\n"
"The curriculum covers an 8-world progression from basic functional proofs\n"
"through imperative verification with loop invariants.\n"
"\n"
"**Version**: 0.1.0 (World 1 complete; Worlds 2โ8 coming soon)\n"
"\n"
"**Source**: https://github.com/your-org/pvgame"

#: Game.Levels.Termination
msgid "**World 4: Termination**\n"
"\n"
"Prove that programs always terminate. Learn structural recursion, well-founded\n"
"measures, and how Lean's kernel ensures every recursive function has a proof\n"
"that its recursive calls strictly decrease.\n"
"\n"
"*Coming soon!*"
msgstr "**World 4: Termination**\n"
"\n"
"Prove that programs always terminate. Learn structural recursion, well-founded\n"
"measures, and how Lean's kernel ensures every recursive function has a proof\n"
"that its recursive calls strictly decrease.\n"
"\n"
"*Coming soon!*"

#. ยง0: `@[simp]`
#. ยง1: `cases h : p (f x)`
#. ยง2: `simp_all [Function.comp_apply]`
#. ยง3: `(p โ f) x = p (f x)`
#. ยง4: `simp_all`
#. ยง5: `@[simp]`
#. ยง6: `grind`
#. ยง7: `cases h : expr`
#. ยง8: `simp_all`
#: Game.Levels.AutomationPower.L07_FilterMap
msgid "You've completed **World 3: Automation Power**!\n"
"\n"
"The ยง0 investment made both the filter and map cases automatic.\n"
"ยง1 split the proof cleanly, and ยง2\n"
"tied together ยง3, the filter branches, and the IH.\n"
"\n"
"What you've mastered:\n"
"- **ยง4**: simplifies goals *and* hypotheses; IH is automatic\n"
"- **ยง5**: tag your equations once, benefit everywhere\n"
"- **ยง6**: equality reasoning + arithmetic in one call\n"
"- **ยง7**: case-split and name the result for ยง8\n"
"\n"
"These tools will power every world that follows."
msgstr "You've completed **World 3: Automation Power**!\n"
"\n"
"The ยง0 investment made both the filter and map cases automatic.\n"
"ยง1 split the proof cleanly, and ยง2\n"
"tied together ยง3, the filter branches, and the IH.\n"
"\n"
"What you've mastered:\n"
"- **ยง4**: simplifies goals *and* hypotheses; IH is automatic\n"
"- **ยง5**: tag your equations once, benefit everywhere\n"
"- **ยง6**: equality reasoning + arithmetic in one call\n"
"- **ยง7**: case-split and name the result for ยง8\n"
"\n"
"These tools will power every world that follows."

#: Game.Levels.PurePrograms.L01_MyMap
msgid "Mapping Over a List"
msgstr "Mapping Over a List"

#. ยง0: `induction lโ <;> simp_all`
#. ยง1: `@[simp]`
#. ยง2: `myMap`
#: Game.Levels.AutomationPower.L04_MapAppend
msgid "Use ยง0.\n"
"The ยง1 lemmas for ยง2 from Level 2 fire automatically."
msgstr "Use ยง0.\n"
"The ยง1 lemmas for ยง2 from Level 2 fire automatically."

#. ยง0: `induction xs <;> simp_all <;> omega`
#. ยง1: `<;>`
#: Game.Levels.AutomationPower.L01_SimpAll
msgid "Try ยง0.\n"
"The ยง1 combinator applies the next tactic to *all* remaining goals at once."
msgstr "Try ยง0.\n"
"The ยง1 combinator applies the next tactic to *all* remaining goals at once."

#. ยง0: ```lean
#. myFilter p (myMap f l) = myMap f (myFilter (p โ f) l)
#. ```
#. ยง1: `myMap f l`
#. ยง2: `p โ f`
#. ยง3: `@[simp]`
#. ยง4: `myMap`
#. ยง5: `myFilter`
#. ยง6: `simp_all`
#. ยง7: ```lean
#. induction l with
#. | nil => simp
#. | cons x xs ih =>
#.   simp only [myMap_cons, myFilter_cons]
#.   cases h : p (f x) <;> simp_all [Function.comp_apply]
#. ```
#. ยง8: `simp only [myMap_cons, myFilter_cons]`
#. ยง9: `cases h : p (f x)`
#. ยง10: `simp_all [Function.comp_apply]`
#. ยง11: `(p โ f) x`
#. ยง12: `p (f x)`
#. ยง13: `if`
#: Game.Levels.AutomationPower.L07_FilterMap
msgid "The payoff level. This theorem appears in compilers, query optimizers, and\n"
"functional programming textbooks: **filter-map fusion**.\n"
"\n"
"ยง0\n"
"\n"
"Filtering after mapping equals mapping after filtering with a composed\n"
"predicate. Instead of building an intermediate list (ยง1) and then\n"
"filtering it, you can filter the *original* list by the composed predicate\n"
"ยง2 and map only the elements that pass.\n"
"\n"
"Without our automation tools, this would take 6+ manual lines. With\n"
"ยง3 on both ยง4 and ยง5, and ยง6 finding the IH:\n"
"\n"
"ยง7\n"
"\n"
"- ยง8 expands both sides one step.\n"
"- ยง9 splits on whether the element passes the filter.\n"
"- ยง10 connects ยง11 to ยง12,\n"
"  simplifies the ยง13 branches, and uses the IH."
msgstr "The payoff level. This theorem appears in compilers, query optimizers, and\n"
"functional programming textbooks: **filter-map fusion**.\n"
"\n"
"ยง0\n"
"\n"
"Filtering after mapping equals mapping after filtering with a composed\n"
"predicate. Instead of building an intermediate list (ยง1) and then\n"
"filtering it, you can filter the *original* list by the composed predicate\n"
"ยง2 and map only the elements that pass.\n"
"\n"
"Without our automation tools, this would take 6+ manual lines. With\n"
"ยง3 on both ยง4 and ยง5, and ยง6 finding the IH:\n"
"\n"
"ยง7\n"
"\n"
"- ยง8 expands both sides one step.\n"
"- ยง9 splits on whether the element passes the filter.\n"
"- ยง10 connects ยง11 to ยง12,\n"
"  simplifies the ยง13 branches, and uses the IH."

#. ยง0: `myGcd`
#. ยง1: ```
#. def myCoprime (a b : Nat) : Prop := myGcd a b = 1
#. ```
#. ยง2: `myCoprime a b`
#. ยง3: `myGcd a b = 1`
#. ยง4: `constructor`
#. ยง5: `โ`
#: Game.Levels.FirstProofs.L06_Coprime
msgid "Two numbers are **coprime** (or relatively prime) if their GCD equals 1.\n"
"This is a key concept in number theory and cryptography โ for example,\n"
"RSA encryption requires finding large coprime numbers.\n"
"\n"
"We define coprimality using ยง0:\n"
"ยง1\n"
"\n"
"Prove that ยง2 is logically equivalent to ยง3.\n"
"\n"
"*Tip*: Use ยง4 to split a biconditional ยง5 into two implications."
msgstr "Two numbers are **coprime** (or relatively prime) if their GCD equals 1.\n"
"This is a key concept in number theory and cryptography โ for example,\n"
"RSA encryption requires finding large coprime numbers.\n"
"\n"
"We define coprimality using ยง0:\n"
"ยง1\n"
"\n"
"Prove that ยง2 is logically equivalent to ยง3.\n"
"\n"
"*Tip*: Use ยง4 to split a biconditional ยง5 into two implications."

#: Game.Levels.DataInvariants
msgid "**World 5: Data Invariants**\n"
"\n"
"Maintain invariants over data structures: sorted lists, balanced trees,\n"
"and how to carry proofs alongside data so that structural invariants can\n"
"never be violated by construction.\n"
"\n"
"*Coming soon!*"
msgstr "**World 5: Data Invariants**\n"
"\n"
"Maintain invariants over data structures: sorted lists, balanced trees,\n"
"and how to carry proofs alongside data so that structural invariants can\n"
"never be violated by construction.\n"
"\n"
"*Coming soon!*"

#. ยง0: `{n : Nat // P n}`
#. ยง1: `โจn, hโฉ`
#. ยง2: `n : Nat`
#. ยง3: `h : P n`
#. ยง4: `h`
#. ยง5: ```lean
#. abbrev EvenNat := {n : Nat // n % 2 = 0}
#. ```
#. ยง6: `EvenNat`
#. ยง7: ```lean
#. -- This compiles: 4 is even
#. example : EvenNat := โจ4, by omegaโฉ
#. 
#. -- This is a type error: 3 is not even
#. -- example : EvenNat := โจ3, by omegaโฉ  -- omega can't prove 3 % 2 = 0
#. ```
#. ยง8: `n + n`
#. ยง9: `omega`
#: Game.Levels.ProofsInTypes.L01_Subtype
msgid "In Lean, ยง0 is a **subtype** โ a type whose values are pairs ยง1\n"
"where ยง2 and ยง3. The proof ยง4 is packed directly inside the value.\n"
"\n"
"For example:\n"
"ยง5\n"
"A value of type ยง6 is guaranteed to be even โ not by a runtime check, but by its type.\n"
"\n"
"ยง7\n"
"\n"
"The compiler is now the gatekeeper. To prove ยง8 is always even, use ยง9."
msgstr "In Lean, ยง0 is a **subtype** โ a type whose values are pairs ยง1\n"
"where ยง2 and ยง3. The proof ยง4 is packed directly inside the value.\n"
"\n"
"For example:\n"
"ยง5\n"
"A value of type ยง6 is guaranteed to be even โ not by a runtime check, but by its type.\n"
"\n"
"ยง7\n"
"\n"
"The compiler is now the gatekeeper. To prove ยง8 is always even, use ยง9."

#: GameServer.RpcHandlers
msgid "level completed with warningsโฆ ๐ญ"
msgstr "level completed with warningsโฆ ๐ญ"

#. ยง0: ```
#. (xs ++ ys).length = xs.length + ys.length
#. ```
#. ยง1: `xs`
#. ยง2: `ys`
#. ยง3: `xs`
#. ยง4: `xs = []`
#. ยง5: `xs = x :: xs'`
#. ยง6: `xs'`
#: Game.Levels.FirstProofs.L03_ListLength
msgid "Lists are everywhere in programming. Here's a fundamental property:\n"
"if you concatenate two lists, the length of the result is the sum of their lengths.\n"
"ยง0\n"
"\n"
"Prove this for **all** lists ยง1 and ยง2 of natural numbers.\n"
"\n"
"You'll need to reason by **structural induction** on the list ยง3:\n"
"- **Base case**: ยง4 โ the empty list is easy.\n"
"- **Inductive step**: ยง5 โ use the *induction hypothesis* about ยง6."
msgstr "Lists are everywhere in programming. Here's a fundamental property:\n"
"if you concatenate two lists, the length of the result is the sum of their lengths.\n"
"ยง0\n"
"\n"
"Prove this for **all** lists ยง1 and ยง2 of natural numbers.\n"
"\n"
"You'll need to reason by **structural induction** on the list ยง3:\n"
"- **Base case**: ยง4 โ the empty list is easy.\n"
"- **Inductive step**: ยง5 โ use the *induction hypothesis* about ยง6."

#: Game.Levels.PurePrograms.L01_MyMap
msgid "Apply a function to every element of a list."
msgstr "Apply a function to every element of a list."

#. ยง0: ```lean
#. def bstInsert (x : Nat) : Tree Nat โ Tree Nat
#.   | .leaf       => .node .leaf x .leaf
#.   | .node l y r =>
#.     if x < y then .node (bstInsert x l) y r
#.     else if y < x then .node l y (bstInsert x r)
#.     else .node l y r   -- x = y: already present
#. 
#. def bstMember (x : Nat) : Tree Nat โ Bool
#.   | .leaf       => false
#.   | .node l y r =>
#.     if x < y then bstMember x l
#.     else if y < x then bstMember x r
#.     else true
#. ```
#. ยง1: `x`
#. ยง2: `x`
#. ยง3: `true`
#. ยง4: `induction t`
#. ยง5: `leaf`
#. ยง6: `simp [bstInsert, bstMember]`
#. ยง7: `node`
#. ยง8: `simp only [bstInsert]`
#. ยง9: `by_cases h : x < y`
#. ยง10: `simp [h, bstMember, ...]`
#: Game.Levels.PurePrograms.L06_BST
msgid "A **Binary Search Tree (BST)** stores values in sorted order so we can search in\n"
"O(log n) time. The key property: every value in the left subtree is smaller than\n"
"the node's value, and every value in the right subtree is larger.\n"
"\n"
"ยง0\n"
"\n"
"**Your goal**: prove that after inserting ยง1, searching for ยง2 always returns ยง3.\n"
"\n"
"*Hint*: Use ยง4. For the ยง5 case, ยง6 closes it.\n"
"For the ยง7 case, use ยง8 to unfold the insert, then\n"
"ยง9 to split on the comparison, and close each branch with\n"
"ยง10."
msgstr "A **Binary Search Tree (BST)** stores values in sorted order so we can search in\n"
"O(log n) time. The key property: every value in the left subtree is smaller than\n"
"the node's value, and every value in the right subtree is larger.\n"
"\n"
"ยง0\n"
"\n"
"**Your goal**: prove that after inserting ยง1, searching for ยง2 always returns ยง3.\n"
"\n"
"*Hint*: Use ยง4. For the ยง5 case, ยง6 closes it.\n"
"For the ยง7 case, use ยง8 to unfold the insert, then\n"
"ยง9 to split on the comparison, and close each branch with\n"
"ยง10."

#: Game.Levels.PurePrograms.L05_Tree
msgid "Binary Trees"
msgstr "Binary Trees"

#: Game.Levels.PurePrograms.L03_MyFoldr
msgid "Fold a list from the right with a binary function and initial value."
msgstr "Fold a list from the right with a binary function and initial value."

#. ยง0: `intro h`
#. ยง1: `h : myCoprime a b`
#. ยง2: `exact h`
#: Game.Levels.FirstProofs.L06_Coprime
msgid "The forward direction: ยง0 gives ยง1. Use ยง2."
msgstr "The forward direction: ยง0 gives ยง1. Use ยง2."

#. ยง0: `simp [double]`
#. ยง1: `double`
#: Game.Levels.FirstProofs.L01_Double
msgid "Lean accepted your proof!\n"
"\n"
"ยง0 unfolded the definition of ยง1 and closed the goal by reflexivity.\n"
"\n"
"You have formally verified your first program. Welcome to program verification!"
msgstr "Lean accepted your proof!\n"
"\n"
"ยง0 unfolded the definition of ยง1 and closed the goal by reflexivity.\n"
"\n"
"You have formally verified your first program. Welcome to program verification!"

#. ยง0: `l`
#. ยง1: `cons`
#. ยง2: `simp only [myMap_cons, myFilter_cons]`
#. ยง3: `cases h : p (f x) <;> simp_all [Function.comp_apply]`
#: Game.Levels.AutomationPower.L07_FilterMap
msgid "Induct on ยง0. For the ยง1 case:\n"
"ยง2, then\n"
"ยง3."
msgstr "Induct on ยง0. For the ยง1 case:\n"
"ยง2, then\n"
"ยง3."

#. ยง0: `insertSorted`
#: Game.Levels.ProofsInTypes.L07_InsertSorted
msgid "Proved once, trusted forever. Any call to ยง0 on a sorted list yields\n"
"a sorted list โ the compiler will hold us to this contract on every use."
msgstr "Proved once, trusted forever. Any call to ยง0 on a sorted list yields\n"
"a sorted list โ the compiler will hold us to this contract on every use."

#. ยง0: `SortedList`
#. ยง1: `Sorted data`
#: Game.Levels.ProofsInTypes.L06_SortedList
msgid "The empty ยง0 has ยง1."
msgstr "The empty ยง0 has ยง1."

#: Game.Levels.ProofsInTypes.L05_Sorted
msgid "Sorted: An Inductive Predicate"
msgstr "Sorted: An Inductive Predicate"

#. ยง0: `Sorted (x :: y :: ys)`
#. ยง1: `x โค y`
#: Game.Levels.ProofsInTypes.L05_Sorted
msgid "If ยง0, then ยง1"
msgstr "If ยง0, then ยง1"

#: Game.Levels.PurePrograms.L06_BST
msgid "Binary Search Tree"
msgstr "Binary Search Tree"

#. ยง0: `simp [Sorted] at h`
#. ยง1: `h`
#. ยง2: `.1`
#. ยง3: `โง`
#: Game.Levels.ProofsInTypes.L05_Sorted
msgid "ยง0 unfolds the predicate in hypothesis ยง1. Then ยง2 extracts the left part of ยง3."
msgstr "ยง0 unfolds the predicate in hypothesis ยง1. Then ยง2 extracts the left part of ยง3."

#. ยง0: `Fin n`
#. ยง1: `n`
#. ยง2: `.val : Nat`
#. ยง3: `.isLt : val < n`
#. ยง4: ```lean
#. -- This compiles: 3 < 5
#. example : Fin 5 := โจ3, by omegaโฉ
#. 
#. -- This is a type error: 7 < 5 is false
#. -- example : Fin 5 := โจ7, by omegaโฉ  -- omega can't prove 7 < 5
#. ```
#. ยง5: `Fin`
#. ยง6: `Option`
#: Game.Levels.ProofsInTypes.L03_Fin
msgid "ยง0 is Lean's built-in type of natural numbers **strictly less than ยง1**.\n"
"It's a subtype with two fields:\n"
"- ยง2 โ the number\n"
"- ยง3 โ the proof it's in bounds\n"
"\n"
"ยง4\n"
"\n"
"Array indexing with ยง5 is **always safe** โ no runtime bounds check, no ยง6,\n"
"no panic. The bound is verified once, at compile time."
msgstr "ยง0 is Lean's built-in type of natural numbers **strictly less than ยง1**.\n"
"It's a subtype with two fields:\n"
"- ยง2 โ the number\n"
"- ยง3 โ the proof it's in bounds\n"
"\n"
"ยง4\n"
"\n"
"Array indexing with ยง5 is **always safe** โ no runtime bounds check, no ยง6,\n"
"no panic. The bound is verified once, at compile time."

#. ยง0: `map`
#. ยง1: ```lean
#. def myMap {ฮฑ ฮฒ : Type} (f : ฮฑ โ ฮฒ) : List ฮฑ โ List ฮฒ
#.   | []      => []
#.   | x :: xs => f x :: myMap f xs
#. ```
#. ยง2: `myMap`
#. ยง3: `f : ฮฑ โ ฮฒ`
#. ยง4: `ฮฑ`
#. ยง5: `ฮฒ`
#. ยง6: `myMap`
#. ยง7: `induction`
#. ยง8: `simp [myMap]`
#: Game.Levels.PurePrograms.L01_MyMap
msgid "In functional programming, ยง0 applies a function to every element of a list.\n"
"Let's define our own version and prove a key property about it.\n"
"\n"
"ยง1\n"
"\n"
"ยง2 takes a function ยง3 and a list of ยง4s, returning a list of ยง5s.\n"
"The output list has the same number of elements as the input.\n"
"\n"
"**Your goal**: prove that ยง6 preserves the length of any list.\n"
"\n"
"*Hint*: Use ยง7 on the list, then ยง8 with the induction hypothesis."
msgstr "In functional programming, ยง0 applies a function to every element of a list.\n"
"Let's define our own version and prove a key property about it.\n"
"\n"
"ยง1\n"
"\n"
"ยง2 takes a function ยง3 and a list of ยง4s, returning a list of ยง5s.\n"
"The output list has the same number of elements as the input.\n"
"\n"
"**Your goal**: prove that ยง6 preserves the length of any list.\n"
"\n"
"*Hint*: Use ยง7 on the list, then ยง8 with the induction hypothesis."

#. ยง0: `intro a b h`
#. ยง1: `cases b`
#. ยง2: `b = 0`
#. ยง3: `b = b' + 1`
#: Game.Levels.FirstProofs.L05_GcdStep
msgid "Use ยง0, then ยง1 to split on whether ยง2 or ยง3."
msgstr "Use ยง0, then ยง1 to split on whether ยง2 or ยง3."

#. ยง0: `b โ 0`
#. ยง1: `myGcd a b = myGcd b (a % b)`
#: Game.Levels.FirstProofs.L05_GcdStep
msgid "When ยง0, ยง1."
msgstr "When ยง0, ยง1."

#. ยง0: ```
#. def isEven (n : Nat) : Prop := n % 2 = 0
#. ```
#. ยง1: `double n = n + n`
#. ยง2: `simp [isEven, double]`
#. ยง3: `omega`
#: Game.Levels.FirstProofs.L02_IsEven
msgid "A natural number is **even** if it is divisible by 2.\n"
"We can express this as a proposition in Lean:\n"
"ยง0\n"
"\n"
"In the previous level, you proved that ยง1.\n"
"Now prove that doubling any number always produces an even number.\n"
"\n"
"*Tip*: ยง2 can unfold both definitions at once,\n"
"then ยง3 handles the arithmetic."
msgstr "A natural number is **even** if it is divisible by 2.\n"
"We can express this as a proposition in Lean:\n"
"ยง0\n"
"\n"
"In the previous level, you proved that ยง1.\n"
"Now prove that doubling any number always produces an even number.\n"
"\n"
"*Tip*: ยง2 can unfold both definitions at once,\n"
"then ยง3 handles the arithmetic."

#: Game.Levels.ProofsInTypes
msgid "Proofs Packed in Types"
msgstr "Proofs Packed in Types"

#: Game.Levels.PurePrograms.L06_BST
msgid "Search for a value in a BST."
msgstr "Search for a value in a BST."

#. ยง0: `simp [isEven, double]`
#: Game.Levels.FirstProofs.L02_IsEven
msgid "Try ยง0 to unfold both definitions."
msgstr "Try ยง0 to unfold both definitions."

#. ยง0: `mvcgen`
#: Game.Levels.ImperativeBoss
msgid "**World 8: Imperative Boss**\n"
"\n"
"The final challenge: verify a complete imperative algorithm using loop\n"
"invariants and the ยง0 framework. Everything comes together here โ\n"
"functional specs, termination proofs, data invariants, and Hoare logic โ\n"
"applied to real imperative code.\n"
"\n"
"*Coming soon!*"
msgstr "**World 8: Imperative Boss**\n"
"\n"
"The final challenge: verify a complete imperative algorithm using loop\n"
"invariants and the ยง0 framework. Everything comes together here โ\n"
"functional specs, termination proofs, data invariants, and Hoare logic โ\n"
"applied to real imperative code.\n"
"\n"
"*Coming soon!*"

#. ยง0: `simp_all`
#. ยง1: `simp`
#. ยง2: `@[simp]`
#. ยง3: `myMap`
#. ยง4: `@[simp]`
#. ยง5: `simp`
#. ยง6: `simp [myMap]`
#. ยง7: `grind`
#. ยง8: `grind [lemma, ...]`
#. ยง9: `myMap`
#. ยง10: `myFilter`
#: Game.Levels.AutomationPower
msgid "Welcome to **World 3: Automation Power**!\n"
"\n"
"You've proven programs correct one tactic at a time. Now we hand more\n"
"work to Lean's automation machinery โ the same proofs that took five\n"
"lines before will often collapse to one or two.\n"
"\n"
"**New tools in this world**:\n"
"\n"
"- **ยง0** โ like ยง1, but also rewrites using every hypothesis\n"
"  in the context. The induction hypothesis becomes automatic.\n"
"- **ยง2** โ an *attribute* that marks a theorem as a simplification\n"
"  rule. After tagging the equations of ยง3 with ยง4, plain\n"
"  ยง5 knows about them everywhere โ no need to write ยง6.\n"
"- **ยง7** โ an automated prover combining equality reasoning and\n"
"  arithmetic. Feed it hints with ยง8 and it hunts for\n"
"  a proof automatically.\n"
"\n"
"You'll revisit ยง9, ยง10, and the BST from World 2 โ and\n"
"prove brand-new theorems about them with far less effort."
msgstr "Welcome to **World 3: Automation Power**!\n"
"\n"
"You've proven programs correct one tactic at a time. Now we hand more\n"
"work to Lean's automation machinery โ the same proofs that took five\n"
"lines before will often collapse to one or two.\n"
"\n"
"**New tools in this world**:\n"
"\n"
"- **ยง0** โ like ยง1, but also rewrites using every hypothesis\n"
"  in the context. The induction hypothesis becomes automatic.\n"
"- **ยง2** โ an *attribute* that marks a theorem as a simplification\n"
"  rule. After tagging the equations of ยง3 with ยง4, plain\n"
"  ยง5 knows about them everywhere โ no need to write ยง6.\n"
"- **ยง7** โ an automated prover combining equality reasoning and\n"
"  arithmetic. Feed it hints with ยง8 and it hunts for\n"
"  a proof automatically.\n"
"\n"
"You'll revisit ยง9, ยง10, and the BST from World 2 โ and\n"
"prove brand-new theorems about them with far less effort."

#: Game.Levels.AutomationPower
msgid "Automation Power"
msgstr "Automation Power"

#. ยง0: `exact e.2`
#. ยง1: `exact e.property`
#: Game.Levels.ProofsInTypes.L02_SubtypeAccess
msgid "Try ยง0 or ยง1."
msgstr "Try ยง0 or ยง1."

#: Game.Levels.AutomationPower.L05_FilterPartition
msgid "Filter Partitions a List"
msgstr "Filter Partitions a List"

#. ยง0: `intro n`
#: Game.Levels.FirstProofs.L02_IsEven
msgid "Start with ยง0 to introduce the variable."
msgstr "Start with ยง0 to introduce the variable."

#: Game.Levels.ProofsInTypes.L07_InsertSorted
msgid "Inserting into a sorted list yields a sorted list."
msgstr "Inserting into a sorted list yields a sorted list."

#. ยง0: `do`
#: Game.Levels.ImperativeIntro.L01_Stub
msgid "This world is under construction.\n"
"\n"
"**World 7: Imperative Intro** will teach you to verify imperative programs\n"
"that use mutable state, loops, and ยง0 notation โ and prove they meet their\n"
"functional specifications.\n"
"\n"
"Check back soon!"
msgstr "This world is under construction.\n"
"\n"
"**World 7: Imperative Intro** will teach you to verify imperative programs\n"
"that use mutable state, loops, and ยง0 notation โ and prove they meet their\n"
"functional specifications.\n"
"\n"
"Check back soon!"

#. ยง0: `n`
#: Game.Levels.ProofsInTypes.L03_Fin
msgid "Type of natural numbers strictly less than ยง0, bundled with the proof."
msgstr "Type of natural numbers strictly less than ยง0, bundled with the proof."

#. ยง0: `x :: xs`
#. ยง1: `simp [ih]`
#. ยง2: `omega`
#: Game.Levels.FirstProofs.L03_ListLength
msgid "For ยง0, try ยง1 then ยง2 for the arithmetic."
msgstr "For ยง0, try ยง1 then ยง2 for the arithmetic."

#. ยง0: `ยฌp`
#. ยง1: `if p then a else b = b`
#: Game.Levels.ProofsInTypes.L07_InsertSorted
#: Game.Levels.ProofsInTypes.L07_InsertSorted
msgid "If ยง0, then ยง1."
msgstr "If ยง0, then ยง1."

#: Game.Levels.AutomationPower.L04_MapAppend
msgid "Map Distributes Over Append"
msgstr "Map Distributes Over Append"

#. ยง0: `rfl`
#. ยง1: `safeHead (x :: xs) _`
#. ยง2: `x`
#. ยง3: `none`
#: Game.Levels.ProofsInTypes.L04_SafeHead
msgid "ยง0 works because ยง1 *definitionally equals* ยง2.\n"
"The compiler verified the precondition; we never needed to handle ยง3."
msgstr "ยง0 works because ยง1 *definitionally equals* ยง2.\n"
"The compiler verified the precondition; we never needed to handle ยง3."

#. ยง0: `a`
#. ยง1: `b`
#. ยง2: `myGcd a b = 1`
#: Game.Levels.FirstProofs.L06_Coprime
msgid "ยง0 and ยง1 are coprime iff ยง2."
msgstr "ยง0 and ยง1 are coprime iff ยง2."

#: Game.Levels.PurePrograms.L07_Expr
msgid "Expression Evaluator"
msgstr "Expression Evaluator"

#: Game.Levels.AutomationPower.L06_GrindBST
msgid "BST Insert: simp_all in Action"
msgstr "BST Insert: simp_all in Action"

#: Game.Levels.FirstProofs.L03_ListLength
msgid "Length of Lists"
msgstr "Length of Lists"

#. ยง0: `intro xs ys`
#. ยง1: `induction xs`
#: Game.Levels.FirstProofs.L03_ListLength
msgid "Start with ยง0, then use ยง1."
msgstr "Start with ยง0, then use ยง1."

#: Game.Levels.FirstProofs.L01_Double
msgid "Double or Nothing"
msgstr "Double or Nothing"

#: Game.Levels.FirstProofs.L07_Primality
msgid "Is This Prime?"
msgstr "Is This Prime?"

#: Game.Levels.ProofsInTypes.L04_SafeHead
msgid "Safe Head: Proof-Carrying Functions"
msgstr "Safe Head: Proof-Carrying Functions"

#. ยง0: `@[simp]`
#. ยง1: `myMap`
#. ยง2: `simp_all`
#. ยง3: `@[simp]`
#. ยง4: `@[simp]`
#. ยง5: `simp`
#. ยง6: `simp_all`
#: Game.Levels.AutomationPower.L02_SimpAttr
msgid "ยง0 turned ยง1's equation lemmas into permanent simplification rules.\n"
"ยง2 then used them (plus the IH) to close both the base and inductive cases\n"
"without any manual guidance.\n"
"\n"
"This is the ยง3 workflow:\n"
"1. Tag your function's equations with ยง4.\n"
"2. From then on, use plain ยง5 or ยง6 โ no hints needed."
msgstr "ยง0 turned ยง1's equation lemmas into permanent simplification rules.\n"
"ยง2 then used them (plus the IH) to close both the base and inductive cases\n"
"without any manual guidance.\n"
"\n"
"This is the ยง3 workflow:\n"
"1. Tag your function's equations with ยง4.\n"
"2. From then on, use plain ยง5 or ยง6 โ no hints needed."

#. ยง0: `double n = n + n`
#: Game.Levels.FirstProofs.L01_Double
#: Game.Levels.FirstProofs.L02_IsEven
#: Game.Levels.FirstProofs.L03_ListLength
#: Game.Levels.FirstProofs.L04_GcdBase
#: Game.Levels.FirstProofs.L06_Coprime
#: Game.Levels.PurePrograms.L01_MyMap
#: Game.Levels.PurePrograms.L02_MyFilter
#: Game.Levels.PurePrograms.L03_MyFoldr
#: Game.Levels.PurePrograms.L05_Tree
#: Game.Levels.PurePrograms.L06_BST
#: Game.Levels.PurePrograms.L07_Expr
#: Game.Levels.PurePrograms.L07_Expr
#: Game.Levels.AutomationPower.L02_SimpAttr
#: Game.Levels.AutomationPower.L02_SimpAttr
#: Game.Levels.AutomationPower.L02_SimpAttr
#: Game.Levels.AutomationPower.L02_SimpAttr
#: Game.Levels.AutomationPower.L03_Grind
#: Game.Levels.AutomationPower.L03_Grind
#: Game.Levels.AutomationPower.L04_MapAppend
#: Game.Levels.AutomationPower.L05_FilterPartition
#: Game.Levels.AutomationPower.L05_FilterPartition
#: Game.Levels.AutomationPower.L05_FilterPartition
#: Game.Levels.AutomationPower.L07_FilterMap
#: Game.Levels.ProofsInTypes.L04_SafeHead
#: Game.Levels.ProofsInTypes.L07_InsertSorted
#: Game.Levels.ProofsInTypes.L08_Victory
msgid "ยง0"
msgstr "ยง0"

#. ยง0: `myFilter p l`
#. ยง1: `l`
#. ยง2: `p`
#: Game.Levels.AutomationPower.L05_FilterPartition
msgid "ยง0 returns the sublist of ยง1 whose elements satisfy predicate ยง2."
msgstr "ยง0 returns the sublist of ยง1 whose elements satisfy predicate ยง2."

#: Game.Levels.ProofsInTypes.L07_InsertSorted
msgid "insertSorted: Preserving the Invariant"
msgstr "insertSorted: Preserving the Invariant"

#. ยง0: `SortedList.insert`
#. ยง1: `.data`
#. ยง2: `insertSorted x sl.data`
#. ยง3: `insertSorted_mem`
#: Game.Levels.ProofsInTypes.L08_Victory
msgid "Unfold ยง0. The result's ยง1 is ยง2.\n"
"Then apply ยง3."
msgstr "Unfold ยง0. The result's ยง1 is ยง2.\n"
"Then apply ยง3."

#. ยง0: `filter`
#. ยง1: `Bool`
#. ยง2: ```lean
#. def myFilter {ฮฑ : Type} (p : ฮฑ โ Bool) : List ฮฑ โ List ฮฑ
#.   | []      => []
#.   | x :: xs => if p x then x :: myFilter p xs else myFilter p xs
#. ```
#. ยง3: `p x`
#. ยง4: `true`
#. ยง5: `x`
#. ยง6: `simp [myFilter]`
#. ยง7: `split`
#. ยง8: `p x`
#. ยง9: `simp_all`
#. ยง10: `omega`
#: Game.Levels.PurePrograms.L02_MyFilter
msgid "ยง0 keeps only the elements that satisfy a predicate (a function returning ยง1).\n"
"\n"
"ยง2\n"
"\n"
"When ยง3 is ยง4, we keep ยง5; otherwise we drop it.\n"
"\n"
"**Your goal**: prove that filtering never makes a list longer.\n"
"\n"
"*Hint*: After ยง6, use ยง7 to case-split on whether ยง8 is true or false,\n"
"then finish with ยง9 and ยง10."
msgstr "ยง0 keeps only the elements that satisfy a predicate (a function returning ยง1).\n"
"\n"
"ยง2\n"
"\n"
"When ยง3 is ยง4, we keep ยง5; otherwise we drop it.\n"
"\n"
"**Your goal**: prove that filtering never makes a list longer.\n"
"\n"
"*Hint*: After ยง6, use ยง7 to case-split on whether ยง8 is true or false,\n"
"then finish with ยง9 and ยง10."

#. ยง0: `e : EvenNat`
#. ยง1: `e.val % 2 = 0`
#: Game.Levels.ProofsInTypes.L02_SubtypeAccess
#: Game.Levels.ProofsInTypes.L03_Fin
msgid "For any ยง0, ยง1"
msgstr "For any ยง0, ยง1"

#. ยง0: `SortedList`
#. ยง1: `SortedList`
#: Game.Levels.ProofsInTypes.L06_SortedList
msgid "ยง0 bakes the invariant into the type. You get correctness for free โ\n"
"any function that takes a ยง1 can trust it's sorted, no check needed."
msgstr "ยง0 bakes the invariant into the type. You get correctness for free โ\n"
"any function that takes a ยง1 can trust it's sorted, no check needed."

#. ยง0: `i.isLt`
#. ยง1: `Fin`
#: Game.Levels.ProofsInTypes.L03_Fin
msgid "ยง0 is always there, always valid. That's the promise of ยง1."
msgstr "ยง0 is always there, always valid. That's the promise of ยง1."

#. ยง0: ```lean
#. def half (n : Nat) : Nat :=
#.   if n < 2 then 0 else 1 + half (n - 2)
#. ```
#. ยง1: `n - 2`
#. ยง2: `n`
#. ยง3: `n - 2 < n`
#. ยง4: ```lean
#. def half (n : Nat) : Nat :=
#.   if n < 2 then 0 else 1 + half (n - 2)
#. termination_by n
#. decreasing_by omega
#. ```
#. ยง5: `termination_by n`
#. ยง6: `n`
#. ยง7: `decreasing_by omega`
#. ยง8: `omega`
#. ยง9: `n - 2 < n`
#. ยง10: `ยฌ(n < 2)`
#. ยง11: `half`
#. ยง12: `native_decide`
#. ยง13: `decreasing_by omega`
#. ยง14: `n โฅ 2`
#. ยง15: `n - 2 < n`
#. ยง16: `omega`
#: Game.Levels.PurePrograms.L04_Half
msgid "Until now, every recursive function you've seen has been **structurally recursive**:\n"
"each recursive call is on a smaller piece of the input (a tail, a subtree).\n"
"Lean accepts these automatically.\n"
"\n"
"But what about this?\n"
"\n"
"ยง0\n"
"\n"
"Lean **rejects** this without a termination proof! The recursive call is on ยง1,\n"
"not a structural predecessor of ยง2. Lean can't automatically verify that ยง3.\n"
"\n"
"We fix this with a **termination measure**:\n"
"\n"
"ยง4\n"
"\n"
"ยง5 says: *the measure is just ยง6 itself*.\n"
"ยง7 says: *trust ยง8 to prove ยง9 when ยง10*.\n"
"\n"
"**Your goal** has two parts:\n"
"1. Verify concrete values of ยง11 (using ยง12).\n"
"2. Prove the key arithmetic fact that makes ยง13 work: when ยง14, we have ยง15.\n"
"\n"
"The second part is exactly the inequality ยง16 closes automatically โ try it manually!"
msgstr "Until now, every recursive function you've seen has been **structurally recursive**:\n"
"each recursive call is on a smaller piece of the input (a tail, a subtree).\n"
"Lean accepts these automatically.\n"
"\n"
"But what about this?\n"
"\n"
"ยง0\n"
"\n"
"Lean **rejects** this without a termination proof! The recursive call is on ยง1,\n"
"not a structural predecessor of ยง2. Lean can't automatically verify that ยง3.\n"
"\n"
"We fix this with a **termination measure**:\n"
"\n"
"ยง4\n"
"\n"
"ยง5 says: *the measure is just ยง6 itself*.\n"
"ยง7 says: *trust ยง8 to prove ยง9 when ยง10*.\n"
"\n"
"**Your goal** has two parts:\n"
"1. Verify concrete values of ยง11 (using ยง12).\n"
"2. Prove the key arithmetic fact that makes ยง13 work: when ยง14, we have ยง15.\n"
"\n"
"The second part is exactly the inequality ยง16 closes automatically โ try it manually!"

#. ยง0: `native_decide`
#: Game.Levels.FirstProofs.L07_Primality
msgid "All of these are concrete computations. Try ยง0!"
msgstr "All of these are concrete computations. Try ยง0!"

#. ยง0: ```
#. def myGcd (a b : Nat) : Nat :=
#.   match b with
#.   | 0     => a
#.   | b' + 1 => myGcd (b' + 1) (a % (b' + 1))
#. ```
#. ยง1: `(a, b)`
#. ยง2: `(b, a % b)`
#. ยง3: `b = 0`
#. ยง4: `b = 0`
#. ยง5: `myGcd a 0 = a`
#: Game.Levels.FirstProofs.L04_GcdBase
msgid "The **Euclidean algorithm** is one of the oldest algorithms in mathematics.\n"
"It computes the greatest common divisor (GCD) of two numbers:\n"
"ยง0\n"
"\n"
"The algorithm works by repeatedly replacing ยง1 with ยง2 until ยง3.\n"
"\n"
"Prove the **base case**: when ยง4, ยง5."
msgstr "The **Euclidean algorithm** is one of the oldest algorithms in mathematics.\n"
"It computes the greatest common divisor (GCD) of two numbers:\n"
"ยง0\n"
"\n"
"The algorithm works by repeatedly replacing ยง1 with ยง2 until ยง3.\n"
"\n"
"Prove the **base case**: when ยง4, ยง5."

#. ยง0: `List.head?`
#. ยง1: `Option ฮฑ`
#. ยง2: `none`
#. ยง3: ```lean
#. def safeHead {ฮฑ : Type} (l : List ฮฑ) (_ : l โ []) : ฮฑ :=
#.   match l with
#.   | x :: _ => x
#.   | []      => by contradiction
#. ```
#. ยง4: `safeHead [] h`
#. ยง5: `[] โ []`
#. ยง6: `ฮฑ`
#. ยง7: `Option`
#. ยง8: `safeHead`
#. ยง9: `safeHead`
#: Game.Levels.ProofsInTypes.L04_SafeHead
msgid "ยง0 returns ยง1 โ safe, but forces callers to handle ยง2 everywhere,\n"
"even when they *know* the list is non-empty.\n"
"\n"
"Instead, we can demand a **proof** of non-emptiness as an argument:\n"
"\n"
"ยง3\n"
"\n"
"Calling ยง4 is a **type error** โ you cannot provide a proof of ยง5.\n"
"The function returns ยง6 directly; no ยง7 unwrapping needed.\n"
"\n"
"The statement below says ยง8 on a cons list returns the head element. Because\n"
"ยง9 reduces definitionally, the proof is trivial."
msgstr "ยง0 returns ยง1 โ safe, but forces callers to handle ยง2 everywhere,\n"
"even when they *know* the list is non-empty.\n"
"\n"
"Instead, we can demand a **proof** of non-emptiness as an argument:\n"
"\n"
"ยง3\n"
"\n"
"Calling ยง4 is a **type error** โ you cannot provide a proof of ยง5.\n"
"The function returns ยง6 directly; no ยง7 unwrapping needed.\n"
"\n"
"The statement below says ยง8 on a cons list returns the head element. Because\n"
"ยง9 reduces definitionally, the proof is trivial."

#. ยง0: `omega`
#: Game.Levels.FirstProofs.L02_IsEven
msgid "The remaining goal is an arithmetic fact. Try ยง0."
msgstr "The remaining goal is an arithmetic fact. Try ยง0."

#. ยง0: `(xs ++ ys).length = xs.length + ys.length`
#. ยง1: `simp_all`
#: Game.Levels.AutomationPower.L01_SimpAll
msgid "ยง0 (proved with ยง1)"
msgstr "ยง0 (proved with ยง1)"

#. ยง0: `simp [myGcd]`
#. ยง1: `| 0 => a`
#. ยง2: `a`
#. ยง3: `termination_by b`
#. ยง4: `a % (b' + 1) < b' + 1`
#: Game.Levels.FirstProofs.L04_GcdBase
msgid "ยง0 matched the ยง1 case of the definition and immediately\n"
"returned ยง2. The base case is proved!\n"
"\n"
"Notice ยง3: this tells Lean that the second argument decreases at each\n"
"recursive call (since ยง4). Without this, Lean would reject the definition."
msgstr "ยง0 matched the ยง1 case of the definition and immediately\n"
"returned ยง2. The base case is proved!\n"
"\n"
"Notice ยง3: this tells Lean that the second argument decreases at each\n"
"recursive call (since ยง4). Without this, Lean would reject the definition."

#: Game.Levels.AutomationPower.L02_SimpAttr
msgid "@[simp]: Teaching simp New Rules"
msgstr "@[simp]: Teaching simp New Rules"

#: Game
msgid "Learn to formally verify programs using Lean 4, from basic proofs to imperative algorithms."
msgstr "Learn to formally verify programs using Lean 4, from basic proofs to imperative algorithms."

#: Game.Levels.AutomationPower.L06_GrindBST
msgid "A binary tree: either a leaf or a node with left subtree, value, and right subtree."
msgstr "A binary tree: either a leaf or a node with left subtree, value, and right subtree."

#. ยง0: `isPrime 2 = true`
#. ยง1: `isPrime 3 = true`
#. ยง2: `isPrime 4 = false`
#. ยง3: `isPrime 5 = true`
#: Game.Levels.FirstProofs.L07_Primality
msgid "ยง0, ยง1, ยง2, ยง3"
msgstr "ยง0, ยง1, ยง2, ยง3"

#: Game.Levels.ProofsInTypes.L08_Victory
msgid "World 4 complete! You've packed proofs into types:\n"
"\n"
"- **EvenNat** โ only even numbers can be constructed\n"
"- **Fin n** โ indices that are provably in-bounds\n"
"- **safeHead** โ a head function that cannot be called on empty lists\n"
"- **Sorted** โ a predicate encoding a list's invariant\n"
"- **SortedList** โ a type where sortedness is enforced at construction\n"
"- **SortedList.insert** โ insertion that preserves sortedness, verified once for all time\n"
"\n"
"Onward to World 5: Termination!"
msgstr "World 4 complete! You've packed proofs into types:\n"
"\n"
"- **EvenNat** โ only even numbers can be constructed\n"
"- **Fin n** โ indices that are provably in-bounds\n"
"- **safeHead** โ a head function that cannot be called on empty lists\n"
"- **Sorted** โ a predicate encoding a list's invariant\n"
"- **SortedList** โ a type where sortedness is enforced at construction\n"
"- **SortedList.insert** โ insertion that preserves sortedness, verified once for all time\n"
"\n"
"Onward to World 5: Termination!"

#. ยง0: `omega`
#: Game.Levels.ProofsInTypes.L01_Subtype
msgid "ยง0 closes pure arithmetic goals."
msgstr "ยง0 closes pure arithmetic goals."

#. ยง0: `induction l`
#. ยง1: `simp`
#. ยง2: `cons x xs ih`
#. ยง3: `cases h : p x <;> simp_all <;> omega`
#: Game.Levels.AutomationPower.L05_FilterPartition
msgid "Use ยง0. The base case is ยง1.\n"
"For ยง2, try ยง3."
msgstr "Use ยง0. The base case is ยง1.\n"
"For ยง2, try ยง3."

#. ยง0: `do`
#: Game.Levels.ImperativeIntro
msgid "**World 7: Imperative Intro**\n"
"\n"
"From pure to imperative: verify programs that use mutable state, loops,\n"
"and Lean's ยง0 notation. Learn how functional verification techniques\n"
"extend to imperative programs.\n"
"\n"
"*Coming soon!*"
msgstr "**World 7: Imperative Intro**\n"
"\n"
"From pure to imperative: verify programs that use mutable state, loops,\n"
"and Lean's ยง0 notation. Learn how functional verification techniques\n"
"extend to imperative programs.\n"
"\n"
"*Coming soon!*"

#. ยง0: `.val`
#. ยง1: `.property`
#: Game.Levels.ProofsInTypes.L02_SubtypeAccess
msgid "ยง0 gives the data; ยง1 gives the proof. Both are always present."
msgstr "ยง0 gives the data; ยง1 gives the proof. Both are always present."

#: Game.Levels.AutomationPower.L06_GrindBST
msgid "Insert a value into a binary search tree, maintaining the BST ordering invariant."
msgstr "Insert a value into a binary search tree, maintaining the BST ordering invariant."

#: Game.Levels.AutomationPower.L03_Grind
msgid "grind: The Automated Prover"
msgstr "grind: The Automated Prover"

#. ยง0: `termination_by <measure>`
#. ยง1: `decreasing_by <tactic>`
#. ยง2: `omega`
#: Game.Levels.PurePrograms.L04_Half
msgid "You've hit the termination wall โ and climbed it!\n"
"\n"
"- **Structural recursion**: Lean accepts it for free (lists, trees).\n"
"- **Non-structural recursion**: supply ยง0 and ยง1.\n"
"\n"
"ยง2 is powerful enough to discharge most arithmetic termination obligations.\n"
"You'll see this pattern again in World 4."
msgstr "You've hit the termination wall โ and climbed it!\n"
"\n"
"- **Structural recursion**: Lean accepts it for free (lists, trees).\n"
"- **Non-structural recursion**: supply ยง0 and ยง1.\n"
"\n"
"ยง2 is powerful enough to discharge most arithmetic termination obligations.\n"
"You'll see this pattern again in World 4."

#: Game.Levels.AutomationPower.L07_FilterMap
msgid "Filter-Map Fusion"
msgstr "Filter-Map Fusion"

#. ยง0: `intro n`
#: Game.Levels.FirstProofs.L01_Double
msgid "Start with ยง0 to bring the variable into scope."
msgstr "Start with ยง0 to bring the variable into scope."

#: Game.Levels.ProofsInTypes.L03_Fin
msgid "Fin n: Bounded Naturals"
msgstr "Fin n: Bounded Naturals"

#. ยง0: `simp_all [bstMember]`
#. ยง1: `ihl`
#. ยง2: `simp [h, ...]`
#. ยง3: `simp_all`
#. ยง4: `ยฌ(x < y)`
#. ยง5: `y โค x`
#. ยง6: `simp [h]`
#. ยง7: `if_neg h`
#. ยง8: `simp_all`
#. ยง9: `simp [explicit_hints]`
#: Game.Levels.AutomationPower.L06_GrindBST
msgid "ยง0 in the first branch found the induction hypothesis ยง1\n"
"without being told โ it scanned the context and used it. That's one fewer explicit hint.\n"
"\n"
"The negation branches still use ยง2 because ยง3 normalizes\n"
"ยง4 to ยง5, which can confuse the if-then-else reduction. Plain ยง6\n"
"uses the hypothesis as-is, applying ยง7 directly.\n"
"\n"
"**Takeaway**: ยง8 is a powerful default, but knowing when to fall back to\n"
"ยง9 is part of mastering Lean automation."
msgstr "ยง0 in the first branch found the induction hypothesis ยง1\n"
"without being told โ it scanned the context and used it. That's one fewer explicit hint.\n"
"\n"
"The negation branches still use ยง2 because ยง3 normalizes\n"
"ยง4 to ยง5, which can confuse the if-then-else reduction. Plain ยง6\n"
"uses the hypothesis as-is, applying ยง7 directly.\n"
"\n"
"**Takeaway**: ยง8 is a powerful default, but knowing when to fall back to\n"
"ยง9 is part of mastering Lean automation."

#. ยง0: `Nat`
#: Game.Levels.ProofsInTypes.L07_InsertSorted
msgid "Insert a ยง0 into a sorted list, preserving order."
msgstr "Insert a ยง0 into a sorted list, preserving order."

#. ยง0: `rfl`
#: Game.Levels.ProofsInTypes.L04_SafeHead
msgid "The definition reduces definitionally. Try ยง0."
msgstr "The definition reduces definitionally. Try ยง0."

#. ยง0: `l`
#. ยง1: `cons`
#. ยง2: `by_cases hxy : x โค y`
#. ยง3: `simp only [if_pos hxy]`
#. ยง4: `simp only [if_neg hxy]`
#. ยง5: `simp [Sorted]`
#: Game.Levels.ProofsInTypes.L07_InsertSorted
msgid "Induct on ยง0. For the ยง1 case, use ยง2.\n"
"Then ยง3 or ยง4 to reduce the conditional,\n"
"and ยง5 to unfold the predicate."
msgstr "Induct on ยง0. For the ยง1 case, use ยง2.\n"
"Then ยง3 or ยง4 to reduce the conditional,\n"
"and ยง5 to unfold the predicate."

#: Game.Levels.PrePost.L01_Stub
msgid "This world is under construction.\n"
"\n"
"**World 6: Pre/Post Conditions** will teach Hoare-style reasoning: specifying\n"
"what a function *requires* (preconditions) and *guarantees* (postconditions),\n"
"then proving it meets its contract.\n"
"\n"
"Check back soon!"
msgstr "This world is under construction.\n"
"\n"
"**World 6: Pre/Post Conditions** will teach Hoare-style reasoning: specifying\n"
"what a function *requires* (preconditions) and *guarantees* (postconditions),\n"
"then proving it meets its contract.\n"
"\n"
"Check back soon!"

#. ยง0: `Sorted`
#. ยง1: ```lean
#. structure SortedList where
#.   data   : List Nat
#.   sorted : Sorted data
#. ```
#. ยง2: `SortedList`
#. ยง3: ```lean
#. -- This is a type error โ Sorted [3, 1, 2] requires 3 โค 1, which omega refutes
#. -- example : SortedList := โจ[3, 1, 2], by simp [Sorted]; omegaโฉ
#. ```
#. ยง4: `List Nat + a separate boolean check`
#. ยง5: `SortedList`
#. ยง6: `trivial`
#. ยง7: `Sorted []`
#. ยง8: `Sorted []`
#. ยง9: `True`
#: Game.Levels.ProofsInTypes.L06_SortedList
msgid "We can pack the ยง0 proof directly into a structure:\n"
"\n"
"ยง1\n"
"\n"
"Now it is **impossible** to create an unsorted ยง2:\n"
"\n"
"ยง3\n"
"\n"
"Compare to ยง4: the check might be bypassed,\n"
"forgotten, or tested only in some code paths. With ยง5, there is **no bypass**.\n"
"\n"
"The empty sorted list is constructed with ยง6 for the ยง7 proof,\n"
"since ยง8 unfolds to ยง9."
msgstr "We can pack the ยง0 proof directly into a structure:\n"
"\n"
"ยง1\n"
"\n"
"Now it is **impossible** to create an unsorted ยง2:\n"
"\n"
"ยง3\n"
"\n"
"Compare to ยง4: the check might be bypassed,\n"
"forgotten, or tested only in some code paths. With ยง5, there is **no bypass**.\n"
"\n"
"The empty sorted list is constructed with ยง6 for the ยง7 proof,\n"
"since ยง8 unfolds to ยง9."

#. ยง0: `intro a`
#. ยง1: `simp [myGcd]`
#: Game.Levels.FirstProofs.L04_GcdBase
msgid "Try ยง0 then ยง1."
msgstr "Try ยง0 then ยง1."

#. ยง0: `cases b`
#. ยง1: `b = 0`
#. ยง2: `h : 0 โ 0`
#. ยง3: `omega`
#. ยง4: `b = b' + 1`
#. ยง5: `simp [myGcd]`
#. ยง6: `myGcd (b'+1) (a % (b'+1)) = myGcd (b'+1) (a % (b'+1))`
#. ยง7: `gcd_base`
#: Game.Levels.FirstProofs.L05_GcdStep
msgid "ยง0 split the proof into two cases:\n"
"- ยง1: contradicts ยง2, closed by ยง3.\n"
"- ยง4: ยง5 applied the second equation of the definition,\n"
"  giving ยง6.\n"
"\n"
"Together with ยง7, you have now verified **both equations** of the\n"
"Euclidean algorithm!"
msgstr "ยง0 split the proof into two cases:\n"
"- ยง1: contradicts ยง2, closed by ยง3.\n"
"- ยง4: ยง5 applied the second equation of the definition,\n"
"  giving ยง6.\n"
"\n"
"Together with ยง7, you have now verified **both equations** of the\n"
"Euclidean algorithm!"

#. ยง0: `Fin n`
#. ยง1: `exact i.isLt`
#: Game.Levels.ProofsInTypes.L03_Fin
msgid "Every ยง0 carries a proof field. Can you name it? Try ยง1."
msgstr "Every ยง0 carries a proof field. Can you name it? Try ยง1."

#. ยง0: `b = b' + 1`
#. ยง1: `simp [myGcd]`
#: Game.Levels.FirstProofs.L05_GcdStep
msgid "Now ยง0. Try ยง1 to apply the recursive equation."
msgstr "Now ยง0. Try ยง1 to apply the recursive equation."

#. ยง0: `simp`
#: Game.Levels.FirstProofs.L03_ListLength
msgid "The empty list case: ยง0 handles it."
msgstr "The empty list case: ยง0 handles it."

#. ยง0: `foldr`
#. ยง1: `[]`
#. ยง2: `::`
#. ยง3: ```lean
#. def myFoldr {ฮฑ ฮฒ : Type} (f : ฮฑ โ ฮฒ โ ฮฒ) (init : ฮฒ) : List ฮฑ โ ฮฒ
#.   | []      => init
#.   | x :: xs => f x (myFoldr f init xs)
#. ```
#. ยง4: `myFoldr (ยท + ยท) 0 [1, 2, 3] = 1 + (2 + (3 + 0)) = 6`
#. ยง5: `(ยท :: ยท)`
#. ยง6: `[]`
#. ยง7: `myFoldr (ยท :: ยท) [] [1, 2, 3] = 1 :: (2 :: (3 :: [])) = [1, 2, 3]`
#: Game.Levels.PurePrograms.L03_MyFoldr
msgid "ยง0 is the most general list combinator โ it replaces ยง1 with an initial value\n"
"and ยง2 with a binary function.\n"
"\n"
"ยง3\n"
"\n"
"For example, ยง4.\n"
"\n"
"**Key insight**: if you fold with ยง5 and ยง6, you reconstruct the original list!\n"
"\n"
"ยง7\n"
"\n"
"**Your goal**: prove this identity law formally."
msgstr "ยง0 is the most general list combinator โ it replaces ยง1 with an initial value\n"
"and ยง2 with a binary function.\n"
"\n"
"ยง3\n"
"\n"
"For example, ยง4.\n"
"\n"
"**Key insight**: if you fold with ยง5 and ยง6, you reconstruct the original list!\n"
"\n"
"ยง7\n"
"\n"
"**Your goal**: prove this identity law formally."

#: Game.Levels.PurePrograms
msgid "Pure Programs"
msgstr "Pure Programs"

#. ยง0: `double n = n + n`
#. ยง1: `n`
#: Game.Levels.FirstProofs.L01_Double
msgid "ยง0 for all ยง1."
msgstr "ยง0 for all ยง1."

#: Game.Levels.ProofsInTypes.L06_SortedList
msgid "The empty sorted list."
msgstr "The empty sorted list."

#. ยง0: `myMap`
#. ยง1: `myFilter`
#. ยง2: `myFoldr`
#. ยง3: `half`
#. ยง4: `Tree`
#. ยง5: `treeHeight`
#. ยง6: `bstInsert`
#. ยง7: `bstMember`
#. ยง8: `Expr`
#. ยง9: `eval`
#: Game.Levels.PurePrograms.L07_Expr
msgid "World 2 complete! You've built and verified:\n"
"- **ยง0**, **ยง1**, **ยง2** โ the classic list combinators\n"
"- **ยง3** โ a non-structural recursion with explicit termination proof\n"
"- **ยง4** and **ยง5** โ your own inductive type\n"
"- **ยง6/ยง7** โ BST insert-then-search correctness\n"
"- **ยง8/ยง9** โ a verified expression evaluator\n"
"\n"
"Onward to World 3: Subtypes!"
msgstr "World 2 complete! You've built and verified:\n"
"- **ยง0**, **ยง1**, **ยง2** โ the classic list combinators\n"
"- **ยง3** โ a non-structural recursion with explicit termination proof\n"
"- **ยง4** and **ยง5** โ your own inductive type\n"
"- **ยง6/ยง7** โ BST insert-then-search correctness\n"
"- **ยง8/ยง9** โ a verified expression evaluator\n"
"\n"
"Onward to World 3: Subtypes!"

#. ยง0: `double_even n`
#. ยง1: `โจn + n, double_even nโฉ : EvenNat`
#: Game.Levels.ProofsInTypes.L01_Subtype
msgid "The proof is the membership certificate. No certificate, no value.\n"
"\n"
"ยง0 is the proof we'd pack into ยง1."
msgstr "The proof is the membership certificate. No certificate, no value.\n"
"\n"
"ยง0 is the proof we'd pack into ยง1."

#. ยง0: `@[simp]`
#. ยง1: `simp_all`
#. ยง2: `myMap_nil`
#. ยง3: `myMap_cons`
#. ยง4: `@[simp]`
#: Game.Levels.AutomationPower.L04_MapAppend
msgid "One line. The ยง0 investment in Level 2 pays off here.\n"
"\n"
"ยง1 sees ยง2 and ยง3 in the simp set, uses\n"
"the induction hypothesis from the context, and closes both cases.\n"
"\n"
"This is the power of ยง4: tag your equations once, benefit everywhere."
msgstr "One line. The ยง0 investment in Level 2 pays off here.\n"
"\n"
"ยง1 sees ยง2 and ยง3 in the simp set, uses\n"
"the induction hypothesis from the context, and closes both cases.\n"
"\n"
"This is the power of ยง4: tag your equations once, benefit everywhere."

#: Game.Levels.DataInvariants.L01_Stub
msgid "This world is under construction.\n"
"\n"
"**World 5: Data Invariants** will teach you to maintain invariants over data\n"
"structures: sorted lists, balanced trees, and how to carry proofs alongside\n"
"data so that invariants can never be violated.\n"
"\n"
"Check back soon!"
msgstr "This world is under construction.\n"
"\n"
"**World 5: Data Invariants** will teach you to maintain invariants over data\n"
"structures: sorted lists, balanced trees, and how to carry proofs alongside\n"
"data so that invariants can never be violated.\n"
"\n"
"Check back soon!"

#: Game.Levels.ProofsInTypes.L08_Victory
msgid "Victory: The Proof-Carrying Insert"
msgstr "Victory: The Proof-Carrying Insert"

#: Game.Levels.PurePrograms.L03_MyFoldr
msgid "Folding a List"
msgstr "Folding a List"

#: Game.Levels.PurePrograms.L06_BST
msgid "Insert a value into a BST."
msgstr "Insert a value into a BST."

#. ยง0: `Nat`
#. ยง1: `SortedList`
#. ยง2: `SortedList`
#: Game.Levels.ProofsInTypes.L08_Victory
msgid "Insert a ยง0 into a ยง1, returning a ยง2."
msgstr "Insert a ยง0 into a ยง1, returning a ยง2."

#. ยง0: `.val`
#. ยง1: `.1`
#. ยง2: `.property`
#. ยง3: `.2`
#. ยง4: `e : EvenNat`
#. ยง5: `e.val : Nat`
#. ยง6: `e.property : e.val % 2 = 0`
#. ยง7: `EvenNat`
#: Game.Levels.ProofsInTypes.L02_SubtypeAccess
msgid "Every subtype value carries two pieces:\n"
"- ยง0 (or ยง1): the underlying value\n"
"- ยง2 (or ยง3): the proof\n"
"\n"
"For ยง4:\n"
"- ยง5 โ the number itself\n"
"- ยง6 โ the proof it's even\n"
"\n"
"The type system **guarantees** this proof exists. You cannot construct an ยง7 without\n"
"providing a proof of evenness."
msgstr "Every subtype value carries two pieces:\n"
"- ยง0 (or ยง1): the underlying value\n"
"- ยง2 (or ยง3): the proof\n"
"\n"
"For ยง4:\n"
"- ยง5 โ the number itself\n"
"- ยง6 โ the proof it's even\n"
"\n"
"The type system **guarantees** this proof exists. You cannot construct an ยง7 without\n"
"providing a proof of evenness."

#. ยง0: `grind [double]`
#. ยง1: `grind`
#. ยง2: `grind [def1, lemma2, ...]`
#. ยง3: `[double]`
#. ยง4: `grind`
#: Game.Levels.AutomationPower.L03_Grind
msgid "ยง0 unfolded the definition, rewrote the hypothesis, and\n"
"closed the goal with linear arithmetic โ all in one call.\n"
"\n"
"When ยง1 needs a push, you can give it more lemma hints:\n"
"ยง2. Here, ยง3 was enough.\n"
"\n"
"ยง4 is particularly useful when you have hypotheses relating\n"
"computed values and need to derive new equalities or inequalities."
msgstr "ยง0 unfolded the definition, rewrote the hypothesis, and\n"
"closed the goal with linear arithmetic โ all in one call.\n"
"\n"
"When ยง1 needs a push, you can give it more lemma hints:\n"
"ยง2. Here, ยง3 was enough.\n"
"\n"
"ยง4 is particularly useful when you have hypotheses relating\n"
"computed values and need to derive new equalities or inequalities."

#: Game.Levels.PurePrograms.L07_Expr
msgid "Abstract syntax tree for arithmetic expressions."
msgstr "Abstract syntax tree for arithmetic expressions."

#: Game.Levels.Termination.L01_Stub
#: Game.Levels.DataInvariants.L01_Stub
#: Game.Levels.PrePost.L01_Stub
#: Game.Levels.ImperativeIntro.L01_Stub
#: Game.Levels.ImperativeBoss.L01_Stub
msgid "Coming Soon"
msgstr "Coming Soon"

#: Game.Levels.AutomationPower.L01_SimpAll
msgid "simp_all: Turbo-Charged Simplification"
msgstr "simp_all: Turbo-Charged Simplification"

#. ยง0: ```lean
#. inductive Tree (ฮฑ : Type) where
#.   | leaf : Tree ฮฑ
#.   | node : Tree ฮฑ โ ฮฑ โ Tree ฮฑ โ Tree ฮฑ
#. ```
#. ยง1: `Tree ฮฑ`
#. ยง2: `leaf`
#. ยง3: `node`
#. ยง4: ```lean
#. def treeHeight : Tree ฮฑ โ Nat
#.   | .leaf       => 0
#.   | .node l _ r => 1 + max (treeHeight l) (treeHeight r)
#. ```
#. ยง5: `treeHeight`
#. ยง6: `Tree ฮฑ`
#. ยง7: `termination_by`
#. ยง8: `node`
#: Game.Levels.PurePrograms.L05_Tree
msgid "Lists are one-dimensional. **Binary trees** branch in two directions:\n"
"\n"
"ยง0\n"
"\n"
"A ยง1 is either a ยง2 (empty) or a ยง3 with a left subtree, a value, and a right subtree.\n"
"\n"
"We can measure a tree's height recursively:\n"
"\n"
"ยง4\n"
"\n"
"Note: ยง5 is **structurally recursive** on ยง6, so Lean accepts it without\n"
"any ยง7 annotation.\n"
"\n"
"**Your goal**: prove that any non-empty tree (built with ยง8) has height โฅ 1."
msgstr "Lists are one-dimensional. **Binary trees** branch in two directions:\n"
"\n"
"ยง0\n"
"\n"
"A ยง1 is either a ยง2 (empty) or a ยง3 with a left subtree, a value, and a right subtree.\n"
"\n"
"We can measure a tree's height recursively:\n"
"\n"
"ยง4\n"
"\n"
"Note: ยง5 is **structurally recursive** on ยง6, so Lean accepts it without\n"
"any ยง7 annotation.\n"
"\n"
"**Your goal**: prove that any non-empty tree (built with ยง8) has height โฅ 1."

#: Game.Levels.PurePrograms.L04_Half
msgid "The Termination Wall"
msgstr "The Termination Wall"

#: Game.Levels.AutomationPower.L06_GrindBST
msgid "Test whether a value is a member of a binary search tree."
msgstr "Test whether a value is a member of a binary search tree."

#. ยง0: `simp [isEven, double]`
#. ยง1: `(n + n) % 2 = 0`
#. ยง2: `omega`
#. ยง3: `omega`
#: Game.Levels.FirstProofs.L02_IsEven
msgid "ยง0 unfolded both definitions, turning the goal into\n"
"ยง1. Then ยง2 โ Lean's built-in linear arithmetic solver โ\n"
"finished the proof automatically.\n"
"\n"
"ยง3 is incredibly powerful: it can prove any goal that follows from linear\n"
"arithmetic over integers and natural numbers."
msgstr "ยง0 unfolded both definitions, turning the goal into\n"
"ยง1. Then ยง2 โ Lean's built-in linear arithmetic solver โ\n"
"finished the proof automatically.\n"
"\n"
"ยง3 is incredibly powerful: it can prove any goal that follows from linear\n"
"arithmetic over integers and natural numbers."

#: Game.Levels.ProofsInTypes.L02_SubtypeAccess
msgid "Extracting the Packed Proof"
msgstr "Extracting the Packed Proof"

#. ยง0: `simp_all`
#. ยง1: `[ih]`
#. ยง2: `<;>`
#. ยง3: `induction xs <;> tac`
#. ยง4: `tac`
#. ยง5: `simp_all`
#: Game.Levels.AutomationPower.L01_SimpAll
msgid "ยง0 found the induction hypothesis in the context and used it\n"
"automatically โ no ยง1 needed.\n"
"\n"
"The ยง2 combinator is powerful: ยง3 applies ยง4 to\n"
"**both** the base case and the inductive case. Combined with ยง5, a\n"
"5-line induction proof collapses to one line."
msgstr "ยง0 found the induction hypothesis in the context and used it\n"
"automatically โ no ยง1 needed.\n"
"\n"
"The ยง2 combinator is powerful: ยง3 applies ยง4 to\n"
"**both** the base case and the inductive case. Combined with ยง5, a\n"
"5-line induction proof collapses to one line."

#. ยง0: `simp`
#. ยง1: `@[simp]`
#. ยง2: `@[simp]`
#. ยง3: `simp`
#. ยง4: `simp_all`
#. ยง5: `simp [myMap]`
#. ยง6: `myMap`
#. ยง7: ```lean
#. @[simp] theorem myMap_nil (f : ฮฑ โ ฮฒ) :
#.     myMap f [] = [] := rfl
#. 
#. @[simp] theorem myMap_cons (f : ฮฑ โ ฮฒ) (x : ฮฑ) (xs : List ฮฑ) :
#.     myMap f (x :: xs) = f x :: myMap f xs := rfl
#. ```
#. ยง8: `rfl`
#. ยง9: `myMap`
#. ยง10: `simp`
#. ยง11: `myMap`
#. ยง12: `myMap`
#. ยง13: `myMap g (myMap f l) = myMap (g โ f) l`
#. ยง14: `f`
#. ยง15: `g`
#. ยง16: `induction l <;> simp_all [Function.comp_apply]`
#: Game.Levels.AutomationPower.L02_SimpAttr
msgid "ยง0 has a built-in library of rewrite rules. You can extend it permanently\n"
"by tagging your own theorems with the **ยง1 attribute**.\n"
"\n"
"After marking a theorem ยง2, plain ยง3 (and ยง4) uses it\n"
"automatically โ you never need to write ยง5 again.\n"
"\n"
"The equation lemmas of ยง6 make great simp rules:\n"
"ยง7\n"
"\n"
"Both are proved by ยง8 because they follow directly from ยง9's definition.\n"
"\n"
"With these in place, ยง10 knows how ยง11 behaves on every list shape.\n"
"Now prove a brand-new theorem: **ยง12 respects function composition**.\n"
"\n"
"ยง13\n"
"\n"
"Mapping ยง14 then ยง15 is the same as mapping their composition in one pass.\n"
"Try ยง16."
msgstr "ยง0 has a built-in library of rewrite rules. You can extend it permanently\n"
"by tagging your own theorems with the **ยง1 attribute**.\n"
"\n"
"After marking a theorem ยง2, plain ยง3 (and ยง4) uses it\n"
"automatically โ you never need to write ยง5 again.\n"
"\n"
"The equation lemmas of ยง6 make great simp rules:\n"
"ยง7\n"
"\n"
"Both are proved by ยง8 because they follow directly from ยง9's definition.\n"
"\n"
"With these in place, ยง10 knows how ยง11 behaves on every list shape.\n"
"Now prove a brand-new theorem: **ยง12 respects function composition**.\n"
"\n"
"ยง13\n"
"\n"
"Mapping ยง14 then ยง15 is the same as mapping their composition in one pass.\n"
"Try ยง16."

#: Game.Levels.PurePrograms.L05_Tree
msgid "Binary tree type: either a leaf or a node with left subtree, value, right subtree."
msgstr "Binary tree type: either a leaf or a node with left subtree, value, right subtree."

#. ยง0: `intro a b`
#. ยง1: `constructor`
#. ยง2: `โ`
#: Game.Levels.FirstProofs.L06_Coprime
msgid "Use ยง0, then ยง1 to split the ยง2."
msgstr "Use ยง0, then ยง1 to split the ยง2."

#. ยง0: `(n + n) % 2 = 0`
#. ยง1: `n`
#: Game.Levels.ProofsInTypes.L01_Subtype
msgid "ยง0 for all ยง1"
msgstr "ยง0 for all ยง1"

#. ยง0: `induction l <;> simp_all [Function.comp_apply]`
#. ยง1: `Function.comp_apply`
#. ยง2: `(f โ g) x = f (g x)`
#. ยง3: `@[simp]`
#. ยง4: `myMap`
#: Game.Levels.AutomationPower.L02_SimpAttr
msgid "Use ยง0.\n"
"ยง1 is the lemma ยง2.\n"
"The ยง3 lemmas for ยง4 and the induction hypothesis do the rest."
msgstr "Use ยง0.\n"
"ยง1 is the lemma ยง2.\n"
"The ยง3 lemmas for ยง4 and the induction hypothesis do the rest."

#: Game.Levels.PurePrograms.L02_MyFilter
msgid "Keep only elements satisfying a boolean predicate."
msgstr "Keep only elements satisfying a boolean predicate."

#: Game
msgid "# Welcome to the Program Verification Game!\n"
"\n"
"In this game you will learn **formal program verification** โ the art of\n"
"proving mathematical theorems about programs to guarantee they are correct.\n"
"\n"
"You will use **Lean 4**, a proof assistant that checks every step of your reasoning.\n"
"\n"
"## The 8 Worlds\n"
"\n"
"| # | World | Theme |\n"
"|---|-------|-------|\n"
"| 1 | **First Proofs** | Core tactics, GCD algorithm, primality |\n"
"| 2 | **Pure Programs** | Pure recursive programs + termination |\n"
"| 3 | **Automation Power** | simp_all, grind, and @[simp] |\n"
"| 4 | **Proofs in Types** | Subtypes, Fin, proof-carrying functions |\n"
"| 5 | **Termination** | Proving programs always terminate |\n"
"| 6 | **Data Invariants** | Sorted lists, balanced trees, invariant maintenance |\n"
"| 7 | **Pre/Post Conditions** | Hoare-style contracts |\n"
"| 8 | **Imperative Intro** | Verifying mutable state and loops |\n"
"\n"
"Start with **World 1** to learn the basics!"
msgstr "# Welcome to the Program Verification Game!\n"
"\n"
"In this game you will learn **formal program verification** โ the art of\n"
"proving mathematical theorems about programs to guarantee they are correct.\n"
"\n"
"You will use **Lean 4**, a proof assistant that checks every step of your reasoning.\n"
"\n"
"## The 8 Worlds\n"
"\n"
"| # | World | Theme |\n"
"|---|-------|-------|\n"
"| 1 | **First Proofs** | Core tactics, GCD algorithm, primality |\n"
"| 2 | **Pure Programs** | Pure recursive programs + termination |\n"
"| 3 | **Automation Power** | simp_all, grind, and @[simp] |\n"
"| 4 | **Proofs in Types** | Subtypes, Fin, proof-carrying functions |\n"
"| 5 | **Termination** | Proving programs always terminate |\n"
"| 6 | **Data Invariants** | Sorted lists, balanced trees, invariant maintenance |\n"
"| 7 | **Pre/Post Conditions** | Hoare-style contracts |\n"
"| 8 | **Imperative Intro** | Verifying mutable state and loops |\n"
"\n"
"Start with **World 1** to learn the basics!"

#: Game.Levels.ImperativeBoss
msgid "Imperative Boss"
msgstr "Imperative Boss"

#. ยง0: `simp ... at h`
#: Game.Levels.ProofsInTypes.L05_Sorted
msgid "ยง0 is the variant that simplifies *hypotheses* rather than the goal.\n"
"It's essential when you need to unfold a definition to extract information from an assumption."
msgstr "ยง0 is the variant that simplifies *hypotheses* rather than the goal.\n"
"It's essential when you need to unfold a definition to extract information from an assumption."

#. ยง0: `simp [h1, h2, bstMember, ihl]`
#. ยง1: `simp_all`
#. ยง2: `simp_all`
#. ยง3: `h : x < y`
#. ยง4: `ihl`
#. ยง5: `ihr`
#. ยง6: `h : ยฌ(x < y)`
#. ยง7: `simp_all`
#. ยง8: `h : y โค x`
#. ยง9: `if x < y then ... else ...`
#. ยง10: `simp [h, ...]`
#. ยง11: ```lean
#. by_cases h1 : x < y
#. ยท simp [h1, bstMember, ihl]        -- explicit ihl needed
#. ยท by_cases h2 : y < x
#.   ยท simp [h1, h2, bstMember, ihr]  -- explicit ihr needed
#.   ยท simp [h1, h2, bstMember]
#. ```
#. ยง12: `simp_all`
#. ยง13: ```lean
#. by_cases h1 : x < y
#. ยท simp_all [bstMember]           -- finds ihl automatically โ
#. ยท by_cases h2 : y < x
#.   ยท simp [bstMember, h1, h2, ihr]
#.   ยท simp [bstMember, h1, h2]
#. ```
#. ยง14: `simp_all`
#. ยง15: `ihl`
#. ยง16: `simp`
#: Game.Levels.AutomationPower.L06_GrindBST
msgid "In World 2, you proved BST correctness with explicit ยง0 calls.\n"
"ยง1 can improve this โ but with a catch.\n"
"\n"
"**The key insight**: ยง2 works best with *positive* hypotheses like ยง3.\n"
"It can search the context for ยง4 and ยง5 automatically. However, when you have\n"
"ยง6, ยง7 normalizes it to ยง8, which prevents the standard\n"
"ยง9 reduction. For those branches, plain ยง10 is safer.\n"
"\n"
"**World 2 proof**:\n"
"ยง11\n"
"\n"
"**World 3 proof** โ ยง12 handles the positive branch automatically:\n"
"ยง13\n"
"\n"
"The first branch is now cleaner. The ยง14 found ยง15 in the context without\n"
"being told. The other branches still use ยง16 with explicit hints."
msgstr "In World 2, you proved BST correctness with explicit ยง0 calls.\n"
"ยง1 can improve this โ but with a catch.\n"
"\n"
"**The key insight**: ยง2 works best with *positive* hypotheses like ยง3.\n"
"It can search the context for ยง4 and ยง5 automatically. However, when you have\n"
"ยง6, ยง7 normalizes it to ยง8, which prevents the standard\n"
"ยง9 reduction. For those branches, plain ยง10 is safer.\n"
"\n"
"**World 2 proof**:\n"
"ยง11\n"
"\n"
"**World 3 proof** โ ยง12 handles the positive branch automatically:\n"
"ยง13\n"
"\n"
"The first branch is now cleaner. The ยง14 found ยง15 in the context without\n"
"being told. The other branches still use ยง16 with explicit hints."

#: Game.Levels.FirstProofs.L06_Coprime
msgid "Coprime Numbers"
msgstr "Coprime Numbers"

#: Game.Levels.PrePost
msgid "**World 6: Pre/Post Conditions**\n"
"\n"
"Hoare-style reasoning: specify what a function *requires* (preconditions)\n"
"and *guarantees* (postconditions), then prove the implementation satisfies\n"
"its contract. The foundation of formal program verification.\n"
"\n"
"*Coming soon!*"
msgstr "**World 6: Pre/Post Conditions**\n"
"\n"
"Hoare-style reasoning: specify what a function *requires* (preconditions)\n"
"and *guarantees* (postconditions), then prove the implementation satisfies\n"
"its contract. The foundation of formal program verification.\n"
"\n"
"*Coming soon!*"

#: Game.Levels.ProofsInTypes.L06_SortedList
msgid "SortedList: A Type That IS Its Invariant"
msgstr "SortedList: A Type That IS Its Invariant"

#. ยง0: `induction t`
#. ยง1: `leaf`
#. ยง2: `simp [bstInsert, bstMember]`
#. ยง3: `node l y r ihl ihr`
#. ยง4: `simp only [bstInsert]`
#. ยง5: `by_cases h1 : x < y`
#. ยง6: `h1 : x < y`
#. ยง7: `simp_all [bstMember]`
#. ยง8: `h1 : ยฌ(x < y)`
#. ยง9: `by_cases h2 : y < x`
#. ยง10: `simp [bstMember, h1, h2, ...]`
#: Game.Levels.AutomationPower.L06_GrindBST
msgid "Use ยง0. For ยง1, ยง2 closes it.\n"
"For ยง3: ยง4, then ยง5.\n"
"- If ยง6: ยง7 finds the IH automatically.\n"
"- If ยง8: use a second ยง9 and ยง10."
msgstr "Use ยง0. For ยง1, ยง2 closes it.\n"
"For ยง3: ยง4, then ยง5.\n"
"- If ยง6: ยง7 finds the IH automatically.\n"
"- If ยง8: use a second ยง9 and ยง10."

#. ยง0: `@[simp]`
#. ยง1: `myFilter`
#. ยง2: ```lean
#. @[simp] theorem myFilter_nil (p : ฮฑ โ Bool) :
#.     myFilter p [] = [] := rfl
#. 
#. @[simp] theorem myFilter_cons (p : ฮฑ โ Bool) (x : ฮฑ) (xs : List ฮฑ) :
#.     myFilter p (x :: xs) =
#.       if p x then x :: myFilter p xs else myFilter p xs := rfl
#. ```
#. ยง3: `p`
#. ยง4: `!p`
#. ยง5: ```lean
#. (myFilter p l).length + (myFilter (fun x => !p x) l).length = l.length
#. ```
#. ยง6: `p`
#. ยง7: `!p`
#. ยง8: `l`
#. ยง9: `cons`
#. ยง10: `p x`
#. ยง11: `cases h : p x`
#. ยง12: `simp_all`
#. ยง13: `h`
#. ยง14: `omega`
#: Game.Levels.AutomationPower.L05_FilterPartition
msgid "Let's do the same ยง0 treatment for ยง1, then prove a\n"
"new theorem about it.\n"
"\n"
"ยง2\n"
"\n"
"Now the theorem: filtering a list with a predicate ยง3 and filtering with\n"
"its complement ยง4 together account for **every element**:\n"
"ยง5\n"
"\n"
"Each element goes into exactly one bucket โ either ยง6 kept it or ยง7 did.\n"
"\n"
"The proof strategy:\n"
"- Induct on ยง8\n"
"- For the ยง9 case, case-split on ยง10 with ยง11\n"
"- ยง12 handles the filter simplification using ยง13\n"
"- ยง14 closes the arithmetic"
msgstr "Let's do the same ยง0 treatment for ยง1, then prove a\n"
"new theorem about it.\n"
"\n"
"ยง2\n"
"\n"
"Now the theorem: filtering a list with a predicate ยง3 and filtering with\n"
"its complement ยง4 together account for **every element**:\n"
"ยง5\n"
"\n"
"Each element goes into exactly one bucket โ either ยง6 kept it or ยง7 did.\n"
"\n"
"The proof strategy:\n"
"- Induct on ยง8\n"
"- For the ยง9 case, case-split on ยง10 with ยง11\n"
"- ยง12 handles the filter simplification using ยง13\n"
"- ยง14 closes the arithmetic"

#. ยง0: `myGcd`
#. ยง1: `n`
#. ยง2: `n โฅ 2`
#. ยง3: `d`
#. ยง4: `[2, n-1]`
#. ยง5: `n`
#. ยง6: ```
#. def isPrime (n : Nat) : Bool :=
#.   n โฅ 2 &&
#.   ((List.range n).drop 2).all (fun d => myGcd n d == 1)
#. ```
#. ยง7: ```
#. isPrime 2 = true โง isPrime 3 = true โง isPrime 4 = false โง isPrime 5 = true
#. ```
#. ยง8: `native_decide`
#: Game.Levels.FirstProofs.L07_Primality
msgid "You've built and verified the Euclidean algorithm. Now use it to verify\n"
"a **primality checker** built from ยง0!\n"
"\n"
"A number ยง1 is prime if ยง2 and every number ยง3 in ยง4\n"
"is coprime with ยง5:\n"
"ยง6\n"
"\n"
"Prove that 2, 3, and 5 are prime, and that 4 is not:\n"
"ยง7\n"
"\n"
"*Tip*: All four values are **computable** โ try ยง8 to evaluate them instantly."
msgstr "You've built and verified the Euclidean algorithm. Now use it to verify\n"
"a **primality checker** built from ยง0!\n"
"\n"
"A number ยง1 is prime if ยง2 and every number ยง3 in ยง4\n"
"is coprime with ยง5:\n"
"ยง6\n"
"\n"
"Prove that 2, 3, and 5 are prime, and that 4 is not:\n"
"ยง7\n"
"\n"
"*Tip*: All four values are **computable** โ try ยง8 to evaluate them instantly."

#. ยง0: `half 0 = 0`
#. ยง1: `half 1 = 0`
#. ยง2: `n โฅ 2`
#. ยง3: `n - 2 < n`
#: Game.Levels.PurePrograms.L04_Half
msgid "ยง0, ยง1, and when ยง2, ยง3."
msgstr "ยง0, ยง1, and when ยง2, ยง3."

#: Game
#: Game
msgid "Program Verification Game"
msgstr "Program Verification Game"

#. ยง0: `SortedList`
#. ยง1: ```lean
#. def insertSorted (x : Nat) : List Nat โ List Nat
#.   | []      => [x]
#.   | y :: ys => if x โค y then x :: y :: ys else y :: insertSorted x ys
#. ```
#. ยง2: `insertSorted`
#. ยง3: `x โค y`
#. ยง4: `by_cases hxy : x โค y`
#. ยง5: `simp only [if_pos hxy]`
#. ยง6: `simp only [if_neg hxy]`
#. ยง7: `simp [Sorted]`
#: Game.Levels.ProofsInTypes.L07_InsertSorted
msgid "Having a ยง0 type is only useful if we can **build** sorted lists.\n"
"Here is a function that inserts an element into a sorted list, keeping it sorted:\n"
"\n"
"ยง1\n"
"\n"
"We need to prove that ยง2 **preserves** sortedness. The proof goes by\n"
"induction on the list. At each step we case-split on whether ยง3.\n"
"\n"
"Key tactics:\n"
"- ยง4 โ split into two cases\n"
"- ยง5 / ยง6 โ reduce the conditional\n"
"- ยง7 โ unfold the predicate and close the goal"
msgstr "Having a ยง0 type is only useful if we can **build** sorted lists.\n"
"Here is a function that inserts an element into a sorted list, keeping it sorted:\n"
"\n"
"ยง1\n"
"\n"
"We need to prove that ยง2 **preserves** sortedness. The proof goes by\n"
"induction on the list. At each step we case-split on whether ยง3.\n"
"\n"
"Key tactics:\n"
"- ยง4 โ split into two cases\n"
"- ยง5 / ยง6 โ reduce the conditional\n"
"- ยง7 โ unfold the predicate and close the goal"

#: GameServer.RpcHandlers
msgid "level completed! ๐"
msgstr "level completed! ๐"

#. ยง0: `[]`
#. ยง1: `([] ++ ys).length = ys.length = 0 + ys.length`
#. ยง2: `x :: xs`
#. ยง3: `ih`
#: Game.Levels.FirstProofs.L03_ListLength
msgid "You proved a fundamental list theorem by structural induction!\n"
"\n"
"The induction had two cases:\n"
"- **Base case** (ยง0): ยง1, trivial.\n"
"- **Inductive case** (ยง2): used the induction hypothesis ยง3 and\n"
"  Lean's built-in list lemmas to reduce to arithmetic.\n"
"\n"
"This is the essence of verification by induction."
msgstr "You proved a fundamental list theorem by structural induction!\n"
"\n"
"The induction had two cases:\n"
"- **Base case** (ยง0): ยง1, trivial.\n"
"- **Inductive case** (ยง2): used the induction hypothesis ยง3 and\n"
"  Lean's built-in list lemmas to reduce to arithmetic.\n"
"\n"
"This is the essence of verification by induction."

#: Game.Levels.PurePrograms.L02_MyFilter
msgid "Filtering a List"
msgstr "Filtering a List"

#: Game.Levels.PurePrograms.L04_Half
msgid "Integer division by 2, defined by well-founded recursion."
msgstr "Integer division by 2, defined by well-founded recursion."

#. ยง0: `b = 0`
#. ยง1: `h : 0 โ 0`
#. ยง2: `omega`
#: Game.Levels.FirstProofs.L05_GcdStep
msgid "In this case ยง0 but ยง1. This is a contradiction โ try ยง2."
msgstr "In this case ยง0 but ยง1. This is a contradiction โ try ยง2."

#: Game.Levels.ProofsInTypes.L04_SafeHead
msgid "Return the head of a non-empty list, with non-emptiness proved at call site."
msgstr "Return the head of a non-empty list, with non-emptiness proved at call site."

#. ยง0: `exact h`
#. ยง1: `myCoprime a b`
#. ยง2: `myGcd a b = 1`
#. ยง3: `constructor`
#. ยง4: `P โ Q`
#. ยง5: `P โง Q`
#: Game.Levels.FirstProofs.L06_Coprime
msgid "Both directions are proved by ยง0 โ because ยง1 is\n"
"**defined as** ยง2. They are literally the same proposition!\n"
"\n"
"ยง3 is the key tactic for goals of the form ยง4 (biconditionals)\n"
"and ยง5 (conjunctions). It splits them into separate subgoals."
msgstr "Both directions are proved by ยง0 โ because ยง1 is\n"
"**defined as** ยง2. They are literally the same proposition!\n"
"\n"
"ยง3 is the key tactic for goals of the form ยง4 (biconditionals)\n"
"and ยง5 (conjunctions). It splits them into separate subgoals."

#. ยง0: `bstMember x (bstInsert x t) = true`
#. ยง1: `x`
#. ยง2: `t`
#: Game.Levels.AutomationPower.L06_GrindBST
msgid "ยง0 for any ยง1 and tree ยง2."
msgstr "ยง0 for any ยง1 and tree ยง2."

#: Game.Levels.FirstProofs.L02_IsEven
msgid "Even Numbers"
msgstr "Even Numbers"

#: Game.Levels.FirstProofs.L04_GcdBase
msgid "Euclidean GCD algorithm."
msgstr "Euclidean GCD algorithm."

#. ยง0: `bstMember x (bstInsert x t) = true`
#. ยง1: `x`
#. ยง2: `t`
#: Game.Levels.PurePrograms.L06_BST
msgid "ยง0 for all ยง1 and ยง2.\n"
"\n"
"This is the fundamental correctness property of BSTs: if you insert something,\n"
"you can always find it. Proving the full BST ordering invariant is left for World 5!"
msgstr "ยง0 for all ยง1 and ยง2.\n"
"\n"
"This is the fundamental correctness property of BSTs: if you insert something,\n"
"you can always find it. Proving the full BST ordering invariant is left for World 5!"

#: Game.Levels.ProofsInTypes.L01_Subtype
msgid "Subtypes: A Value With a Proof Inside"
msgstr "Subtypes: A Value With a Proof Inside"

#: Game.Levels.Termination.L01_Stub
msgid "This world is under construction.\n"
"\n"
"**World 4: Termination** will teach you to prove that programs always terminate:\n"
"structural recursion, well-founded measures, and how Lean checks that recursive\n"
"calls decrease toward the base case.\n"
"\n"
"Check back soon!"
msgstr "This world is under construction.\n"
"\n"
"**World 4: Termination** will teach you to prove that programs always terminate:\n"
"structural recursion, well-founded measures, and how Lean checks that recursive\n"
"calls decrease toward the base case.\n"
"\n"
"Check back soon!"

#. ยง0: ```lean
#. inductive Expr where
#.   | num : Int โ Expr
#.   | add : Expr โ Expr โ Expr
#.   | mul : Expr โ Expr โ Expr
#. 
#. def eval : Expr โ Int
#.   | .num n     => n
#.   | .add e1 e2 => eval e1 + eval e2
#.   | .mul e1 e2 => eval e1 * eval e2
#. ```
#. ยง1: `eval`
#. ยง2: `Expr`
#. ยง3: `a * (b + c) = a*b + a*c`
#. ยง4: `simp [eval]`
#. ยง5: `Int`
#. ยง6: `Int.mul_add`
#. ยง7: `simp [eval, Int.mul_add]`
#: Game.Levels.PurePrograms.L07_Expr
msgid "Let's build a tiny **expression language** โ the kind at the heart of every compiler\n"
"and interpreter.\n"
"\n"
"ยง0\n"
"\n"
"ยง1 is structurally recursive on ยง2, so Lean accepts it automatically.\n"
"\n"
"**Your goal**: prove the distributive law โ ยง3 โ at the\n"
"expression level.\n"
"\n"
"After ยง4 unfolds the evaluator, the goal becomes a pure arithmetic\n"
"identity on ยง5. Lean knows this as ยง6, so\n"
"ยง7 closes it in one step."
msgstr "Let's build a tiny **expression language** โ the kind at the heart of every compiler\n"
"and interpreter.\n"
"\n"
"ยง0\n"
"\n"
"ยง1 is structurally recursive on ยง2, so Lean accepts it automatically.\n"
"\n"
"**Your goal**: prove the distributive law โ ยง3 โ at the\n"
"expression level.\n"
"\n"
"After ยง4 unfolds the evaluator, the goal becomes a pure arithmetic\n"
"identity on ยง5. Lean knows this as ยง6, so\n"
"ยง7 closes it in one step."

#. ยง0: `List`
#. ยง1: `Tree`
#. ยง2: `termination_by`
#. ยง3: `decreasing_by`
#. ยง4: `myGcd`
#: Game.Levels.PurePrograms
msgid "Welcome to **World 2: Pure Programs**!\n"
"\n"
"All code here is *pure* โ no mutable state, no side effects.\n"
"But purity doesn't mean simple: you'll build polymorphic list operations,\n"
"a binary search tree, and a tiny expression evaluator โ all verified by Lean.\n"
"\n"
"Along the way you'll hit the **termination wall**: Lean demands a proof that\n"
"every recursive function eventually stops.\n"
"\n"
"- **Structural recursion** (on ยง0, on ยง1): Lean accepts it automatically.\n"
"- **Non-structural recursion**: you must supply a measure with ยง2\n"
"  and prove it decreases with ยง3.\n"
"\n"
"You already saw this in World 1 with ยง4. Here you'll see it again โ and\n"
"understand exactly why Lean insists on it."
msgstr "Welcome to **World 2: Pure Programs**!\n"
"\n"
"All code here is *pure* โ no mutable state, no side effects.\n"
"But purity doesn't mean simple: you'll build polymorphic list operations,\n"
"a binary search tree, and a tiny expression evaluator โ all verified by Lean.\n"
"\n"
"Along the way you'll hit the **termination wall**: Lean demands a proof that\n"
"every recursive function eventually stops.\n"
"\n"
"- **Structural recursion** (on ยง0, on ยง1): Lean accepts it automatically.\n"
"- **Non-structural recursion**: you must supply a measure with ยง2\n"
"  and prove it decreases with ยง3.\n"
"\n"
"You already saw this in World 1 with ยง4. Here you'll see it again โ and\n"
"understand exactly why Lean insists on it."

#: Game.Levels.DataInvariants
msgid "Data Invariants"
msgstr "Data Invariants"

#. ยง0: `myFilter`
#. ยง1: `split`
#. ยง2: `if`
#. ยง3: `simp_all`
#. ยง4: `omega`
#: Game.Levels.PurePrograms.L02_MyFilter
msgid "ยง0 can only shrink (or preserve) a list โ it can never grow it.\n"
"Notice how ยง1 handled the ยง2 expression cleanly, letting ยง3 and ยง4\n"
"close each branch."
msgstr "ยง0 can only shrink (or preserve) a list โ it can never grow it.\n"
"Notice how ยง1 handled the ยง2 expression cleanly, letting ยง3 and ยง4\n"
"close each branch."

#: Game.Levels.ImperativeIntro
msgid "Imperative Intro"
msgstr "Imperative Intro"

#: Game.Levels.Termination.L01_Stub
#: Game.Levels.DataInvariants.L01_Stub
#: Game.Levels.PrePost.L01_Stub
#: Game.Levels.ImperativeIntro.L01_Stub
#: Game.Levels.ImperativeBoss.L01_Stub
msgid "You found the stub level! The full content is coming soon."
msgstr "You found the stub level! The full content is coming soon."

#. ยง0: `x โค y`
#. ยง1: `insertSorted x (y :: ys) = x :: y :: ys`
#: Game.Levels.ProofsInTypes.L07_InsertSorted
#: Game.Levels.ProofsInTypes.L07_InsertSorted
msgid "When ยง0: ยง1"
msgstr "When ยง0: ยง1"

#: Game.Levels.PurePrograms.L05_Tree
msgid "Height of a binary tree (0 for leaf, 1 + max of children for node)."
msgstr "Height of a binary tree (0 for leaf, 1 + max of children for node)."

#. ยง0: `simp_all`
#. ยง1: `simp`
#. ยง2: `simp_all`
#. ยง3: `ih`
#. ยง4: `simp [ih]`
#. ยง5: `simp_all`
#. ยง6: ```lean
#. -- World 1 (manual):
#. induction xs with
#. | nil          => simp
#. | cons x xs ih => simp [ih]; omega
#. 
#. -- World 3 (automated):
#. induction xs <;> simp_all <;> omega
#. ```
#. ยง7: `induction xs`
#. ยง8: `simp_all`
#: Game.Levels.AutomationPower.L01_SimpAll
msgid "**Welcome to World 3: Automation Power!**\n"
"\n"
"You've proven programs correct one tactic at a time. In this world we hand\n"
"more work to Lean's automation โ the same proofs that took five lines will\n"
"often collapse to one or two.\n"
"\n"
"Our first new tool is **ยง0**. You already know ยง1, which simplifies\n"
"the *goal*. ยง2 goes further: it simplifies both the *goal* **and every\n"
"hypothesis** in the context, then uses those simplified hypotheses to simplify\n"
"further โ repeating until nothing changes.\n"
"\n"
"The big win comes during **induction**: the induction hypothesis ยง3 is\n"
"automatically incorporated. You never need to write ยง4 again โ just\n"
"ยง5.\n"
"\n"
"**Compare the World 1 proof of this same theorem:**\n"
"ยง6\n"
"\n"
"Your goal is to prove that concatenating two lists produces a list whose\n"
"length is the sum of the parts. Use ยง7 and let ยง8\n"
"handle the inductive step automatically."
msgstr "**Welcome to World 3: Automation Power!**\n"
"\n"
"You've proven programs correct one tactic at a time. In this world we hand\n"
"more work to Lean's automation โ the same proofs that took five lines will\n"
"often collapse to one or two.\n"
"\n"
"Our first new tool is **ยง0**. You already know ยง1, which simplifies\n"
"the *goal*. ยง2 goes further: it simplifies both the *goal* **and every\n"
"hypothesis** in the context, then uses those simplified hypotheses to simplify\n"
"further โ repeating until nothing changes.\n"
"\n"
"The big win comes during **induction**: the induction hypothesis ยง3 is\n"
"automatically incorporated. You never need to write ยง4 again โ just\n"
"ยง5.\n"
"\n"
"**Compare the World 1 proof of this same theorem:**\n"
"ยง6\n"
"\n"
"Your goal is to prove that concatenating two lists produces a list whose\n"
"length is the sum of the parts. Use ยง7 and let ยง8\n"
"handle the inductive step automatically."

#. ยง0: `myMap`
#. ยง1: `f`
#: Game.Levels.PurePrograms.L01_MyMap
msgid "Nice work! ยง0 always produces a list of the same length โ regardless of what\n"
"function ยง1 does. This is a simple structural property that follows directly from\n"
"how the recursion is structured."
msgstr "Nice work! ยง0 always produces a list of the same length โ regardless of what\n"
"function ยง1 does. This is a simple structural property that follows directly from\n"
"how the recursion is structured."

#: Game.Levels.Termination
msgid "Termination"
msgstr "Termination"

#. ยง0: `.sorted`
#: Game.Levels.ProofsInTypes.L06_SortedList
msgid "The sorted proof is a struct field. Access it with ยง0."
msgstr "The sorted proof is a struct field. Access it with ยง0."

#: Game.Levels.FirstProofs.L05_GcdStep
msgid "GCD Step"
msgstr "GCD Step"

#. ยง0: `cases h : p x`
#. ยง1: `p x = true`
#. ยง2: `p x = false`
#. ยง3: `h`
#. ยง4: `simp_all`
#. ยง5: `myFilter`
#. ยง6: `x :: xs`
#. ยง7: `h`
#. ยง8: `(fun x => !p x) x`
#. ยง9: `!p x`
#. ยง10: `!true`
#. ยง11: `!false`
#. ยง12: `omega`
#. ยง13: `k + (j+1) = 1+n`
#. ยง14: `@[simp]`
#. ยง15: `myMap`
#. ยง16: `myFilter`
#: Game.Levels.AutomationPower.L05_FilterPartition
msgid "ยง0 splits on whether ยง1 or ยง2,\n"
"naming the result ยง3 for use in subsequent tactics.\n"
"\n"
"ยง4 then:\n"
"- Unfolds ยง5 on ยง6 using ยง7\n"
"- Beta-reduces ยง8 to ยง9\n"
"- Simplifies ยง10 or ยง11 to resolve the complementary filter case\n"
"\n"
"ยง12 closes the remaining arithmetic (ยง13 style goals).\n"
"\n"
"With ยง14 on both ยง15 and ยง16, we're ready for the\n"
"grand finale."
msgstr "ยง0 splits on whether ยง1 or ยง2,\n"
"naming the result ยง3 for use in subsequent tactics.\n"
"\n"
"ยง4 then:\n"
"- Unfolds ยง5 on ยง6 using ยง7\n"
"- Beta-reduces ยง8 to ยง9\n"
"- Simplifies ยง10 or ยง11 to resolve the complementary filter case\n"
"\n"
"ยง12 closes the remaining arithmetic (ยง13 style goals).\n"
"\n"
"With ยง14 on both ยง15 and ยง16, we're ready for the\n"
"grand finale."

#. ยง0: `node`
#: Game.Levels.PurePrograms.L05_Tree
msgid "Every ยง0 has height at least 1 โ because we add 1 to the maximum of its children's heights.\n"
"\n"
"Trees open the door to efficient data structures. In the next level, we'll build a\n"
"**Binary Search Tree** and prove its core correctness property."
msgstr "Every ยง0 has height at least 1 โ because we add 1 to the maximum of its children's heights.\n"
"\n"
"Trees open the door to efficient data structures. In the next level, we'll build a\n"
"**Binary Search Tree** and prove its core correctness property."

#: Game.Levels.PrePost
msgid "Pre/Post Conditions"
msgstr "Pre/Post Conditions"

#. ยง0: `double n`
#: Game.Levels.FirstProofs.L02_IsEven
msgid "ยง0 is always even."
msgstr "ยง0 is always even."

#. ยง0: `SortedList.insert`
#. ยง1: `SortedList`
#. ยง2: `List Nat`
#. ยง3: ```lean
#. def SortedList.insert (x : Nat) (sl : SortedList) : SortedList :=
#.   โจinsertSorted x sl.data, insertSorted_sorted x sl.data sl.sortedโฉ
#. ```
#. ยง4: `insertSorted_sorted x sl.data sl.sorted`
#. ยง5: `obtain`
#. ยง6: `h : A โง B`
#. ยง7: `โจh1, h2โฉ`
#: Game.Levels.ProofsInTypes.L08_Victory
msgid "The payoff: a ยง0 that **returns a ยง1**, not a bare ยง2.\n"
"\n"
"ยง3\n"
"\n"
"The proof ยง4 is baked into the return type.\n"
"You cannot call this function incorrectly, and its result is guaranteed sorted for\n"
"**all** inputs โ verified once at compile time.\n"
"\n"
"No unit test. No runtime assertion. No documentation that might drift. The type says it all.\n"
"\n"
"First, a helper lemma: the inserted element is always in the result.\n"
"Use ยง5 to destructure hypotheses of the form ยง6 into ยง7."
msgstr "The payoff: a ยง0 that **returns a ยง1**, not a bare ยง2.\n"
"\n"
"ยง3\n"
"\n"
"The proof ยง4 is baked into the return type.\n"
"You cannot call this function incorrectly, and its result is guaranteed sorted for\n"
"**all** inputs โ verified once at compile time.\n"
"\n"
"No unit test. No runtime assertion. No documentation that might drift. The type says it all.\n"
"\n"
"First, a helper lemma: the inserted element is always in the result.\n"
"Use ยง5 to destructure hypotheses of the form ยง6 into ยง7."

#. ยง0: `n`
#. ยง1: `n > 1`
#. ยง2: `k`
#. ยง3: `[2, n-1]`
#: Game.Levels.FirstProofs.L07_Primality
msgid "ยง0 is prime iff ยง1 and it is coprime with all ยง2 in ยง3."
msgstr "ยง0 is prime iff ยง1 and it is coprime with all ยง2 in ยง3."

#. ยง0: `b โ 0`
#. ยง1: `myGcd a b`
#. ยง2: `myGcd b (a % b)`
#. ยง3: ```
#. b โ 0 โ myGcd a b = myGcd b (a % b)
#. ```
#. ยง4: `cases b`
#. ยง5: `b = 0`
#. ยง6: `b = b' + 1`
#. ยง7: `simp [myGcd]`
#: Game.Levels.FirstProofs.L05_GcdStep
msgid "Now prove the **recursive step** of the Euclidean algorithm:\n"
"when ยง0, ยง1 reduces to ยง2.\n"
"\n"
"ยง3\n"
"\n"
"*Tip*: Use ยง4 to split into ยง5 (contradiction) and ยง6\n"
"(where ยง7 applies the second equation of the definition)."
msgstr "Now prove the **recursive step** of the Euclidean algorithm:\n"
"when ยง0, ยง1 reduces to ยง2.\n"
"\n"
"ยง3\n"
"\n"
"*Tip*: Use ยง4 to split into ยง5 (contradiction) and ยง6\n"
"(where ยง7 applies the second equation of the definition)."

#. ยง0: `decreasing_by omega`
#: Game.Levels.PurePrograms.L04_Half
msgid "The second part is the exact inequality ยง0 proves\n"
"automatically. Can you prove it manually?"
msgstr "The second part is the exact inequality ยง0 proves\n"
"automatically. Can you prove it manually?"

#. ยง0: ```
#. def double (n : Nat) : Nat := n + n
#. ```
#. ยง1: `double`
#. ยง2: `n`
#: Game.Levels.FirstProofs.L01_Double
msgid "Welcome to the **Program Verification Game**!\n"
"\n"
"In this game you will write mathematical proofs to verify that programs are correct.\n"
"The Lean proof assistant checks every step โ there is no way to cheat.\n"
"\n"
"Your first program:\n"
"ยง0\n"
"\n"
"ยง1 is supposed to double its input.\n"
"Prove that it always does โ for **every** natural number ยง2."
msgstr "Welcome to the **Program Verification Game**!\n"
"\n"
"In this game you will write mathematical proofs to verify that programs are correct.\n"
"The Lean proof assistant checks every step โ there is no way to cheat.\n"
"\n"
"Your first program:\n"
"ยง0\n"
"\n"
"ยง1 is supposed to double its input.\n"
"Prove that it always does โ for **every** natural number ยง2."

#. ยง0: `Nat`
#: Game.Levels.ProofsInTypes.L05_Sorted
msgid "Predicate: a list of ยง0 is sorted in non-decreasing order."
msgstr "Predicate: a list of ยง0 is sorted in non-decreasing order."

#. ยง0: `myMap`
#. ยง1: `@[simp]`
#. ยง2: `myMap`
#. ยง3: ```lean
#. myMap f (lโ ++ lโ) = myMap f lโ ++ myMap f lโ
#. ```
#. ยง4: `@[simp]`
#. ยง5: `myMap`
#. ยง6: ```lean
#. induction lโ with
#. | nil          => simp [myMap]
#. | cons x xs ih => simp [myMap, ih]
#. ```
#. ยง7: `@[simp]`
#. ยง8: `simp_all`
#. ยง9: `myMap`
#. ยง10: ```lean
#. induction lโ <;> simp_all
#. ```
#: Game.Levels.AutomationPower.L04_MapAppend
msgid "Now that ยง0's equations are tagged ยง1, let's prove a new\n"
"structural theorem with almost no effort.\n"
"\n"
"**ยง2 distributes over list concatenation**:\n"
"ยง3\n"
"\n"
"Mapping over a concatenated list is the same as mapping each part and\n"
"concatenating the results. This is the *functor* distributivity law.\n"
"\n"
"In World 2, without ยง4 on ยง5, you would have written:\n"
"ยง6\n"
"\n"
"With ยง7 already in place, plain ยง8 suffices โ it knows\n"
"about ยง9 automatically and finds the IH in the context:\n"
"ยง10\n"
"\n"
"Try it!"
msgstr "Now that ยง0's equations are tagged ยง1, let's prove a new\n"
"structural theorem with almost no effort.\n"
"\n"
"**ยง2 distributes over list concatenation**:\n"
"ยง3\n"
"\n"
"Mapping over a concatenated list is the same as mapping each part and\n"
"concatenating the results. This is the *functor* distributivity law.\n"
"\n"
"In World 2, without ยง4 on ยง5, you would have written:\n"
"ยง6\n"
"\n"
"With ยง7 already in place, plain ยง8 suffices โ it knows\n"
"about ยง9 automatically and finds the IH in the context:\n"
"ยง10\n"
"\n"
"Try it!"

#. ยง0: `Nat`
#: Game.Levels.ProofsInTypes.L06_SortedList
msgid "A list of ยง0 paired with a proof that it is sorted."
msgstr "A list of ยง0 paired with a proof that it is sorted."

#. ยง0: `simp`
#. ยง1: `omega`
#. ยง2: `induction`
#. ยง3: `decide`
#: Game.Levels.FirstProofs
msgid "Welcome to **World 1: First Proofs**!\n"
"\n"
"In this world you will:\n"
"- Write your first verified programs in Lean 4\n"
"- Learn the core proof tactics: ยง0, ยง1, ยง2, ยง3\n"
"- Build and verify the **Euclidean GCD algorithm** from scratch\n"
"- Use your verified GCD to check primality\n"
"\n"
"By the end, you'll understand what it means to formally verify a program โ\n"
"and you'll have done it yourself."
msgstr "Welcome to **World 1: First Proofs**!\n"
"\n"
"In this world you will:\n"
"- Write your first verified programs in Lean 4\n"
"- Learn the core proof tactics: ยง0, ยง1, ยง2, ยง3\n"
"- Build and verify the **Euclidean GCD algorithm** from scratch\n"
"- Use your verified GCD to check primality\n"
"\n"
"By the end, you'll understand what it means to formally verify a program โ\n"
"and you'll have done it yourself."

#. ยง0: `simp_all`
#. ยง1: `grind`
#. ยง2: `grind`
#. ยง3: `grind [lemma, ...]`
#. ยง4: `grind`
#. ยง5: `double n = n + n`
#. ยง6: `double`
#. ยง7: `double n = double m`
#. ยง8: `n = m`
#. ยง9: ```lean
#. double_injective : โ (n m : Nat), double n = double m โ n = m
#. ```
#. ยง10: `intro n m h; grind [double]`
#. ยง11: `grind [double]`
#. ยง12: `double`
#. ยง13: `h : double n = double m`
#. ยง14: `n + n = m + m`
#. ยง15: `n = m`
#: Game.Levels.AutomationPower.L03_Grind
msgid "ยง0 is great for simplification. But some goals need more:\n"
"they require combining **equality reasoning** with **arithmetic**.\n"
"\n"
"Enter **ยง1** โ an automated prover that handles both at once.\n"
"ยง2 performs *congruence closure* (equality reasoning) and integrates\n"
"linear arithmetic. Feed it lemmas with ยง3 and it hunts\n"
"for a proof automatically.\n"
"\n"
"Let's put ยง4 to work on a new theorem from World 1 material.\n"
"\n"
"You know ยง5. Now prove that ยง6 is **injective**:\n"
"if ยง7, then ยง8.\n"
"\n"
"ยง9\n"
"\n"
"Try ยง10.\n"
"ยง11 tells the prover to use ยง12's definition as a rule.\n"
"It then rewrites ยง13 to ยง14 and deduces\n"
"ยง15 via arithmetic โ all automatically."
msgstr "ยง0 is great for simplification. But some goals need more:\n"
"they require combining **equality reasoning** with **arithmetic**.\n"
"\n"
"Enter **ยง1** โ an automated prover that handles both at once.\n"
"ยง2 performs *congruence closure* (equality reasoning) and integrates\n"
"linear arithmetic. Feed it lemmas with ยง3 and it hunts\n"
"for a proof automatically.\n"
"\n"
"Let's put ยง4 to work on a new theorem from World 1 material.\n"
"\n"
"You know ยง5. Now prove that ยง6 is **injective**:\n"
"if ยง7, then ยง8.\n"
"\n"
"ยง9\n"
"\n"
"Try ยง10.\n"
"ยง11 tells the prover to use ยง12's definition as a rule.\n"
"It then rewrites ยง13 to ยง14 and deduces\n"
"ยง15 via arithmetic โ all automatically."

#: Game.Levels.DataInvariants.L01_Stub Game.Levels.Termination.L01_Stub Game.Levels.PrePost.L01_Stub Game.Levels.ImperativeIntro.L01_Stub Game.Levels.ImperativeBoss.L01_Stub
msgid "Placeholder theorem for this stub world."
msgstr "Placeholder theorem for this stub world."

#. ยง0: `use expr`
#. ยง1: `โข โ x, P x`
#. ยง2: `P expr`
#: Game.Levels.ProofsInTypes.L01_Subtype
msgid "Supply a witness for an existential goal: ยง0 closes ยง1 when ยง2 holds."
msgstr "Supply a witness for an existential goal: ยง0 closes ยง1 when ยง2 holds."

msgid ""
msgstr "Project-Id-Version: Game v4.26.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-20\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#. ยง0: `native_decide`
#. ยง1: `isPrime`
#. ยง2: `isPrime`
#. ยง3: `myGcd`
#. ยง4: `myGcd`
#: Game.Levels.FirstProofs.L07_Primality
msgid "ยง0 compiled ยง1 to native code and **evaluated** each value\n"
"and verify the result. Since ยง2 is a computable function (using ยง3),\n"
"Lean can do this automatically โ no manual proof steps needed.\n"
"\n"
"The same ยง4 you proved correct in levels 4โ5 powers this verification.\n"
"This is **program verification in action**: prove your building blocks correct,\n"
"then compose them into larger verified programs.\n"
"\n"
"**Congratulations โ you've completed World 1!**\n"
"\n"
"Continue to World 2 to learn how to write complete functional specifications."
msgstr ""

#: Game.Levels.FirstProofs
msgid "First Proofs"
msgstr ""

#. ยง0: `intro n m h`
#. ยง1: `grind [double]`
#. ยง2: `grind`
#. ยง3: `double`
#: Game.Levels.AutomationPower.L03_Grind
msgid "After ยง0, try ยง1.\n"
"This tells ยง2 to unfold ยง3 and then use arithmetic to finish."
msgstr ""

#. ยง0: `f`
#. ยง1: `P โ Q`
#. ยง2: `g`
#. ยง3: `Q โ R`
#. ยง4: `g โ f`
#. ยง5: `P โ R`
#. ยง6: `f`
#. ยง7: `g`
#: Game.Levels.PrePost.L06_Composition
msgid "The real power of contracts: they **compose**.\n"
"\n"
"If function ยง0 has a contract ยง1 and function ยง2 has a contract ยง3,\n"
"then the pipeline ยง4 has contract ยง5. The postcondition of ยง6 becomes\n"
"the precondition of ยง7.\n"
"\n"
"No need for Hoare triples here โ this is a pure logical principle.\n"
"You have all the hypotheses you need; chain them together."
msgstr ""

#. ยง0: `myLog2 n > 0`
#. ยง1: `n โฅ 2`
#: Game.Levels.Termination.L03_MyLog2
msgid "ยง0 whenever ยง1."
msgstr ""

#. ยง0: `Nat.mul_div_cancel_left`
#. ยง1: `k * m / k = m`
#. ยง2: `simp [Nat.mul_div_cancel_left]`
#: Game.Levels.Termination.L04_Log2Double
msgid "ยง0 says ยง1. Try ยง2."
msgstr ""

#. ยง0: `simp [compile, eval, run_append, iha, ihb, run, step]`
#: Game.Levels.ImperativeBoss.L07_CompileMul
msgid "Same as addition: ยง0."
msgstr ""

#. ยง0: `.node (bstInsert x l) y r`
#. ยง1: `simp only [if_pos hxy, IsBST]`
#. ยง2: `exact โจallLt_bstInsert x y l hbst_l hxy hlt_l, hgt_r, ihl hbst_l, hbst_rโฉ`
#: Game.Levels.DataInvariants.L05_InsertBST
msgid "Insert went left. The result is ยง0.\n"
"Use ยง1 then\n"
"ยง2."
msgstr ""

#. ยง0: ```
#. (xs ++ ys).length = xs.length + ys.length
#. ```
#. ยง1: `xs`
#. ยง2: `ys`
#. ยง3: `xs`
#. ยง4: `xs = []`
#. ยง5: `xs = x :: xs'`
#. ยง6: `xs'`
#: Game.Levels.FirstProofs.L03_ListLength
msgid "Lists are everywhere in programming. Here's a fundamental property:\n"
"if you concatenate two lists, the length of the result is the sum of their lengths.\n"
"ยง0\n"
"\n"
"Prove this for **all** lists ยง1 and ยง2 of natural numbers.\n"
"\n"
"You'll need to reason by **structural induction** on the list ยง3:\n"
"- **Base case**: ยง4 โ the empty list is easy.\n"
"- **Inductive step**: ยง5 โ use the *induction hypothesis* about ยง6."
msgstr ""

#: Game.Levels.PurePrograms.L01_MyMap
msgid "Apply a function to every element of a list."
msgstr ""

#: Game.Levels.PurePrograms.L05_Tree
msgid "Binary Trees"
msgstr ""

#. ยง0: `@[grind โ]`
#. ยง1: `double_pos`
#. ยง2: `grind`
#. ยง3: `0 < n โ 0 < double n โ 0 < double (double n)`
#. ยง4: `hโ โ hโ`
#. ยง5: `@[grind โ]`
#. ยง6: `hโ`
#. ยง7: `have`
#: Game.Levels.TheGrinder.L04_GrindFwd
msgid "ยง0 registered ยง1 as a forward inference rule.\n"
"ยง2 fired it twice, chaining ยง3.\n"
"\n"
"The pattern generalizes: any implication ยง4 about your functions can be\n"
"annotated ยง5, and grind will fire it automatically whenever ยง6 appears.\n"
"This enables **automated reasoning chains** โ no manual ยง7 steps required."
msgstr ""

#. ยง0: `bstInsert`
#. ยง1: `IsBST`
#. ยง2: `AllLt`
#. ยง3: `AllGt`
#. ยง4: `bound`
#. ยง5: `x < bound`
#. ยง6: `bound`
#. ยง7: `bstInsert`
#. ยง8: `x < y`
#. ยง9: `y < x`
#. ยง10: `x = y`
#. ยง11: `induction t`
#. ยง12: `obtain`
#. ยง13: `IsBST`
#. ยง14: `AllLt`
#. ยง15: `simp only [bstInsert]`
#. ยง16: `by_cases hxy : x < y`
#. ยง17: `bstInsert`
#. ยง18: `simp`
#: Game.Levels.DataInvariants.L04_BoundsInsert
msgid "The key to proving ยง0 preserves ยง1 is showing that the\n"
"**bound predicates** ยง2 and ยง3 are preserved by insertion.\n"
"\n"
"If every value in a tree is less than ยง4, and we insert ยง5,\n"
"then every value in the result is still less than ยง6.\n"
"\n"
"The proof follows the structure of ยง7: **induction** on the tree,\n"
"then **case-split** on ยง8 / ยง9 / ยง10.\n"
"\n"
"**Strategy**:\n"
"1. ยง11 โ split into leaf and node cases\n"
"2. In the node case, ยง12 the pieces of ยง13 and ยง14\n"
"3. ยง15 to unfold the insertion one step\n"
"4. ยง16 to match ยง17's branching\n"
"5. In each branch, ยง18 with the IH and hypotheses to close the goal"
msgstr ""

#. ยง0: `simp [double]`
#. ยง1: `double`
#: Game.Levels.FirstProofs.L01_Double
msgid "Lean accepted your proof!\n"
"\n"
"ยง0 unfolded the definition of ยง1 and closed the goal by reflexivity.\n"
"\n"
"You have formally verified your first program. Welcome to program verification!"
msgstr ""

#. ยง0: `by_cases h : x โค y`
#: Game.Levels.Termination.L05_MergeLength
msgid "Use ยง0 to split on which element goes first."
msgstr ""

#: Game.Levels.ProofsInTypes.L05_Sorted
msgid "Sorted: An Inductive Predicate"
msgstr ""

#. ยง0: `induction ys`
#: Game.Levels.Termination.L05_MergeLength
msgid "Now use ยง0 to split on the second list."
msgstr ""

#. ยง0: `Sorted (x :: y :: ys)`
#. ยง1: `x โค y`
#: Game.Levels.ProofsInTypes.L05_Sorted
msgid "If ยง0, then ยง1"
msgstr ""

#: Game.Levels.PurePrograms.L06_BST
msgid "Binary Search Tree"
msgstr ""

#. ยง0: `Fin n`
#. ยง1: `n`
#. ยง2: `.val : Nat`
#. ยง3: `.isLt : val < n`
#. ยง4: ```lean
#. -- This compiles: 3 < 5
#. example : Fin 5 := โจ3, by omegaโฉ
#. 
#. -- This is a type error: 7 < 5 is false
#. -- example : Fin 5 := โจ7, by omegaโฉ  -- omega can't prove 7 < 5
#. ```
#. ยง5: `Fin`
#. ยง6: `Option`
#: Game.Levels.ProofsInTypes.L03_Fin
msgid "ยง0 is Lean's built-in type of natural numbers **strictly less than ยง1**.\n"
"It's a subtype with two fields:\n"
"- ยง2 โ the number\n"
"- ยง3 โ the proof it's in bounds\n"
"\n"
"ยง4\n"
"\n"
"Array indexing with ยง5 is **always safe** โ no runtime bounds check, no ยง6,\n"
"no panic. The bound is verified once, at compile time."
msgstr ""

#: Game.Levels.TheGrinder.L02_Arith
msgid "A write-pointer stays within a bounded buffer."
msgstr ""

#. ยง0: `intro a b h`
#. ยง1: `cases b`
#. ยง2: `b = 0`
#. ยง3: `b = b' + 1`
#: Game.Levels.FirstProofs.L05_GcdStep
msgid "Use ยง0, then ยง1 to split on whether ยง2 or ยง3."
msgstr ""

#: Game.Levels.ImperativeIntro.L02_Sum
msgid "Summing an Array"
msgstr ""

#. ยง0: `b โ 0`
#. ยง1: `myGcd a b = myGcd b (a % b)`
#: Game.Levels.FirstProofs.L05_GcdStep
msgid "When ยง0, ยง1."
msgstr ""

#. ยง0: `findFirst a target = none`
#. ยง1: `target โ a.toList`
#: Game.Levels.ImperativeIntro.L04_LinearSearch
msgid "ยง0 iff ยง1."
msgstr ""

#: Game.Levels.ProofsInTypes.L07_InsertSorted
msgid "Inserting into a sorted list yields a sorted list."
msgstr ""

#: Game.Levels.AutomationPower.L04_MapAppend
msgid "Map Distributes Over Append"
msgstr ""

#. ยง0: `ยฌp`
#. ยง1: `if p then a else b = b`
#: Game.Levels.ProofsInTypes.L07_InsertSorted
#: Game.Levels.ProofsInTypes.L07_InsertSorted
msgid "If ยง0, then ยง1."
msgstr ""

#: Game.Levels.ImperativeBoss.L08_CompileCorrect
msgid "Compiler correctness: running compiled code produces eval on the stack."
msgstr ""

#. ยง0: `nil`
#. ยง1: `by_cases h : x โค y`
#. ยง2: `merge`
#. ยง3: `ihxs`
#. ยง4: `xs`
#. ยง5: `ihys`
#. ยง6: `ys`
#. ยง7: `omega`
#. ยง8: `1 + ... = ...`
#: Game.Levels.Termination.L05_MergeLength
msgid "The proof mirrors the termination argument exactly:\n"
"- Base cases (ยง0 on either side) are immediate.\n"
"- In the recursive case, ยง1 splits on which branch ยง2 takes.\n"
"- ยง3 gives the length fact for the ยง4 branch; ยง5 for the ยง6 branch.\n"
"- ยง7 handles the arithmetic ยง8 in each case.\n"
"\n"
"This is the power of well-founded recursion: once Lean accepts the measure, the\n"
"function behaves like any total function in proofs."
msgstr ""

#. ยง0: `allGt_bstInsert`
#. ยง1: `ihr`
#. ยง2: `IsBST`
#: Game.Levels.DataInvariants.L05_InsertBST
msgid "Insert went right. Use ยง0 for the right bound and ยง1 for ยง2."
msgstr ""

#. ยง0: `e : EvenNat`
#. ยง1: `e.val % 2 = 0`
#: Game.Levels.ProofsInTypes.L02_SubtypeAccess
#: Game.Levels.ProofsInTypes.L03_Fin
msgid "For any ยง0, ยง1"
msgstr ""

#. ยง0: `@[grind]`
#. ยง1: `myMap_len_eq`
#. ยง2: `@[grind =]`
#. ยง3: `@[grind โ]`
#. ยง4: `@[grind]`
#: Game.Levels.TheGrinder.L05_Pattern
msgid "ยง0 registered ยง1 for E-matching.\n"
"Grind instantiated it twice and used transitivity automatically.\n"
"\n"
"Summary of grind annotations:\n"
"- ยง2 โ equations: rewrite LHS โ RHS automatically\n"
"- ยง3 โ implications: fire whenever premise holds\n"
"- ยง4 โ universally quantified theorems: E-match and instantiate\n"
"\n"
"One level to go. Let's combine them all."
msgstr ""

#. ยง0: `intro a`
#. ยง1: `mvcgen [allPositive]`
#. ยง2: `ok`
#. ยง3: `xs.prefix`
#: Game.Levels.ImperativeIntro.L03_AllPositive
msgid "Try ยง0, then apply ยง1 with an invariant about ยง2 and ยง3."
msgstr ""

#. ยง0: `myGcd`
#. ยง1: `myDiv`
#. ยง2: `myLog2`
#. ยง3: `merge`
#: Game.Levels.Termination.L06_Victory
msgid "Congratulations โ you have completed **World 5: Termination**!\n"
"\n"
"You have proved that four recursive functions terminate and reasoned about their\n"
"behavior:\n"
"- ยง0: the Euclidean algorithm (measure: second argument)\n"
"- ยง1: division by subtraction (measure: dividend)\n"
"- ยง2: logarithm by halving (measure: value)\n"
"- ยง3: sorted merge (measure: combined list length)\n"
"\n"
"The key insight: once Lean has verified a termination proof, every theorem you\n"
"prove about the function holds for *all* inputs โ no special cases, no partiality.\n"
"\n"
"**World 6** awaits: Data Invariants. You will prove that data structures like\n"
"sorted lists and balanced trees maintain their invariants through every operation."
msgstr ""

#. ยง0: `List.head?`
#. ยง1: `Option ฮฑ`
#. ยง2: `none`
#. ยง3: ```lean
#. def safeHead {ฮฑ : Type} (l : List ฮฑ) (_ : l โ []) : ฮฑ :=
#.   match l with
#.   | x :: _ => x
#.   | []      => by contradiction
#. ```
#. ยง4: `safeHead [] h`
#. ยง5: `[] โ []`
#. ยง6: `ฮฑ`
#. ยง7: `Option`
#. ยง8: `safeHead`
#. ยง9: `safeHead`
#: Game.Levels.ProofsInTypes.L04_SafeHead
msgid "ยง0 returns ยง1 โ safe, but forces callers to handle ยง2 everywhere,\n"
"even when they *know* the list is non-empty.\n"
"\n"
"Instead, we can demand a **proof** of non-emptiness as an argument:\n"
"\n"
"ยง3\n"
"\n"
"Calling ยง4 is a **type error** โ you cannot provide a proof of ยง5.\n"
"The function returns ยง6 directly; no ยง7 unwrapping needed.\n"
"\n"
"The statement below says ยง8 on a cons list returns the head element. Because\n"
"ยง9 reduces definitionally, the proof is trivial."
msgstr ""

#. ยง0: `0 < n โ 0 < double n`
#: Game.Levels.TheGrinder.L04_GrindFwd
msgid "ยง0 (registered as a grind forward rule)"
msgstr ""

#. ยง0: `omega`
#: Game.Levels.FirstProofs.L02_IsEven
msgid "The remaining goal is an arithmetic fact. Try ยง0."
msgstr ""

#: Game.Levels.PrePost.L03_Precondition
msgid "Preconditions Save Lives"
msgstr ""

#. ยง0: `simp [Stack.push, Stack.pop]`
#: Game.Levels.PrePost.L01_StackContract
msgid "Unfold both definitions with ยง0."
msgstr ""

#: Game.Levels.Termination.L03_MyLog2
msgid "Integer base-2 logarithm by repeated halving."
msgstr ""

#. ยง0: `intro a d`
#. ยง1: `mvcgen [findMax]`
#: Game.Levels.ImperativeIntro.L05_FindMax
msgid "Try ยง0, then ยง1 with the running-max invariant."
msgstr ""

#. ยง0: `isPrime 2 = true`
#. ยง1: `isPrime 3 = true`
#. ยง2: `isPrime 4 = false`
#. ยง3: `isPrime 5 = true`
#: Game.Levels.FirstProofs.L07_Primality
msgid "ยง0, ยง1, ยง2, ยง3"
msgstr ""

#: Game.Levels.PrePost
msgid "**World 7: Pre/Post Conditions**\n"
"\n"
"Contracts for code: specify what a function *requires* (preconditions) and\n"
"*guarantees* (postconditions), then prove the implementation satisfies its\n"
"contract.\n"
"\n"
"You will start with simple data-structure contracts, learn about preconditions,\n"
"and then meet **Hoare triples** โ the foundation of imperative program\n"
"verification."
msgstr ""

#: Game.Levels.AutomationPower.L06_GrindBST
msgid "Insert a value into a binary search tree, maintaining the BST ordering invariant."
msgstr ""

#: Game.Levels.AutomationPower.L07_FilterMap
msgid "Filter-Map Fusion"
msgstr ""

#. ยง0: `rfl`
#: Game.Levels.ProofsInTypes.L04_SafeHead
msgid "The definition reduces definitionally. Try ยง0."
msgstr ""

#: Game.Levels.Termination.L05_MergeLength
msgid "Sorted Merge Preserves Length"
msgstr ""

#. ยง0: `AllLt`
#. ยง1: `AllGt`
#. ยง2: `AllLt`
#. ยง3: `AllGt`
#: Game.Levels.DataInvariants.L03_InsertLeaf
msgid "A single-node tree is trivially a BST โ both subtrees are leaves, so ยง0\n"
"and ยง1 hold vacuously.\n"
"\n"
"The real challenge: preserving the invariant when inserting into a *non-empty* tree.\n"
"That requires showing the **bound predicates** ยง2 and ยง3 survive insertion."
msgstr ""

#: Game.Levels.Termination.L01_GcdSelf
msgid "A Familiar Function, New Property"
msgstr ""

#. ยง0: `Fin n`
#. ยง1: `exact i.isLt`
#: Game.Levels.ProofsInTypes.L03_Fin
msgid "Every ยง0 carries a proof field. Can you name it? Try ยง1."
msgstr ""

#. ยง0: `simp`
#: Game.Levels.FirstProofs.L03_ListLength
msgid "The empty list case: ยง0 handles it."
msgstr ""

#. ยง0: `foldr`
#. ยง1: `[]`
#. ยง2: `::`
#. ยง3: ```lean
#. def myFoldr {ฮฑ ฮฒ : Type} (f : ฮฑ โ ฮฒ โ ฮฒ) (init : ฮฒ) : List ฮฑ โ ฮฒ
#.   | []      => init
#.   | x :: xs => f x (myFoldr f init xs)
#. ```
#. ยง4: `myFoldr (ยท + ยท) 0 [1, 2, 3] = 1 + (2 + (3 + 0)) = 6`
#. ยง5: `(ยท :: ยท)`
#. ยง6: `[]`
#. ยง7: `myFoldr (ยท :: ยท) [] [1, 2, 3] = 1 :: (2 :: (3 :: [])) = [1, 2, 3]`
#: Game.Levels.PurePrograms.L03_MyFoldr
msgid "ยง0 is the most general list combinator โ it replaces ยง1 with an initial value\n"
"and ยง2 with a binary function.\n"
"\n"
"ยง3\n"
"\n"
"For example, ยง4.\n"
"\n"
"**Key insight**: if you fold with ยง5 and ยง6, you reconstruct the original list!\n"
"\n"
"ยง7\n"
"\n"
"**Your goal**: prove this identity law formally."
msgstr ""

#. ยง0: `grind`
#. ยง1: `written โค cap โค 1024 < 1025`
#. ยง2: `grind`
#. ยง3: `omega`
#. ยง4: `simp`
#: Game.Levels.TheGrinder.L02_Arith
msgid "ยง0's arithmetic engine derived ยง1 automatically.\n"
"\n"
"When proofs mix equality reasoning (hypothesis substitution) with inequalities,\n"
"ยง2 handles both simultaneously โ unlike ยง3, which only does arithmetic,\n"
"or ยง4, which only rewrites."
msgstr ""

#. ยง0: `double n = n + n`
#. ยง1: `n`
#: Game.Levels.FirstProofs.L01_Double
msgid "ยง0 for all ยง1."
msgstr ""

#: Game.Levels.ProofsInTypes.L06_SortedList
msgid "The empty sorted list."
msgstr ""

#. ยง0: `(myMap f l).length = l.length`
#: Game.Levels.TheGrinder.L05_Pattern
msgid "ยง0 (registered for grind E-matching)"
msgstr ""

#. ยง0: `double_even n`
#. ยง1: `โจn + n, double_even nโฉ : EvenNat`
#: Game.Levels.ProofsInTypes.L01_Subtype
msgid "The proof is the membership certificate. No certificate, no value.\n"
"\n"
"ยง0 is the proof we'd pack into ยง1."
msgstr ""

#. ยง0: `intro a b`
#. ยง1: `mvcgen [mutableSwap]`
#: Game.Levels.PrePost.L05_MutableSwap
msgid "Same pattern as before: ยง0 then ยง1."
msgstr ""

#. ยง0: `by_cases hxy : x < y`
#. ยง1: `bstInsert`
#: Game.Levels.DataInvariants.L05_InsertBST
msgid "Now ยง0 to match ยง1's branching."
msgstr ""

#: Game.Levels.TheGrinder.L01_Congr
msgid "Congruence Closure: Equal Inputs, Equal Outputs"
msgstr ""

#: Game.Levels.PurePrograms.L04_Half
msgid "The Termination Wall"
msgstr ""

#: Game.Levels.ProofsInTypes.L02_SubtypeAccess
msgid "Extracting the Packed Proof"
msgstr ""

#. ยง0: `step (.push n)`
#. ยง1: `n`
#. ยง2: `rfl`
#. ยง3: `Instr`
#. ยง4: `step`
#: Game.Levels.ImperativeBoss.L01_Instr
msgid "ยง0 simply prepends ยง1 to the stack โ exactly what ยง2 confirms.\n"
"\n"
"We now have the building blocks of a stack machine: ยง3 (the instruction set)\n"
"and ยง4 (single-instruction execution). Next, we will chain instructions together."
msgstr ""

#. ยง0: `compile_correct`
#. ยง1: `intro e`
#. ยง2: `exact compile_correct e []`
#: Game.Levels.ImperativeBoss.L10_Victory
msgid "This is a direct consequence of ยง0. Try ยง1 then\n"
"ยง2."
msgstr ""

#. ยง0: `let mut`
#. ยง1: ```lean
#. def mutableSwap (a b : Nat) : Id (Nat ร Nat) := do
#.   let mut x := a
#.   let mut y := b
#.   let t := x
#.   x := y
#.   y := t
#.   return (x, y)
#. ```
#. ยง2: `Id`
#: Game.Levels.PrePost.L05_MutableSwap
msgid "Here is the same swap, but written with ยง0 โ mutable local variables:\n"
"\n"
"ยง1\n"
"\n"
"ยง2 is Lean's *identity monad* โ it runs imperatively but has no side effects\n"
"beyond tracking mutable locals.\n"
"\n"
"Does mutation make the proof harder? Try it and find out!"
msgstr ""

#. ยง0: `intro a target`
#. ยง1: `mvcgen [findFirst]`
#. ยง2: `result`
#. ยง3: `xs.prefix`
#: Game.Levels.ImperativeIntro.L04_LinearSearch
msgid "Try ยง0, then ยง1 with an invariant about ยง2 and ยง3."
msgstr ""

#: Game.Levels.ImperativeBoss.L10_Victory
msgid "The headline theorem: compiling and running produces eval."
msgstr ""

#: Game.Levels.PurePrograms.L02_MyFilter
msgid "Keep only elements satisfying a boolean predicate."
msgstr ""

#: Game.Levels.ImperativeBoss
msgid "Imperative Boss"
msgstr ""

#: Game.Levels.ImperativeBoss.L08_CompileCorrect
msgid "The Correctness Theorem"
msgstr ""

#: Game.Levels.ProofsInTypes.L06_SortedList
msgid "SortedList: A Type That IS Its Invariant"
msgstr ""

#. ยง0: `@[simp]`
#. ยง1: `myFilter`
#. ยง2: ```lean
#. @[simp] theorem myFilter_nil (p : ฮฑ โ Bool) :
#.     myFilter p [] = [] := rfl
#. 
#. @[simp] theorem myFilter_cons (p : ฮฑ โ Bool) (x : ฮฑ) (xs : List ฮฑ) :
#.     myFilter p (x :: xs) =
#.       if p x then x :: myFilter p xs else myFilter p xs := rfl
#. ```
#. ยง3: `p`
#. ยง4: `!p`
#. ยง5: ```lean
#. (myFilter p l).length + (myFilter (fun x => !p x) l).length = l.length
#. ```
#. ยง6: `p`
#. ยง7: `!p`
#. ยง8: `l`
#. ยง9: `cons`
#. ยง10: `p x`
#. ยง11: `cases h : p x`
#. ยง12: `simp_all`
#. ยง13: `h`
#. ยง14: `omega`
#: Game.Levels.AutomationPower.L05_FilterPartition
msgid "Let's do the same ยง0 treatment for ยง1, then prove a\n"
"new theorem about it.\n"
"\n"
"ยง2\n"
"\n"
"Now the theorem: filtering a list with a predicate ยง3 and filtering with\n"
"its complement ยง4 together account for **every element**:\n"
"ยง5\n"
"\n"
"Each element goes into exactly one bucket โ either ยง6 kept it or ยง7 did.\n"
"\n"
"The proof strategy:\n"
"- Induct on ยง8\n"
"- For the ยง9 case, case-split on ยง10 with ยง11\n"
"- ยง12 handles the filter simplification using ยง13\n"
"- ยง14 closes the arithmetic"
msgstr ""

#. ยง0: `half 0 = 0`
#. ยง1: `half 1 = 0`
#. ยง2: `n โฅ 2`
#. ยง3: `n - 2 < n`
#: Game.Levels.PurePrograms.L04_Half
msgid "ยง0, ยง1, and when ยง2, ยง3."
msgstr ""

#: Game.Levels.PurePrograms.L02_MyFilter
msgid "Filtering a List"
msgstr ""

#. ยง0: `myGcd_self`
#. ยง1: `myGcd n n = n`
#. ยง2: `myLog2_pos`
#. ยง3: `2 โค n โ 0 < myLog2 n`
#. ยง4: `n โฅ 2`
#. ยง5: `n`
#: Game.Levels.Termination.L06_Victory
msgid "You have now proved:\n"
"- ยง0 (Level 1): ยง1\n"
"- ยง2 (Level 3): ยง3\n"
"\n"
"Both functions are **total** โ Lean verified their termination. That means you\n"
"can freely compose and chain results about them.\n"
"\n"
"Prove: for any ยง4, taking the GCD of ยง5 with itself and then computing\n"
"its log gives a positive result.\n"
"\n"
"This should take exactly two steps."
msgstr ""

#: Game.Levels.PrePost.L02_MapContract
msgid "Lookup After Insert"
msgstr ""

#. ยง0: `b = 0`
#. ยง1: `h : 0 โ 0`
#. ยง2: `omega`
#: Game.Levels.FirstProofs.L05_GcdStep
msgid "In this case ยง0 but ยง1. This is a contradiction โ try ยง2."
msgstr ""

#. ยง0: `myGcd`
#. ยง1: ```lean
#. def myGcd (a b : Nat) : Nat :=
#.   match b with
#.   | 0     => a
#.   | b' + 1 => myGcd (b' + 1) (a % (b' + 1))
#. termination_by b
#. decreasing_by exact Nat.mod_lt _ (Nat.succ_pos _)
#. ```
#. ยง2: `termination_by b`
#. ยง3: `a % (b'+1) < b'+1`
#. ยง4: `b = 0`
#. ยง5: `myGcd`
#. ยง6: `myGcd n n`
#: Game.Levels.Termination.L01_GcdSelf
msgid "You already proved things *about* ยง0 in World 1 โ the base case and the\n"
"step lemma. Here is the definition again, with its termination proof:\n"
"\n"
"ยง1\n"
"\n"
"ยง2 says: the second argument strictly decreases at every\n"
"recursive call. ยง3, so the algorithm always reaches ยง4.\n"
"\n"
"Because Lean has *checked* this termination proof, you can reason about ยง5\n"
"for **any** input โ including ยง6, which was not covered in World 1.\n"
"\n"
"Your goal: prove that every number is its own GCD."
msgstr ""

#. ยง0: `simp`
#. ยง1: `compile`
#. ยง2: `.add a b`
#. ยง3: `compile a ++ compile b ++ [.add]`
#. ยง4: `run_append`
#. ยง5: `iha`
#. ยง6: `ihb`
#. ยง7: `run`
#. ยง8: `step`
#. ยง9: `[.add]`
#. ยง10: `eval`
#. ยง11: `run_append`
#. ยง12: `step_*`
#: Game.Levels.ImperativeBoss.L06_CompileAdd
msgid "One ยง0 call closed the entire goal! Here is what happened:\n"
"- ยง1 unfolded ยง2 to ยง3\n"
"- ยง4 split this into three sequential runs\n"
"- ยง5 and ยง6 simplified the first two runs\n"
"- ยง7 and ยง8 handled the final ยง9 instruction\n"
"- ยง10 matched the result\n"
"\n"
"This is the power of building up the right lemmas (ยง11, ยง12)."
msgstr ""

#: Game.Levels.ImperativeBoss.L06_CompileAdd
msgid "Compiler correctness for addition."
msgstr ""

#: Game.Levels.TheGrinder.L01_Congr
msgid "Equal inputs to a hash function produce equal outputs."
msgstr ""

#: Game.Levels.ImperativeBoss.L03_Compile
msgid "The Compiler"
msgstr ""

#: Game.Levels.ImperativeBoss.L04_RunAppend
msgid "Composing Instruction Sequences"
msgstr ""

#. ยง0: `run_append`
#. ยง1: `is1 ++ is2`
#. ยง2: `s`
#. ยง3: `is1`
#. ยง4: `is2`
#. ยง5: `generalizing s`
#. ยง6: `step i s`
#. ยง7: `@[simp]`
#: Game.Levels.ImperativeBoss.L04_RunAppend
msgid "ยง0 is the workhorse lemma for compiler correctness. It says:\n"
"\n"
"> Running ยง1 on stack ยง2 is the same as first running ยง3 to get an\n"
"> intermediate stack, then running ยง4 on that.\n"
"\n"
"The key insight was ยง5 โ without it, the IH would only apply to the\n"
"original stack, but we need it for ยง6 (the stack after one instruction).\n"
"\n"
"With this lemma marked ยง7, the compiler correctness proofs become almost automatic."
msgstr ""

#: Game.Levels.DataInvariants.L06_BSTSet
msgid "A tree paired with a proof of the BST invariant."
msgstr ""

#. ยง0: `grind`
#. ยง1: `id1`
#. ยง2: `id2`
#. ยง3: `keyId`
#. ยง4: `a = b โ f a = f b`
#: Game.Levels.TheGrinder.L01_Congr
msgid "ยง0 merged ยง1, ยง2, and ยง3 into one equivalence class, then\n"
"applied the congruence rule ยง4 โ all automatically.\n"
"\n"
"Congruence closure is the foundation of grind's equality reasoning. Any chain of\n"
"equalities in the context is automatically exploited."
msgstr ""

#. ยง0: `swap a b = (b, a)`
#: Game.Levels.ImperativeIntro.L01_Swap
msgid "Swap two values: ยง0."
msgstr ""

#. ยง0: `.sorted`
#: Game.Levels.ProofsInTypes.L06_SortedList
msgid "The sorted proof is a struct field. Access it with ยง0."
msgstr ""

#: Game.Levels.FirstProofs.L05_GcdStep
msgid "GCD Step"
msgstr ""

#. ยง0: `add`
#. ยง1: ```
#. compile (.add a b) = compile a ++ compile b ++ [.add]
#. ```
#. ยง2: `s`
#. ยง3: `run (compile a) s`
#. ยง4: `eval a :: s`
#. ยง5: `a`
#. ยง6: `run (compile b) (eval a :: s)`
#. ยง7: `eval b :: eval a :: s`
#. ยง8: `b`
#. ยง9: `run [.add] (eval b :: eval a :: s)`
#. ยง10: `(eval a + eval b) :: s`
#. ยง11: `eval (.add a b) = eval a + eval b`
#. ยง12: `run (compile (.add a b)) s = eval (.add a b) :: s`
#. ยง13: `run_append`
#. ยง14: `simp`
#. ยง15: `iha`
#. ยง16: `ihb`
#. ยง17: `induction ... generalizing`
#: Game.Levels.ImperativeBoss.L06_CompileAdd
msgid "Now for the ยง0 case. The compiler produces:\n"
"ยง1\n"
"\n"
"Running this on stack ยง2:\n"
"1. ยง3 gives ยง4 (by IH for ยง5)\n"
"2. ยง6 gives ยง7 (by IH for ยง8)\n"
"3. ยง9 gives ยง10\n"
"\n"
"And ยง11, so ยง12.\n"
"\n"
"The ยง13 lemma does the heavy lifting: it splits the concatenated instruction\n"
"list into sequential runs. Then ยง14 with the inductive hypotheses closes the goal.\n"
"\n"
"In this level, the inductive hypotheses are given to you as explicit assumptions\n"
"ยง15 and ยง16. In L08, you will use ยง17 to generate them\n"
"yourself."
msgstr ""

#. ยง0: `intro a v`
#. ยง1: `mvcgen [countOcc]`
#: Game.Levels.ImperativeIntro.L06_CountOcc
msgid "Try ยง0, then ยง1 with a counting-prefix invariant."
msgstr ""

#. ยง0: `b โ 0`
#. ยง1: `myGcd a b`
#. ยง2: `myGcd b (a % b)`
#. ยง3: ```
#. b โ 0 โ myGcd a b = myGcd b (a % b)
#. ```
#. ยง4: `cases b`
#. ยง5: `b = 0`
#. ยง6: `b = b' + 1`
#. ยง7: `simp [myGcd]`
#: Game.Levels.FirstProofs.L05_GcdStep
msgid "Now prove the **recursive step** of the Euclidean algorithm:\n"
"when ยง0, ยง1 reduces to ยง2.\n"
"\n"
"ยง3\n"
"\n"
"*Tip*: Use ยง4 to split into ยง5 (contradiction) and ยง6\n"
"(where ยง7 applies the second equation of the definition)."
msgstr ""

#. ยง0: ```
#. โ (e : Expr) (s : List Int), run (compile e) s = eval e :: s
#. ```
#. ยง1: `.num n`
#. ยง2: `[.push n]`
#. ยง3: `s`
#. ยง4: `n :: s`
#. ยง5: `eval (.num n) = n`
#. ยง6: `run (compile (.num n)) s = eval (.num n) :: s`
#: Game.Levels.ImperativeBoss.L05_CompileNum
msgid "Now we begin proving compiler correctness โ the theorem that running compiled code\n"
"produces the same result as evaluating the expression.\n"
"\n"
"The full theorem is:\n"
"ยง0\n"
"\n"
"We will prove it case by case, starting with the base case: **number literals**.\n"
"\n"
"Compiling ยง1 produces ยง2. Running that on any stack ยง3 gives ยง4.\n"
"And ยง5. So ยง6.\n"
"\n"
"This follows directly from the definitions."
msgstr ""

#. ยง0: `Nat`
#: Game.Levels.ProofsInTypes.L05_Sorted
msgid "Predicate: a list of ยง0 is sorted in non-decreasing order."
msgstr ""

#: Game.Levels.ImperativeBoss.L07_CompileMul
msgid "Compiler Correctness: Multiplication"
msgstr ""

#: Game.Levels.TheGrinder.L05_Pattern
msgid "@[grind]: Registering Lemmas for E-matching"
msgstr ""

#. ยง0: `@[grind =]`
#. ยง1: `@[grind โ]`
#. ยง2: ```lean
#. @[grind โ] theorem double_pos (n : Nat) (h : 0 < n) : 0 < double n := by
#.   simp [double]; omega
#. ```
#. ยง3: `0 < ?n`
#. ยง4: `double_pos`
#. ยง5: `0 < double ?n`
#. ยง6: `double`
#. ยง7: ```lean
#. double_chain_pos (n : Nat) (h : 0 < n) : 0 < double (double n)
#. ```
#. ยง8: `h : 0 < n`
#. ยง9: `double_pos`
#. ยง10: `0 < double n`
#. ยง11: `0 < double n`
#. ยง12: `double_pos`
#. ยง13: `0 < double (double n)`
#. ยง14: `omega`
#. ยง15: `double`
#. ยง16: `simp`
#: Game.Levels.TheGrinder.L04_GrindFwd
msgid "ยง0 taught grind to rewrite equations. Now meet ยง1:\n"
"annotate an implication and grind applies it **automatically as a forward rule**.\n"
"\n"
"A forward rule says: whenever the premise holds in context, add the conclusion.\n"
"\n"
"ยง2\n"
"\n"
"With this annotation, whenever grind sees ยง3 as a hypothesis, it fires\n"
"ยง4 and adds ยง5 to its working set.\n"
"\n"
"**The challenge**: prove that ยง6 applied twice preserves positivity.\n"
"\n"
"ยง7\n"
"\n"
"The chain:\n"
"1. ยง8 โ fire ยง9 โ ยง10\n"
"2. ยง11 โ fire ยง12 again โ ยง13 โ\n"
"\n"
"ยง14 can't do this โ it doesn't know ยง15.\n"
"ยง16 can't do this โ it's not arithmetic simplification.\n"
"Only a forward rule engine can chain implications about defined functions."
msgstr ""

#. ยง0: `intro a b`
#. ยง1: `mvcgen [pureSwap]`
#: Game.Levels.PrePost.L04_HoareTriple
msgid "First ยง0 to name the inputs, then use ยง1\n"
"to verify the triple automatically."
msgstr ""

#. ยง0: `intro e s`
#. ยง1: `induction e generalizing s`
#: Game.Levels.ImperativeBoss.L08_CompileCorrect
msgid "Start with ยง0 then ยง1.\n"
"Each case matches a level you already proved (L05, L06, L07)."
msgstr ""

#. ยง0: `x โ insertSorted x l`
#. ยง1: `l`
#: Game.Levels.ProofsInTypes.L08_Victory
msgid "ยง0 for any list ยง1"
msgstr ""

#. ยง0: `induction is1 generalizing s`
#. ยง1: `generalizing s`
#. ยง2: `s`
#: Game.Levels.ImperativeBoss.L04_RunAppend
msgid "Now use ยง0. The ยง1 ensures the\n"
"inductive hypothesis works for any stack, not just ยง2."
msgstr ""

#: Game.Levels.PrePost.L01_StackContract
msgid "A stack: last-in, first-out."
msgstr ""

#. ยง0: `{x : T // P x}`
#. ยง1: `Fin n`
#. ยง2: `< n`
#: Game.Levels.ProofsInTypes
msgid "**Welcome to World 4: Proofs Packed in Types!**\n"
"\n"
"In Worlds 1โ3 we proved *theorems about programs*.\n"
"In this world, we go further: we pack those proofs *inside the types themselves*.\n"
"\n"
"The result: values whose types **guarantee** correctness.\n"
"The compiler becomes the verifier โ incorrect code simply won't compile.\n"
"\n"
"**New ideas in this world**:\n"
"- **Subtypes** ยง0 โ values bundled with their proof\n"
"- **ยง1** โ natural numbers that are provably ยง2\n"
"- **Proof-carrying functions** โ types that enforce pre/postconditions\n"
"- **Invariant-preserving structures** โ data structures that *cannot* violate their invariants"
msgstr ""

#. ยง0: `n = 0`
#. ยง1: `n = k + 1`
#. ยง2: `cases n`
#: Game.Levels.Termination.L01_GcdSelf
msgid "Split on whether ยง0 or ยง1 with ยง2."
msgstr ""

#. ยง0: `e = .mul a b`
#: Game.Levels.ImperativeBoss.L08_CompileCorrect
msgid "Inductive case: ยง0. Same proof as L07."
msgstr ""

#. ยง0: `log(2 ยท n) = log(n) + 1`
#. ยง1: `myLog2`
#. ยง2: ```
#. myLog2 (2 * n) = myLog2 n + 1   (when n > 0)
#. ```
#. ยง3: `myLog2_ge_two`
#. ยง4: `2 * n โฅ 2`
#. ยง5: `n > 0`
#. ยง6: `Nat.mul_div_cancel_left`
#. ยง7: `k * m / k = m`
#. ยง8: `0 < k`
#. ยง9: `rw`
#. ยง10: `simp`
#: Game.Levels.Termination.L04_Log2Double
msgid "Every logarithm satisfies: ยง0.\n"
"\n"
"For our integer ยง1, this becomes:\n"
"\n"
"ยง2\n"
"\n"
"You have ยง3 to unfold one step (since ยง4 when ยง5),\n"
"and ยง6 which says ยง7 when ยง8.\n"
"\n"
"Your proof is two lines: one ยง9 and one ยง10."
msgstr ""

#. ยง0: `simp`
#. ยง1: `mapInsert`
#. ยง2: `(k, v) :: m`
#. ยง3: `mapLookup`
#. ยง4: `k == k`
#. ยง5: `true`
#: Game.Levels.PrePost.L02_MapContract
msgid "Again, one line! ยง0 unfolded ยง1 to ยง2, then unfolded\n"
"ยง3 at the cons case, saw ยง4 (which simplifies to ยง5), and\n"
"closed the goal.\n"
"\n"
"These simple contracts โ *insert then lookup*, *push then pop* โ are the\n"
"building blocks of verified data structure libraries."
msgstr ""

#. ยง0: `induction lโ <;> simp_all`
#. ยง1: `@[simp]`
#. ยง2: `myMap`
#: Game.Levels.AutomationPower.L04_MapAppend
msgid "Use ยง0.\n"
"The ยง1 lemmas for ยง2 from Level 2 fire automatically."
msgstr ""

#: Game.Levels.ImperativeIntro.L05_FindMax
msgid "Running Maximum"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsโฆ ๐ญ"
msgstr ""

#. ยง0: `l`
#. ยง1: `cons`
#. ยง2: `simp only [myMap_cons, myFilter_cons]`
#. ยง3: `cases h : p (f x) <;> simp_all [Function.comp_apply]`
#: Game.Levels.AutomationPower.L07_FilterMap
msgid "Induct on ยง0. For the ยง1 case:\n"
"ยง2, then\n"
"ยง3."
msgstr ""

#. ยง0: `simp [mapInsert, mapLookup]`
#: Game.Levels.PrePost.L02_MapContract
msgid "Try ยง0."
msgstr ""

#. ยง0: `insertSorted`
#: Game.Levels.ProofsInTypes.L07_InsertSorted
msgid "Proved once, trusted forever. Any call to ยง0 on a sorted list yields\n"
"a sorted list โ the compiler will hold us to this contract on every use."
msgstr ""

#. ยง0: `AllLt bound t`
#. ยง1: `x < bound`
#. ยง2: `IsBST t`
#. ยง3: `AllLt bound (bstInsert x t)`
#: Game.Levels.DataInvariants.L04_BoundsInsert
#: Game.Levels.DataInvariants.L05_InsertBST
msgid "If ยง0 and ยง1 and ยง2, then ยง3."
msgstr ""

#: Game.Levels.ImperativeBoss.L01_Instr
msgid "Stack machine instructions: push, add, mul."
msgstr ""

#. ยง0: `constructor`
#. ยง1: `simp`
#. ยง2: `@[simp]`
#. ยง3: `myMap_cons`
#. ยง4: `myMap_nil`
#. ยง5: `grind`
#. ยง6: `@[grind โ]`
#: Game.Levels.TheGrinder.L06_Victory
msgid "Split with ยง0. For the length goal, use ยง1 โ the ยง2\n"
"lemmas from World 3 (ยง3, ยง4) evaluate the list automatically.\n"
"For the positivity goal, use ยง5 โ it fires the ยง6 annotation."
msgstr ""

#. ยง0: `bstInsert`
#. ยง1: `simp`
#. ยง2: `simp [hxy, hy, ihl hbst_l hx hbl, hbr]`
#: Game.Levels.DataInvariants.L04_BoundsInsert
msgid "In this branch, ยง0 goes left. Use ยง1 with the IH:\n"
"ยง2."
msgstr ""

#. ยง0: `simp_all`
#. ยง1: `simp`
#. ยง2: `@[simp]`
#. ยง3: `myMap`
#. ยง4: `@[simp]`
#. ยง5: `simp`
#. ยง6: `simp [myMap]`
#. ยง7: `grind`
#. ยง8: `grind [lemma, ...]`
#. ยง9: `myMap`
#. ยง10: `myFilter`
#: Game.Levels.AutomationPower
msgid "Welcome to **World 3: Automation Power**!\n"
"\n"
"You've proven programs correct one tactic at a time. Now we hand more\n"
"work to Lean's automation machinery โ the same proofs that took five\n"
"lines before will often collapse to one or two.\n"
"\n"
"**New tools in this world**:\n"
"\n"
"- **ยง0** โ like ยง1, but also rewrites using every hypothesis\n"
"  in the context. The induction hypothesis becomes automatic.\n"
"- **ยง2** โ an *attribute* that marks a theorem as a simplification\n"
"  rule. After tagging the equations of ยง3 with ยง4, plain\n"
"  ยง5 knows about them everywhere โ no need to write ยง6.\n"
"- **ยง7** โ an automated prover combining equality reasoning and\n"
"  arithmetic. Feed it hints with ยง8 and it hunts for\n"
"  a proof automatically.\n"
"\n"
"You'll revisit ยง9, ยง10, and the BST from World 2 โ and\n"
"prove brand-new theorems about them with far less effort."
msgstr ""

#. ยง0: `exact e.2`
#. ยง1: `exact e.property`
#: Game.Levels.ProofsInTypes.L02_SubtypeAccess
msgid "Try ยง0 or ยง1."
msgstr ""

#. ยง0: `intro n`
#: Game.Levels.FirstProofs.L02_IsEven
msgid "Start with ยง0 to introduce the variable."
msgstr ""

#. ยง0: `n`
#: Game.Levels.ProofsInTypes.L03_Fin
msgid "Type of natural numbers strictly less than ยง0, bundled with the proof."
msgstr ""

#. ยง0: `x :: xs`
#. ยง1: `simp [ih]`
#. ยง2: `omega`
#: Game.Levels.FirstProofs.L03_ListLength
msgid "For ยง0, try ยง1 then ยง2 for the arithmetic."
msgstr ""

#. ยง0: `rw [myGcd_self]`
#. ยง1: `myGcd n n`
#. ยง2: `n`
#: Game.Levels.Termination.L06_Victory
msgid "Use ยง0 to simplify ยง1 to ยง2."
msgstr ""

#. ยง0: `safeMod n d h`
#. ยง1: `d`
#: Game.Levels.PrePost.L03_Precondition
msgid "ยง0 is strictly less than ยง1."
msgstr ""

#: Game.Levels.ImperativeIntro.L01_Swap
msgid "Your First Imperative Proof"
msgstr ""

#. ยง0: `e = .num n`
#: Game.Levels.ImperativeBoss.L08_CompileCorrect
msgid "Base case: ยง0. Same proof as L05."
msgstr ""

#. ยง0: `@[grind]`
#. ยง1: `=`
#. ยง2: `โ`
#. ยง3: ```lean
#. @[grind] theorem myMap_len_eq (f : ฮฑ โ ฮฒ) (l : List ฮฑ) :
#.     (myMap f l).length = l.length := by
#.   induction l with
#.   | nil          => simp [myMap]
#.   | cons x xs ih => simp [myMap, ih]
#. ```
#. ยง4: `(myMap _ _).length`
#. ยง5: `myMap_len_eq`
#. ยง6: ```lean
#. map_map_len (f g : Nat โ Nat) (l : List Nat) :
#.     (myMap f (myMap g l)).length = l.length
#. ```
#. ยง7: `(myMap f (myMap g l)).length`
#. ยง8: `= (myMap g l).length`
#. ยง9: `(myMap g l).length`
#. ยง10: `= l.length`
#: Game.Levels.TheGrinder.L05_Pattern
msgid "The final annotation: ยง0 (without ยง1 or ยง2) registers a theorem for\n"
"grind's **E-matching** engine.\n"
"\n"
"E-matching is pattern-based: grind watches for terms matching the LHS of your theorem\n"
"and instantiates it automatically. It's how grind handles universally quantified lemmas\n"
"about recursive functions.\n"
"\n"
"ยง3\n"
"\n"
"With this annotation, whenever grind's E-matching engine sees ยง4,\n"
"it instantiates ยง5 automatically.\n"
"\n"
"**The challenge**: prove that mapping twice preserves length.\n"
"\n"
"ยง6\n"
"\n"
"E-matching fires twice:\n"
"1. ยง7 matches โ ยง8\n"
"2. ยง9 matches โ ยง10\n"
"\n"
"Transitivity gives the result."
msgstr ""

#. ยง0: `a`
#. ยง1: `b`
#. ยง2: `myGcd a b = 1`
#: Game.Levels.FirstProofs.L06_Coprime
msgid "ยง0 and ยง1 are coprime iff ยง2."
msgstr ""

#: Game.Levels.PurePrograms.L07_Expr
msgid "Expression Evaluator"
msgstr ""

#: Game.Levels.AutomationPower.L06_GrindBST
msgid "BST Insert: simp_all in Action"
msgstr ""

#: Game.Levels.FirstProofs.L03_ListLength
msgid "Length of Lists"
msgstr ""

#. ยง0: `obtain`
#: Game.Levels.DataInvariants.L04_BoundsInsert
msgid "Introduce the hypotheses, then destructure them with ยง0."
msgstr ""

#. ยง0: `double_injective`
#. ยง1: `grind [double]`
#. ยง2: `@[grind =]`
#. ยง3: `grind`
#. ยง4: ```lean
#. @[grind =] theorem double_eq (n : Nat) : double n = n + n := rfl
#. ```
#. ยง5: `@[grind =]`
#. ยง6: `double_eq`
#. ยง7: `double n`
#. ยง8: `n + n`
#. ยง9: ```lean
#. Statement double_mul2 (n : Nat) : double n = 2 * n
#. ```
#. ยง10: `double_eq`
#. ยง11: `grind`
#. ยง12: `double n`
#. ยง13: `n + n`
#. ยง14: `n + n = 2 * n`
#. ยง15: `grind [double]`
#. ยง16: `grind`
#: Game.Levels.TheGrinder.L03_GrindEq
msgid "In World 3 you proved ยง0 with ยง1 โ passing the\n"
"definition as a hint. This works, but every call site needs the hint.\n"
"\n"
"**A better approach**: annotate the equation once with ยง2, and\n"
"bare ยง3 rewrites automatically โ forever, everywhere.\n"
"\n"
"ยง4\n"
"\n"
"The ยง5 attribute registers ยง6 as a left-to-right rewrite rule\n"
"in grind's engine. Now whenever grind sees ยง7, it rewrites to ยง8.\n"
"\n"
"ยง9\n"
"\n"
"With ยง10 annotated:\n"
"1. ยง11 rewrites ยง12 โ ยง13\n"
"2. ยง14 is linear arithmetic โ\n"
"\n"
"Compare: in World 3 you wrote ยง15. Here, bare ยง16 suffices.\n"
"The annotation is the investment โ the payoff is zero-hint proofs."
msgstr ""

#: Game.Levels.FirstProofs.L07_Primality
msgid "Is This Prime?"
msgstr ""

#. ยง0: `double n = n + n`
#: Game.Levels.FirstProofs.L01_Double
#: Game.Levels.FirstProofs.L02_IsEven
#: Game.Levels.FirstProofs.L03_ListLength
#: Game.Levels.FirstProofs.L04_GcdBase
#: Game.Levels.FirstProofs.L06_Coprime
#: Game.Levels.PurePrograms.L01_MyMap
#: Game.Levels.PurePrograms.L02_MyFilter
#: Game.Levels.PurePrograms.L03_MyFoldr
#: Game.Levels.PurePrograms.L05_Tree
#: Game.Levels.PurePrograms.L06_BST
#: Game.Levels.PurePrograms.L07_Expr
#: Game.Levels.PurePrograms.L07_Expr
#: Game.Levels.AutomationPower.L02_SimpAttr
#: Game.Levels.AutomationPower.L02_SimpAttr
#: Game.Levels.AutomationPower.L02_SimpAttr
#: Game.Levels.AutomationPower.L02_SimpAttr
#: Game.Levels.AutomationPower.L03_Grind
#: Game.Levels.AutomationPower.L03_Grind
#: Game.Levels.AutomationPower.L04_MapAppend
#: Game.Levels.AutomationPower.L05_FilterPartition
#: Game.Levels.AutomationPower.L05_FilterPartition
#: Game.Levels.AutomationPower.L05_FilterPartition
#: Game.Levels.AutomationPower.L07_FilterMap
#: Game.Levels.TheGrinder.L04_GrindFwd
#: Game.Levels.TheGrinder.L05_Pattern
#: Game.Levels.ProofsInTypes.L04_SafeHead
#: Game.Levels.ProofsInTypes.L07_InsertSorted
#: Game.Levels.ProofsInTypes.L08_Victory
#: Game.Levels.ImperativeIntro.L02_Sum
#: Game.Levels.ImperativeIntro.L05_FindMax
#: Game.Levels.ImperativeIntro.L06_CountOcc
#: Game.Levels.ImperativeBoss.L01_Instr
#: Game.Levels.ImperativeBoss.L02_Run
#: Game.Levels.ImperativeBoss.L03_Compile
#: Game.Levels.ImperativeBoss.L09_Exec
msgid "ยง0"
msgstr ""

#. ยง0: `myFilter p l`
#. ยง1: `l`
#. ยง2: `p`
#: Game.Levels.AutomationPower.L05_FilterPartition
msgid "ยง0 returns the sublist of ยง1 whose elements satisfy predicate ยง2."
msgstr ""

#: Game.Levels.ImperativeBoss.L03_Compile
msgid "Compile an expression to stack machine instructions (postfix)."
msgstr ""

#. ยง0: `mvcgen [pureSwap]`
#. ยง1: `do`
#. ยง2: `(b, a)`
#. ยง3: `โฆโPโโฆ prog โฆโ r => โQ rโโฆ`
#. ยง4: `mvcgen`
#. ยง5: `mvcgen`
#: Game.Levels.PrePost.L04_HoareTriple
msgid "ยง0 unfolded the ยง1 block, checked that the return value\n"
"equals ยง2, and closed the proof automatically.\n"
"\n"
"This is the Hoare triple workflow:\n"
"1. **State the spec**: ยง3\n"
"2. **Call ยง4**: it generates verification conditions from the code.\n"
"3. **Close the VCs**: for simple programs, ยง5 does it all.\n"
"\n"
"For programs with loops, you will need to supply a **loop invariant** โ but\n"
"the workflow stays the same."
msgstr ""

#. ยง0: `simp only [bstInsert]`
#. ยง1: `by_cases hxy : x < y`
#: Game.Levels.DataInvariants.L04_BoundsInsert
msgid "Now ยง0 to unfold the insertion, then ยง1."
msgstr ""

#. ยง0: `native_decide`
#: Game.Levels.FirstProofs.L07_Primality
msgid "All of these are concrete computations. Try ยง0!"
msgstr ""

#. ยง0: ```
#. def myGcd (a b : Nat) : Nat :=
#.   match b with
#.   | 0     => a
#.   | b' + 1 => myGcd (b' + 1) (a % (b' + 1))
#. ```
#. ยง1: `(a, b)`
#. ยง2: `(b, a % b)`
#. ยง3: `b = 0`
#. ยง4: `b = 0`
#. ยง5: `myGcd a 0 = a`
#: Game.Levels.FirstProofs.L04_GcdBase
msgid "The **Euclidean algorithm** is one of the oldest algorithms in mathematics.\n"
"It computes the greatest common divisor (GCD) of two numbers:\n"
"ยง0\n"
"\n"
"The algorithm works by repeatedly replacing ยง1 with ยง2 until ยง3.\n"
"\n"
"Prove the **base case**: when ยง4, ยง5."
msgstr ""

#. ยง0: `(xs ++ ys).length = xs.length + ys.length`
#. ยง1: `simp_all`
#: Game.Levels.AutomationPower.L01_SimpAll
msgid "ยง0 (proved with ยง1)"
msgstr ""

#: Game.Levels.AutomationPower.L02_SimpAttr
msgid "@[simp]: Teaching simp New Rules"
msgstr ""

#: Game.Levels.ImperativeBoss.L02_Run
msgid "Execute a list of instructions on a stack."
msgstr ""

#: Game.Levels.ImperativeBoss.L10_Victory
msgid "A Verified Compiler"
msgstr ""

#. ยง0: `omega`
#: Game.Levels.ProofsInTypes.L01_Subtype
msgid "ยง0 closes pure arithmetic goals."
msgstr ""

#: Game.Levels.ImperativeIntro.L03_AllPositive
msgid "Are All Elements Positive?"
msgstr ""

#. ยง0: `termination_by <measure>`
#. ยง1: `decreasing_by <tactic>`
#. ยง2: `omega`
#: Game.Levels.PurePrograms.L04_Half
msgid "You've hit the termination wall โ and climbed it!\n"
"\n"
"- **Structural recursion**: Lean accepts it for free (lists, trees).\n"
"- **Non-structural recursion**: supply ยง0 and ยง1.\n"
"\n"
"ยง2 is powerful enough to discharge most arithmetic termination obligations.\n"
"You'll see this pattern again in World 4."
msgstr ""

#. ยง0: `intro n`
#: Game.Levels.FirstProofs.L01_Double
msgid "Start with ยง0 to bring the variable into scope."
msgstr ""

#. ยง0: `bstInsert`
#. ยง1: `x < bound`
#. ยง2: `AllLt bound (bstInsert x l)`
#. ยง3: `AllLt bound (bstInsert x r)`
#. ยง4: `AllLt bound t`
#: Game.Levels.DataInvariants.L04_BoundsInsert
msgid "The proof mirrors ยง0's structure exactly:\n"
"\n"
"- **Leaf**: the single-node result has ยง1 โ\n"
"- **Node, x < y**: insert left; the IH gives ยง2\n"
"- **Node, y < x**: insert right; the IH gives ยง3\n"
"- **Node, x = y**: tree unchanged; original ยง4 still holds\n"
"\n"
"This is the template for every invariant-preservation proof: **follow the operation's\n"
"structure** and show the invariant holds at each step."
msgstr ""

#. ยง0: `simp_all [bstMember]`
#. ยง1: `ihl`
#. ยง2: `simp [h, ...]`
#. ยง3: `simp_all`
#. ยง4: `ยฌ(x < y)`
#. ยง5: `y โค x`
#. ยง6: `simp [h]`
#. ยง7: `if_neg h`
#. ยง8: `simp_all`
#. ยง9: `simp [explicit_hints]`
#: Game.Levels.AutomationPower.L06_GrindBST
msgid "ยง0 in the first branch found the induction hypothesis ยง1\n"
"without being told โ it scanned the context and used it. That's one fewer explicit hint.\n"
"\n"
"The negation branches still use ยง2 because ยง3 normalizes\n"
"ยง4 to ยง5, which can confuse the if-then-else reduction. Plain ยง6\n"
"uses the hypothesis as-is, applying ยง7 directly.\n"
"\n"
"**Takeaway**: ยง8 is a powerful default, but knowing when to fall back to\n"
"ยง9 is part of mastering Lean automation."
msgstr ""

#: Game.Levels.Termination.L02_MyDiv
msgid "Division by Repeated Subtraction"
msgstr ""

#. ยง0: `Nat`
#: Game.Levels.ProofsInTypes.L07_InsertSorted
msgid "Insert a ยง0 into a sorted list, preserving order."
msgstr ""

#. ยง0: `@[grind =]`
#. ยง1: `double_eq`
#. ยง2: `grind`
#. ยง3: `@[grind =]`
#. ยง4: `grind`
#. ยง5: `grind [...]`
#. ยง6: `@[simp]`
#. ยง7: `grind`
#: Game.Levels.TheGrinder.L03_GrindEq
msgid "ยง0 turned ยง1 into a permanent rewrite rule for ยง2.\n"
"\n"
"The workflow:\n"
"1. Prove your equation theorem.\n"
"2. Tag it ยง3.\n"
"3. From then on, bare ยง4 rewrites it automatically โ no ยง5 hints needed.\n"
"\n"
"This is the ยง6 workflow you learned in World 3, but for ยง7."
msgstr ""

#. ยง0: `bstInsert`
#. ยง1: ```lean
#. bstInsert x .leaf = .node .leaf x .leaf
#. ```
#. ยง2: `AllLt`
#. ยง3: `AllGt`
#: Game.Levels.DataInvariants.L03_InsertLeaf
msgid "Does ยง0 preserve the BST property? Let's start with the simplest case:\n"
"inserting into an empty tree.\n"
"\n"
"Recall:\n"
"ยง1\n"
"\n"
"A single-node tree with empty subtrees is always a valid BST โ both ยง2\n"
"and ยง3 hold vacuously on leaves."
msgstr ""

#. ยง0: `default`
#: Game.Levels.ImperativeIntro.L05_FindMax
msgid "Find the maximum element of an array, returning ยง0 for the empty array."
msgstr ""

#. ยง0: `native_decide`
#: Game.Levels.ImperativeBoss.L02_Run
msgid "This is a concrete computation. Try ยง0."
msgstr ""

#: Game.Levels.PrePost.L02_MapContract
msgid "Insert a key-value pair at the front of an association list."
msgstr ""

#. ยง0: `cases b`
#. ยง1: `b = 0`
#. ยง2: `h : 0 โ 0`
#. ยง3: `omega`
#. ยง4: `b = b' + 1`
#. ยง5: `simp [myGcd]`
#. ยง6: `myGcd (b'+1) (a % (b'+1)) = myGcd (b'+1) (a % (b'+1))`
#. ยง7: `gcd_base`
#. ยง8: `cases`
#. ยง9: `induction`
#. ยง10: `cases b <;> tac`
#. ยง11: `tac`
#: Game.Levels.FirstProofs.L05_GcdStep
msgid "ยง0 split the proof into two cases:\n"
"- ยง1: contradicts ยง2, closed by ยง3.\n"
"- ยง4: ยง5 applied the second equation of the definition,\n"
"  giving ยง6.\n"
"\n"
"Together with ยง7, you have now verified **both equations** of the\n"
"Euclidean algorithm!\n"
"\n"
"*Coming up*: when both cases of a ยง8 (or ยง9) need the **same** tactic,\n"
"you can write ยง10 to apply ยง11 to every goal at once โ no need to\n"
"list each case separately. You'll see this in the next level."
msgstr ""

#. ยง0: `myMap`
#. ยง1: `myFilter`
#. ยง2: `myFoldr`
#. ยง3: `half`
#. ยง4: `Tree`
#. ยง5: `treeHeight`
#. ยง6: `bstInsert`
#. ยง7: `bstMember`
#. ยง8: `Expr`
#. ยง9: `eval`
#: Game.Levels.PurePrograms.L07_Expr
msgid "World 2 complete! You've built and verified:\n"
"- **ยง0**, **ยง1**, **ยง2** โ the classic list combinators\n"
"- **ยง3** โ a non-structural recursion with explicit termination proof\n"
"- **ยง4** and **ยง5** โ your own inductive type\n"
"- **ยง6/ยง7** โ BST insert-then-search correctness\n"
"- **ยง8/ยง9** โ a verified expression evaluator\n"
"\n"
"Onward to World 3: Subtypes!"
msgstr ""

#: Game.Levels.DataInvariants.L06_BSTSet
msgid "The empty BST."
msgstr ""

#: Game.Levels.PrePost.L06_Composition
msgid "Contract Composition"
msgstr ""

#. ยง0: `@[simp]`
#. ยง1: `simp_all`
#. ยง2: `myMap_nil`
#. ยง3: `myMap_cons`
#. ยง4: `@[simp]`
#: Game.Levels.AutomationPower.L04_MapAppend
msgid "One line. The ยง0 investment in Level 2 pays off here.\n"
"\n"
"ยง1 sees ยง2 and ยง3 in the simp set, uses\n"
"the induction hypothesis from the context, and closes both cases.\n"
"\n"
"This is the power of ยง4: tag your equations once, benefit everywhere."
msgstr ""

#: Game.Levels.ProofsInTypes.L08_Victory
msgid "Victory: The Proof-Carrying Insert"
msgstr ""

#. ยง0: ```lean
#. def countOcc (a : Array Nat) (v : Nat) : Id Nat := do
#.   let mut cnt := 0
#.   for x in a do
#.     if x = v then cnt := cnt + 1
#.   return cnt
#. ```
#. ยง1: `countOcc a v`
#. ยง2: `v`
#. ยง3: ```
#. โฆโTrueโโฆ countOcc a v โฆโ r => โr = (a.toList.filter (ยท = v)).lengthโโฆ
#. ```
#. ยง4: `cnt = (xs.prefix.filter (ยท = v)).length`
#: Game.Levels.ImperativeIntro.L06_CountOcc
msgid "The final level: count how many times a value appears in an array.\n"
"\n"
"ยง0\n"
"\n"
"**Your goal**: prove that ยง1 equals the number of times ยง2 appears:\n"
"ยง3\n"
"\n"
"The invariant is literally the spec restricted to the prefix:\n"
"*Hint*: ยง4."
msgstr ""

#: Game.Levels.PurePrograms.L07_Expr
msgid "Abstract syntax tree for arithmetic expressions."
msgstr ""

#. ยง0: ```
#. โ (e : Expr), run (compile e) [] = [eval e]
#. ```
#. ยง1: `compile_correct`
#. ยง2: `s = []`
#: Game.Levels.ImperativeBoss.L10_Victory
msgid "The headline theorem โ the one sentence that says it all:\n"
"\n"
"ยง0\n"
"\n"
"Running the compiled instructions on an empty stack produces a stack containing\n"
"exactly the evaluated result. Nothing more, nothing less.\n"
"\n"
"This follows directly from ยง1 (L08) โ just plug in ยง2."
msgstr ""

#. ยง0: `AllLt`
#. ยง1: `AllGt`
#. ยง2: `<`
#. ยง3: ```lean
#. theorem allGt_bstInsert (x bound : Nat) (t : Tree Nat) :
#.     IsBST t โ bound < x โ AllGt bound t โ AllGt bound (bstInsert x t)
#. ```
#. ยง4: `bstInsert`
#. ยง5: `IsBST`
#. ยง6: `t`
#. ยง7: `IsBST`
#. ยง8: `x < y`
#. ยง9: `y < x`
#. ยง10: `x = y`
#. ยง11: `IsBST`
#. ยง12: `AllLt y (...)`
#. ยง13: `allLt_bstInsert`
#. ยง14: `AllGt y (...)`
#. ยง15: `allGt_bstInsert`
#. ยง16: `IsBST (...)`
#: Game.Levels.DataInvariants.L05_InsertBST
msgid "You proved that ยง0 survives insertion. The symmetric result for ยง1\n"
"is provided below (the proof is identical with ยง2 flipped):\n"
"\n"
"ยง3\n"
"\n"
"Now prove the main theorem: **ยง4 preserves ยง5**.\n"
"\n"
"The structure is the same as Level 4:\n"
"1. Induction on ยง6, then destructure ยง7 in the node case\n"
"2. Case-split on ยง8 / ยง9 / ยง10\n"
"3. In each branch, assemble the four parts of ยง11 for the result:\n"
"   - ยง12 โ use ยง13 when the left subtree changed\n"
"   - ยง14 โ use ยง15 when the right subtree changed\n"
"   - ยง16 โ use the induction hypothesis for the changed subtree\n"
"   - The unchanged subtree keeps its original proof"
msgstr ""

#. ยง0: `simp [isEven, double]`
#. ยง1: `(n + n) % 2 = 0`
#. ยง2: `omega`
#. ยง3: `omega`
#: Game.Levels.FirstProofs.L02_IsEven
msgid "ยง0 unfolded both definitions, turning the goal into\n"
"ยง1. Then ยง2 โ Lean's built-in linear arithmetic solver โ\n"
"finished the proof automatically.\n"
"\n"
"ยง3 is incredibly powerful: it can prove any goal that follows from linear\n"
"arithmetic over integers and natural numbers."
msgstr ""

#. ยง0: `simp_all`
#. ยง1: `[ih]`
#. ยง2: `<;>`
#. ยง3: `induction xs <;> tac`
#. ยง4: `tac`
#. ยง5: `simp_all`
#: Game.Levels.AutomationPower.L01_SimpAll
msgid "ยง0 found the induction hypothesis in the context and used it\n"
"automatically โ no ยง1 needed.\n"
"\n"
"The ยง2 combinator is powerful: ยง3 applies ยง4 to\n"
"**both** the base case and the inductive case. Combined with ยง5, a\n"
"5-line induction proof collapses to one line."
msgstr ""

#: Game.Levels.DataInvariants.L04_BoundsInsert
msgid "Bounds Survive Insertion"
msgstr ""

#: Game.Levels.ImperativeBoss.L07_CompileMul
msgid "Compiler correctness for multiplication."
msgstr ""

#: Game.Levels.PurePrograms.L05_Tree
msgid "Binary tree type: either a leaf or a node with left subtree, value, right subtree."
msgstr ""

#: Game.Levels.DataInvariants.L02_CheckBST
msgid "Checking a BST"
msgstr ""

#. ยง0: `simp [compile, eval, run_append, iha, ihb, run, step]`
#. ยง1: `run_append`
#. ยง2: `iha`
#. ยง3: `ihb`
#. ยง4: `run`
#. ยง5: `step`
#: Game.Levels.ImperativeBoss.L06_CompileAdd
msgid "Try ยง0.\n"
"ยง1 splits the concatenation, ยง2/ยง3 handle the subexpressions,\n"
"and ยง4/ยง5 finish the last instruction."
msgstr ""

#. ยง0: `double n = n + n`
#: Game.Levels.TheGrinder.L03_GrindEq
msgid "ยง0 (registered as a grind rewrite rule)"
msgstr ""

#. ยง0: `(n + n) % 2 = 0`
#. ยง1: `n`
#: Game.Levels.ProofsInTypes.L01_Subtype
msgid "ยง0 for all ยง1"
msgstr ""

#: Game.Levels.TheGrinder.L02_Arith
msgid "Linear Arithmetic: Safety Conditions"
msgstr ""

#. ยง0: `induction l <;> simp_all [Function.comp_apply]`
#. ยง1: `Function.comp_apply`
#. ยง2: `(f โ g) x = f (g x)`
#. ยง3: `@[simp]`
#. ยง4: `myMap`
#: Game.Levels.AutomationPower.L02_SimpAttr
msgid "Use ยง0.\n"
"ยง1 is the lemma ยง2.\n"
"The ยง3 lemmas for ยง4 and the induction hypothesis do the rest."
msgstr ""

#. ยง0: `simp [compile, run, step, eval]`
#: Game.Levels.ImperativeBoss.L05_CompileNum
msgid "Unfold the definitions with ยง0."
msgstr ""

#. ยง0: `rw [myLog2_ge_two (by omega)]`
#. ยง1: `myLog2 (2 * n)`
#. ยง2: `myLog2 (2 * n / 2) + 1`
#. ยง3: `simp [Nat.mul_div_cancel_left]`
#. ยง4: `2 * n / 2`
#. ยง5: `n`
#: Game.Levels.Termination.L04_Log2Double
msgid "ยง0 replaced ยง1 with ยง2.\n"
"Then ยง3 simplified ยง4 to ยง5.\n"
"\n"
"This is the algebraic identity you'd expect from any logarithm โ and it follows\n"
"directly from the recursive definition and two standard lemmas."
msgstr ""

#. ยง0: `induction t`
#. ยง1: `leaf`
#. ยง2: `simp [bstInsert, bstMember]`
#. ยง3: `node l y r ihl ihr`
#. ยง4: `simp only [bstInsert]`
#. ยง5: `by_cases h1 : x < y`
#. ยง6: `h1 : x < y`
#. ยง7: `simp_all [bstMember]`
#. ยง8: `h1 : ยฌ(x < y)`
#. ยง9: `by_cases h2 : y < x`
#. ยง10: `simp [bstMember, h1, h2, ...]`
#: Game.Levels.AutomationPower.L06_GrindBST
msgid "Use ยง0. For ยง1, ยง2 closes it.\n"
"For ยง3: ยง4, then ยง5.\n"
"- If ยง6: ยง7 finds the IH automatically.\n"
"- If ยง8: use a second ยง9 and ยง10."
msgstr ""

#. ยง0: `myGcd`
#. ยง1: `n`
#. ยง2: `n โฅ 2`
#. ยง3: `d`
#. ยง4: `[2, n-1]`
#. ยง5: `n`
#. ยง6: ```
#. def isPrime (n : Nat) : Bool :=
#.   n โฅ 2 &&
#.   ((List.range n).drop 2).all (fun d => myGcd n d == 1)
#. ```
#. ยง7: ```
#. isPrime 2 = true โง isPrime 3 = true โง isPrime 4 = false โง isPrime 5 = true
#. ```
#. ยง8: `native_decide`
#: Game.Levels.FirstProofs.L07_Primality
msgid "You've built and verified the Euclidean algorithm. Now use it to verify\n"
"a **primality checker** built from ยง0!\n"
"\n"
"A number ยง1 is prime if ยง2 and every number ยง3 in ยง4\n"
"is coprime with ยง5:\n"
"ยง6\n"
"\n"
"Prove that 2, 3, and 5 are prime, and that 4 is not:\n"
"ยง7\n"
"\n"
"*Tip*: All four values are **computable** โ try ยง8 to evaluate them instantly."
msgstr ""

#: Game.Levels.PrePost.L03_Precondition
msgid "Safe modulo: requires a proof that the divisor is nonzero."
msgstr ""

#. ยง0: `SortedList`
#. ยง1: ```lean
#. def insertSorted (x : Nat) : List Nat โ List Nat
#.   | []      => [x]
#.   | y :: ys => if x โค y then x :: y :: ys else y :: insertSorted x ys
#. ```
#. ยง2: `insertSorted`
#. ยง3: `x โค y`
#. ยง4: `by_cases hxy : x โค y`
#. ยง5: `simp only [if_pos hxy]`
#. ยง6: `simp only [if_neg hxy]`
#. ยง7: `simp [Sorted]`
#: Game.Levels.ProofsInTypes.L07_InsertSorted
msgid "Having a ยง0 type is only useful if we can **build** sorted lists.\n"
"Here is a function that inserts an element into a sorted list, keeping it sorted:\n"
"\n"
"ยง1\n"
"\n"
"We need to prove that ยง2 **preserves** sortedness. The proof goes by\n"
"induction on the list. At each step we case-split on whether ยง3.\n"
"\n"
"Key tactics:\n"
"- ยง4 โ split into two cases\n"
"- ยง5 / ยง6 โ reduce the conditional\n"
"- ยง7 โ unfold the predicate and close the goal"
msgstr ""

#: Game.Levels.PurePrograms.L04_Half
msgid "Integer division by 2, defined by well-founded recursion."
msgstr ""

#. ยง0: `safeMod`
#. ยง1: `simp [safeMod]`
#. ยง2: `exact Nat.mod_lt n (by omega)`
#: Game.Levels.PrePost.L03_Precondition
msgid "Unfold ยง0 with ยง1, then use\n"
"ยง2 to close the goal."
msgstr ""

#. ยง0: `bstMember x (bstInsert x t) = true`
#. ยง1: `x`
#. ยง2: `t`
#: Game.Levels.AutomationPower.L06_GrindBST
msgid "ยง0 for any ยง1 and tree ยง2."
msgstr ""

#: Game.Levels.FirstProofs.L02_IsEven
msgid "Even Numbers"
msgstr ""

#. ยง0: `bstMember x (bstInsert x t) = true`
#. ยง1: `x`
#. ยง2: `t`
#: Game.Levels.PurePrograms.L06_BST
msgid "ยง0 for all ยง1 and ยง2.\n"
"\n"
"This is the fundamental correctness property of BSTs: if you insert something,\n"
"you can always find it. Proving the full BST ordering invariant is left for World 5!"
msgstr ""

#. ยง0: `intro is1 is2 s`
#. ยง1: `induction is1 generalizing s`
#: Game.Levels.ImperativeBoss.L04_RunAppend
msgid "Start with ยง0, then ยง1."
msgstr ""

#. ยง0: ```lean
#. def merge (xs ys : List Nat) : List Nat :=
#.   match xs, ys with
#.   | [], ys       => ys
#.   | xs, []       => xs
#.   | x :: xs, y :: ys =>
#.     if x โค y then x :: merge xs (y :: ys)
#.     else y :: merge (x :: xs) ys
#. termination_by xs.length + ys.length
#. decreasing_by all_goals (simp_wf; omega)
#. ```
#. ยง1: `xs`
#. ยง2: `ys`
#. ยง3: `x โค y`
#. ยง4: `xs`
#. ยง5: `else`
#. ยง6: `ys`
#. ยง7: `xs.length + ys.length`
#. ยง8: ```lean
#. merge_nil_left  : merge [] ys = ys
#. merge_nil_right : merge xs [] = xs
#. merge_cons_le   : x โค y โ merge (x :: xs) (y :: ys) = x :: merge xs (y :: ys)
#. merge_cons_gt   : ยฌx โค y โ merge (x :: xs) (y :: ys) = y :: merge (x :: xs) ys
#. ```
#: Game.Levels.Termination.L05_MergeLength
msgid "The classic merge function from merge sort:\n"
"\n"
"ยง0\n"
"\n"
"Neither ยง1 nor ยง2 alone decreases at every call โ but their *combined*\n"
"length does. In the ยง3 branch, ยง4 shrinks; in the ยง5 branch, ยง6\n"
"shrinks. So ยง7 strictly decreases.\n"
"\n"
"Four helper theorems are available:\n"
"ยง8\n"
"\n"
"Prove that merging preserves the total number of elements."
msgstr ""

#. ยง0: ```lean
#. inductive Expr where
#.   | num : Int โ Expr
#.   | add : Expr โ Expr โ Expr
#.   | mul : Expr โ Expr โ Expr
#. 
#. def eval : Expr โ Int
#.   | .num n     => n
#.   | .add e1 e2 => eval e1 + eval e2
#.   | .mul e1 e2 => eval e1 * eval e2
#. ```
#. ยง1: `eval`
#. ยง2: `Expr`
#. ยง3: `a * (b + c) = a*b + a*c`
#. ยง4: `simp [eval]`
#. ยง5: `Int`
#. ยง6: `Int.mul_add`
#. ยง7: `simp [eval, Int.mul_add]`
#: Game.Levels.PurePrograms.L07_Expr
msgid "Let's build a tiny **expression language** โ the kind at the heart of every compiler\n"
"and interpreter.\n"
"\n"
"ยง0\n"
"\n"
"ยง1 is structurally recursive on ยง2, so Lean accepts it automatically.\n"
"\n"
"**Your goal**: prove the distributive law โ ยง3 โ at the\n"
"expression level.\n"
"\n"
"After ยง4 unfolds the evaluator, the goal becomes a pure arithmetic\n"
"identity on ยง5. Lean knows this as ยง6, so\n"
"ยง7 closes it in one step."
msgstr ""

#. ยง0: `List`
#. ยง1: `Tree`
#. ยง2: `termination_by`
#. ยง3: `decreasing_by`
#. ยง4: `myGcd`
#: Game.Levels.PurePrograms
msgid "Welcome to **World 2: Pure Programs**!\n"
"\n"
"All code here is *pure* โ no mutable state, no side effects.\n"
"But purity doesn't mean simple: you'll build polymorphic list operations,\n"
"a binary search tree, and a tiny expression evaluator โ all verified by Lean.\n"
"\n"
"Along the way you'll hit the **termination wall**: Lean demands a proof that\n"
"every recursive function eventually stops.\n"
"\n"
"- **Structural recursion** (on ยง0, on ยง1): Lean accepts it automatically.\n"
"- **Non-structural recursion**: you must supply a measure with ยง2\n"
"  and prove it decreases with ยง3.\n"
"\n"
"You already saw this in World 1 with ยง4. Here you'll see it again โ and\n"
"understand exactly why Lean insists on it."
msgstr ""

#. ยง0: `induction xs generalizing ys`
#: Game.Levels.Termination.L05_MergeLength
msgid "Use ยง0 to split on the first list while keeping the IH general."
msgstr ""

#. ยง0: `Nat.mod_self`
#. ยง1: `(n+1) % (n+1)`
#. ยง2: `0`
#. ยง3: `myGcd (n+1) 0 = n+1`
#: Game.Levels.Termination.L01_GcdSelf
msgid "ยง0 rewrites ยง1 to ยง2, turning the recursive call into\n"
"the base case ยง3. Because Lean verified termination up front,\n"
"this equational reasoning is unconditionally valid.\n"
"\n"
"Next: a brand-new recursive function โ division by repeated subtraction."
msgstr ""

#. ยง0: `myLog2 n = 0`
#. ยง1: `n < 2`
#: Game.Levels.Termination.L03_MyLog2
#: Game.Levels.Termination.L03_MyLog2
#: Game.Levels.Termination.L04_Log2Double
#: Game.Levels.PrePost.L03_Precondition
msgid "ยง0 when ยง1."
msgstr ""

#. ยง0: ```lean
#. def findFirst (a : Array Nat) (target : Nat) : Id (Option Nat) := do
#.   let mut result : Option Nat := none
#.   for x in a do
#.     if result.isNone && x = target then
#.       result := some x
#.   return result
#. ```
#. ยง1: `none`
#. ยง2: `findFirst a target`
#. ยง3: `some target`
#. ยง4: `target`
#. ยง5: `none`
#. ยง6: ```
#. โฆโTrueโโฆ findFirst a target โฆโ r => โr = none โ target โ a.toListโโฆ
#. ```
#. ยง7: `result`
#. ยง8: `result = none โ target โ xs.prefix`
#: Game.Levels.ImperativeIntro.L04_LinearSearch
msgid "What if we want to *find* an element and return early?\n"
"\n"
"ยง0\n"
"\n"
"This records the first match it finds (or ยง1 if there is no match).\n"
"\n"
"**Your goal**: prove that ยง2 returns ยง3 when ยง4 is in\n"
"the array, and ยง5 otherwise:\n"
"ยง6\n"
"\n"
"The invariant should relate ยง7 to the prefix seen so far:\n"
"*Hint*: ยง8."
msgstr ""

#. ยง0: `x = y`
#. ยง1: `simp only [if_neg hxy, if_neg hyx, IsBST]`
#. ยง2: `exact โจhlt_l, hgt_r, hbst_l, hbst_rโฉ`
#: Game.Levels.DataInvariants.L05_InsertBST
msgid "ยง0: tree unchanged. ยง1 then\n"
"ยง2."
msgstr ""

#. ยง0: `add`
#. ยง1: `mul`
#. ยง2: `step`
#: Game.Levels.ImperativeBoss.L07_CompileMul
msgid "Same technique, same result. The ยง0 and ยง1 cases are symmetric โ\n"
"the only difference is which arithmetic operation ยง2 performs.\n"
"\n"
"You now have all three pieces of compiler correctness:\n"
"- **Base case**: numbers (L05)\n"
"- **Inductive case**: addition (L06)\n"
"- **Inductive case**: multiplication (L07)\n"
"\n"
"Time to put them together into the full theorem!"
msgstr ""

#: Game.Levels.DataInvariants.L01_IsBST
msgid "An empty tree is a valid BST."
msgstr ""

#. ยง0: `x`
#. ยง1: `x`
#: Game.Levels.DataInvariants.L06_BSTSet
msgid "After inserting ยง0, membership lookup finds ยง1."
msgstr ""

#. ยง0: `double n`
#: Game.Levels.FirstProofs.L02_IsEven
msgid "ยง0 is always even."
msgstr ""

#. ยง0: `n`
#. ยง1: `n > 1`
#. ยง2: `k`
#. ยง3: `[2, n-1]`
#: Game.Levels.FirstProofs.L07_Primality
msgid "ยง0 is prime iff ยง1 and it is coprime with all ยง2 in ยง3."
msgstr ""

#: Game.Levels.PrePost.L02_MapContract
msgid "Looking up a key after inserting it returns the inserted value."
msgstr ""

#. ยง0: ```
#. def double (n : Nat) : Nat := n + n
#. ```
#. ยง1: `double`
#. ยง2: `n`
#: Game.Levels.FirstProofs.L01_Double
msgid "Welcome to the **Program Verification Game**!\n"
"\n"
"In this game you will write mathematical proofs to verify that programs are correct.\n"
"The Lean proof assistant checks every step โ there is no way to cheat.\n"
"\n"
"Your first program:\n"
"ยง0\n"
"\n"
"ยง1 is supposed to double its input.\n"
"Prove that it always does โ for **every** natural number ยง2."
msgstr ""

#. ยง0: `myMap`
#. ยง1: `@[simp]`
#. ยง2: `myMap`
#. ยง3: ```lean
#. myMap f (lโ ++ lโ) = myMap f lโ ++ myMap f lโ
#. ```
#. ยง4: `@[simp]`
#. ยง5: `myMap`
#. ยง6: ```lean
#. induction lโ with
#. | nil          => simp [myMap]
#. | cons x xs ih => simp [myMap, ih]
#. ```
#. ยง7: `@[simp]`
#. ยง8: `simp_all`
#. ยง9: `myMap`
#. ยง10: ```lean
#. induction lโ <;> simp_all
#. ```
#: Game.Levels.AutomationPower.L04_MapAppend
msgid "Now that ยง0's equations are tagged ยง1, let's prove a new\n"
"structural theorem with almost no effort.\n"
"\n"
"**ยง2 distributes over list concatenation**:\n"
"ยง3\n"
"\n"
"Mapping over a concatenated list is the same as mapping each part and\n"
"concatenating the results. This is the *functor* distributivity law.\n"
"\n"
"In World 2, without ยง4 on ยง5, you would have written:\n"
"ยง6\n"
"\n"
"With ยง7 already in place, plain ยง8 suffices โ it knows\n"
"about ยง9 automatically and finds the IH in the context:\n"
"ยง10\n"
"\n"
"Try it!"
msgstr ""

#. ยง0: `Sorted`
#. ยง1: `List Nat`
#. ยง2: ```lean
#. @[simp] def Sorted : List Nat โ Prop
#.   | []          => True
#.   | [_]         => True
#.   | x :: y :: ys => x โค y โง Sorted (y :: ys)
#. ```
#. ยง3: `x :: y :: ys`
#. ยง4: `x โค y`
#. ยง5: `y :: ys`
#. ยง6: `simp [Sorted] at h`
#. ยง7: `simp [Sorted] at h`
#. ยง8: `h : Sorted (x :: y :: ys)`
#. ยง9: `h : x โค y โง Sorted (y :: ys)`
#. ยง10: `.1`
#. ยง11: `โง`
#: Game.Levels.ProofsInTypes.L05_Sorted
msgid "A **predicate on lists** can encode an invariant. Here is ยง0 for ยง1:\n"
"\n"
"ยง2\n"
"\n"
"- An empty list is trivially sorted.\n"
"- A singleton list is trivially sorted.\n"
"- A list ยง3 is sorted iff ยง4 and ยง5 is sorted.\n"
"\n"
"The tactic ยง6 unfolds the predicate **inside a hypothesis**.\n"
"After ยง7 where ยง8,\n"
"the hypothesis becomes ยง9.\n"
"Then ยง10 extracts the left part of ยง11."
msgstr ""

#: Game.Levels.FirstProofs.L04_GcdBase
msgid "GCD Base Case"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ๐"
msgstr ""

#. ยง0: `foldr (ยท :: ยท) [] l = l`
#. ยง1: `myFoldr`
#: Game.Levels.PurePrograms.L03_MyFoldr
msgid "ยง0 โ folding cons and nil over a list reconstructs the list.\n"
"This is called the **foldr identity law**, and it shows that ยง1 is the\n"
"most general way to process a list."
msgstr ""

#. ยง0: `List`
#. ยง1: `Array`
#: Game.Levels.PrePost.L01_StackContract
msgid "The proof is just one line โ unfold the definitions and the equation holds.\n"
"That's the beauty of simple contracts: the spec is obvious, and the proof is automatic.\n"
"\n"
"In a real system, you might swap the ยง0 implementation for an ยง1 or a\n"
"ring buffer. The contract stays the same; only the proof changes."
msgstr ""

#: Game.Levels.ImperativeBoss.L04_RunAppend
msgid "Running concatenated instructions equals running them sequentially."
msgstr ""

#. ยง0: ```lean
#. def myLog2 (n : Nat) : Nat :=
#.   match n with
#.   | 0 | 1  => 0
#.   | n + 2  => myLog2 ((n + 2) / 2) + 1
#. termination_by n
#. decreasing_by exact Nat.div_lt_self (by omega) (by omega)
#. ```
#. ยง1: `0`
#. ยง2: `1`
#. ยง3: `n โฅ 2`
#. ยง4: `n + 2`
#. ยง5: `Nat.div_lt_self`
#. ยง6: `(n+2)/2 < n+2`
#. ยง7: `n`
#. ยง8: ```lean
#. theorem myLog2_lt_two {n : Nat} (h : n < 2)  : myLog2 n = 0
#. theorem myLog2_ge_two {n : Nat} (h : 2 โค n)  : myLog2 n = myLog2 (n / 2) + 1
#. ```
#. ยง9: `n โฅ 2`
#. ยง10: `myLog2 n`
#: Game.Levels.Termination.L03_MyLog2
msgid "Integer base-2 logarithm, computed by halving:\n"
"\n"
"ยง0\n"
"\n"
"The match makes the cases explicit: ยง1 and ยง2 are base cases (result 0);\n"
"any ยง3 (written ยง4) halves and recurses. ยง5 certifies\n"
"that ยง6, so the measure ยง7 strictly decreases.\n"
"\n"
"Two helper theorems are available:\n"
"\n"
"ยง8\n"
"\n"
"Use them to prove: if ยง9, then ยง10 is positive."
msgstr ""

#. ยง0: `{n : Nat // n % 2 = 0}`
#: Game.Levels.ProofsInTypes.L01_Subtype
msgid "Subtype of even natural numbers: ยง0"
msgstr ""

#. ยง0: `grind`
#. ยง1: `@[grind]`
#. ยง2: `myMap_len_eq`
#. ยง3: `myMap f ...`
#. ยง4: `myMap g l`
#: Game.Levels.TheGrinder.L05_Pattern
msgid "Just ยง0. The ยง1 annotation on ยง2 makes E-matching\n"
"fire twice โ once for the outer ยง3 and once for the inner ยง4."
msgstr ""

#. ยง0: `x / y`
#. ยง1: `y`
#. ยง2: `x`
#. ยง3: ```lean
#. def myDiv (x y : Nat) : Nat :=
#.   if 0 < y โง y โค x then myDiv (x - y) y + 1 else 0
#. termination_by x
#. decreasing_by omega
#. ```
#. ยง4: `x`
#. ยง5: `y โค x`
#. ยง6: `0 < y`
#. ยง7: `y`
#. ยง8: `x - y < x`
#. ยง9: `omega`
#. ยง10: `myDiv 0 y = 0`
#. ยง11: `0 < y โง y โค 0`
#. ยง12: `0 < y`
#. ยง13: `y โค x`
#. ยง14: `myDiv x y = myDiv (x - y) y + 1`
#. ยง15: `n`
#. ยง16: `zero`
#. ยง17: `succ`
#. ยง18: `simp [myDiv]`
#: Game.Levels.Termination.L02_MyDiv
msgid "Here is a function that computes ยง0 by repeatedly subtracting ยง1 from ยง2:\n"
"\n"
"ยง3\n"
"\n"
"The termination measure is ยง4. When ยง5 and ยง6, subtracting ยง7\n"
"gives ยง8, so the measure strictly decreases. ยง9 verifies this.\n"
"\n"
"Two key facts follow directly from the definition:\n"
"- **Base case**: ยง10 (the condition ยง11 is always false)\n"
"- **Step case**: when ยง12 and ยง13, ยง14\n"
"\n"
"Your goal: prove that dividing a positive number by itself gives 1.\n"
"\n"
"**Hint**: Split into cases on ยง15. The ยง16 case follows from the hypothesis.\n"
"For the ยง17 case, ยง18 unfolds the definition and closes the goal."
msgstr ""

#: Game.Levels.PrePost.L02_MapContract
msgid "Look up a key in an association list."
msgstr ""

#. ยง0: `exec instrs`
#. ยง1: `step`
#: Game.Levels.ImperativeBoss.L09_Exec
msgid "ยง0 computes the same result as folding ยง1 over the instructions."
msgstr ""

#. ยง0: `d โ 0`
#: Game.Levels.PrePost.L03_Precondition
msgid "The precondition ยง0 made the proof possible โ without it, the statement\n"
"would be false!\n"
"\n"
"This is the essence of **design by contract**:\n"
"- The **precondition** says what the *caller* must guarantee.\n"
"- The **postcondition** says what the *function* will guarantee in return.\n"
"\n"
"In Lean, preconditions are just hypotheses in the function's type. The type\n"
"checker enforces them at every call site โ no runtime check needed."
msgstr ""

#: Game.Levels.PurePrograms.L01_MyMap
msgid "Mapping Over a List"
msgstr ""

#: Game.Levels.TheGrinder.L06_Victory
msgid "Victory: The Full Grinder"
msgstr ""

#. ยง0: `induction xs <;> simp_all <;> omega`
#. ยง1: `<;>`
#: Game.Levels.AutomationPower.L01_SimpAll
msgid "Try ยง0.\n"
"The ยง1 combinator applies the next tactic to *all* remaining goals at once."
msgstr ""

#. ยง0: `intro a`
#. ยง1: `mvcgen [sumArray] invariants? with grind`
#. ยง2: `mvcgen`
#: Game.Levels.ImperativeIntro.L02_Sum
msgid "Try ยง0, then ยง1 to see\n"
"what invariant skeleton ยง2 suggests."
msgstr ""

#: Game.Levels.Termination.L04_Log2Double
msgid "The Doubling Law"
msgstr ""

#: Game.Levels.PrePost.L04_HoareTriple
msgid "The Hoare Triple"
msgstr ""

#. ยง0: `Expr`
#. ยง1: `eval`
#. ยง2: ```lean
#. inductive Expr where
#.   | num : Int โ Expr
#.   | add : Expr โ Expr โ Expr
#.   | mul : Expr โ Expr โ Expr
#. 
#. def eval : Expr โ Int
#.   | .num n     => n
#.   | .add e1 e2 => eval e1 + eval e2
#.   | .mul e1 e2 => eval e1 * eval e2
#. ```
#. ยง3: `push n`
#. ยง4: `n`
#. ยง5: `add`
#. ยง6: `mul`
#. ยง7: ```lean
#. inductive Instr where
#.   | push : Int โ Instr
#.   | add  : Instr
#.   | mul  : Instr
#. 
#. def step : Instr โ List Int โ List Int
#.   | .push n, s           => n :: s
#.   | .add, x :: y :: rest  => (y + x) :: rest
#.   | .mul, x :: y :: rest  => (y * x) :: rest
#.   | _, s                  => s
#. ```
#. ยง8: `| _, s => s`
#. ยง9: `step`
#. ยง10: `Option`
#. ยง11: `step (.push n) s = n :: s`
#: Game.Levels.ImperativeBoss.L01_Instr
msgid "Welcome to the **final boss world**!\n"
"\n"
"Remember the ยง0 type and ยง1 function from World 2?\n"
"ยง2\n"
"\n"
"Now we are going to **compile** expressions to a stack machine and prove the compiler\n"
"correct. This is a classic program verification challenge โ and it will exercise\n"
"everything you have learned across all 8 worlds.\n"
"\n"
"A **stack machine** executes instructions one at a time, manipulating a stack of integers:\n"
"- ยง3 pushes ยง4 onto the stack\n"
"- ยง5 pops two values, pushes their sum\n"
"- ยง6 pops two values, pushes their product\n"
"\n"
"ยง7\n"
"\n"
"The fallback ยง8 handles stack underflow โ it never occurs for compiled programs,\n"
"but makes ยง9 total (no ยง10 needed).\n"
"\n"
"**Your goal**: prove that ยง11. This is true by definition!"
msgstr ""

#. ยง0: `{n : Nat // P n}`
#. ยง1: `โจn, hโฉ`
#. ยง2: `n : Nat`
#. ยง3: `h : P n`
#. ยง4: `h`
#. ยง5: ```lean
#. abbrev EvenNat := {n : Nat // n % 2 = 0}
#. ```
#. ยง6: `EvenNat`
#. ยง7: ```lean
#. -- This compiles: 4 is even
#. example : EvenNat := โจ4, by omegaโฉ
#. 
#. -- This is a type error: 3 is not even
#. -- example : EvenNat := โจ3, by omegaโฉ  -- omega can't prove 3 % 2 = 0
#. ```
#. ยง8: `n + n`
#. ยง9: `omega`
#: Game.Levels.ProofsInTypes.L01_Subtype
msgid "In Lean, ยง0 is a **subtype** โ a type whose values are pairs ยง1\n"
"where ยง2 and ยง3. The proof ยง4 is packed directly inside the value.\n"
"\n"
"For example:\n"
"ยง5\n"
"A value of type ยง6 is guaranteed to be even โ not by a runtime check, but by its type.\n"
"\n"
"ยง7\n"
"\n"
"The compiler is now the gatekeeper. To prove ยง8 is always even, use ยง9."
msgstr ""

#. ยง0: ```lean
#. def bstInsert (x : Nat) : Tree Nat โ Tree Nat
#.   | .leaf       => .node .leaf x .leaf
#.   | .node l y r =>
#.     if x < y then .node (bstInsert x l) y r
#.     else if y < x then .node l y (bstInsert x r)
#.     else .node l y r   -- x = y: already present
#. 
#. def bstMember (x : Nat) : Tree Nat โ Bool
#.   | .leaf       => false
#.   | .node l y r =>
#.     if x < y then bstMember x l
#.     else if y < x then bstMember x r
#.     else true
#. ```
#. ยง1: `x`
#. ยง2: `x`
#. ยง3: `true`
#. ยง4: `induction t`
#. ยง5: `leaf`
#. ยง6: `simp [bstInsert, bstMember]`
#. ยง7: `node`
#. ยง8: `simp only [bstInsert]`
#. ยง9: `by_cases h : x < y`
#. ยง10: `simp [h, bstMember, ...]`
#: Game.Levels.PurePrograms.L06_BST
msgid "A **Binary Search Tree (BST)** stores values in sorted order so we can search in\n"
"O(log n) time. The key property: every value in the left subtree is smaller than\n"
"the node's value, and every value in the right subtree is larger.\n"
"\n"
"ยง0\n"
"\n"
"**Your goal**: prove that after inserting ยง1, searching for ยง2 always returns ยง3.\n"
"\n"
"*Hint*: Use ยง4. For the ยง5 case, ยง6 closes it.\n"
"For the ยง7 case, use ยง8 to unfold the insert, then\n"
"ยง9 to split on the comparison, and close each branch with\n"
"ยง10."
msgstr ""

#. ยง0: `curMax = xs.prefix.foldl max d`
#. ยง1: `curMax`
#. ยง2: `max`
#. ยง3: `+`
#. ยง4: `max`
#. ยง5: `&&`
#: Game.Levels.ImperativeIntro.L05_FindMax
msgid "The invariant ยง0 mirrors exactly how ยง1 is built:\n"
"taking the maximum of the default and all elements seen so far.\n"
"\n"
"This *running-aggregate* pattern appears in many algorithms:\n"
"- Replace ยง2 with ยง3 โ you get the sum invariant from Level 2.\n"
"- Replace ยง4 with ยง5 โ you get a boolean-flag invariant like Level 3.\n"
"\n"
"The invariant is always the spec restricted to the prefix seen so far."
msgstr ""

#. ยง0: `intro a b`
#. ยง1: `constructor <;> intro h <;> exact h`
#. ยง2: `constructor`
#. ยง3: `intro h; exact h`
#: Game.Levels.FirstProofs.L06_Coprime
msgid "Use ยง0, then ยง1.\n"
"Or split manually: ยง2, then prove each direction with ยง3."
msgstr ""

#: Game.Levels.PurePrograms.L03_MyFoldr
msgid "Fold a list from the right with a binary function and initial value."
msgstr ""

#. ยง0: `myGcd n n = n`
#: Game.Levels.Termination.L01_GcdSelf
msgid "ยง0: a number is its own greatest common divisor."
msgstr ""

#. ยง0: `pureSwap a b`
#. ยง1: `(b, a)`
#: Game.Levels.PrePost.L04_HoareTriple
#: Game.Levels.PrePost.L05_MutableSwap
#: Game.Levels.ImperativeIntro.L01_Swap
msgid "ยง0 returns ยง1."
msgstr ""

#: Game.Levels.ImperativeIntro.L02_Sum
msgid "Sum all elements of an array."
msgstr ""

#. ยง0: `x โค y`
#. ยง1: `simp [h, ihxs]`
#. ยง2: `omega`
#: Game.Levels.Termination.L05_MergeLength
msgid "In the ยง0 branch: ยง1 then ยง2."
msgstr ""

#. ยง0: `grind`
#. ยง1: `@[grind =]`
#. ยง2: `[double]`
#: Game.Levels.TheGrinder.L03_GrindEq
msgid "Just ยง0. The ยง1 annotation replaces the ยง2 hint from World 3."
msgstr ""

#. ยง0: `simp [Sorted] at h`
#. ยง1: `h`
#. ยง2: `.1`
#. ยง3: `โง`
#: Game.Levels.ProofsInTypes.L05_Sorted
msgid "ยง0 unfolds the predicate in hypothesis ยง1. Then ยง2 extracts the left part of ยง3."
msgstr ""

#. ยง0: `step`
#. ยง1: ```lean
#. def run : List Instr โ List Int โ List Int
#.   | [], stack       => stack
#.   | i :: rest, stack => run rest (step i stack)
#. ```
#. ยง2: `run`
#. ยง3: `run [.push 2, .push 3, .add] []`
#. ยง4: `[5]`
#. ยง5: `native_decide`
#: Game.Levels.ImperativeBoss.L02_Run
msgid "A single ยง0 executes one instruction. To run an entire program, we apply\n"
"instructions one after another:\n"
"\n"
"ยง1\n"
"\n"
"ยง2 is structurally recursive on the instruction list, so Lean accepts it\n"
"automatically.\n"
"\n"
"**Your goal**: compute ยง3 and verify it equals ยง4.\n"
"\n"
"Since this is a concrete computation, ยง5 can evaluate it directly."
msgstr ""

#. ยง0: `map`
#. ยง1: ```lean
#. def myMap {ฮฑ ฮฒ : Type} (f : ฮฑ โ ฮฒ) : List ฮฑ โ List ฮฒ
#.   | []      => []
#.   | x :: xs => f x :: myMap f xs
#. ```
#. ยง2: `myMap`
#. ยง3: `f : ฮฑ โ ฮฒ`
#. ยง4: `ฮฑ`
#. ยง5: `ฮฒ`
#. ยง6: `myMap`
#. ยง7: `induction`
#. ยง8: `simp [myMap]`
#: Game.Levels.PurePrograms.L01_MyMap
msgid "In functional programming, ยง0 applies a function to every element of a list.\n"
"Let's define our own version and prove a key property about it.\n"
"\n"
"ยง1\n"
"\n"
"ยง2 takes a function ยง3 and a list of ยง4s, returning a list of ยง5s.\n"
"The output list has the same number of elements as the input.\n"
"\n"
"**Your goal**: prove that ยง6 preserves the length of any list.\n"
"\n"
"*Hint*: Use ยง7 on the list, then ยง8 with the induction hypothesis."
msgstr ""

#. ยง0: `run`
#. ยง1: ```lean
#. def exec (instrs : Array Instr) : Id (List Int) := do
#.   let mut stack : List Int := []
#.   for i in instrs do
#.     stack := step i stack
#.   return stack
#. ```
#. ยง2: `run`
#. ยง3: `foldl`
#. ยง4: ```lean
#. theorem run_eq_foldl (instrs : List Instr) (s : List Int) :
#.     run instrs s = instrs.foldl (fun s i => step i s) s
#. ```
#. ยง5: `mvcgen`
#: Game.Levels.ImperativeBoss.L09_Exec
msgid "We proved that ยง0 (a pure recursive function) correctly executes compiled code.\n"
"But real machines use loops, not recursion. Let's write an **imperative executor**:\n"
"\n"
"ยง1\n"
"\n"
"This is exactly the kind of loop you verified in the Imperative Intro world!\n"
"The invariant follows the familiar pattern: relate the mutable variable to the\n"
"prefix of elements processed so far.\n"
"\n"
"We also need a bridge lemma connecting ยง2 (recursive) to ยง3 (what the loop computes):\n"
"ยง4\n"
"\n"
"**Your goal**: verify the imperative executor using ยง5."
msgstr ""

#. ยง0: ```
#. def isEven (n : Nat) : Prop := n % 2 = 0
#. ```
#. ยง1: `double n = n + n`
#. ยง2: `simp [isEven, double]`
#. ยง3: `omega`
#: Game.Levels.FirstProofs.L02_IsEven
msgid "A natural number is **even** if it is divisible by 2.\n"
"We can express this as a proposition in Lean:\n"
"ยง0\n"
"\n"
"In the previous level, you proved that ยง1.\n"
"Now prove that doubling any number always produces an even number.\n"
"\n"
"*Tip*: ยง2 can unfold both definitions at once,\n"
"then ยง3 handles the arithmetic."
msgstr ""

#. ยง0: `myLog2 (2 * n) = myLog2 n + 1`
#. ยง1: `n`
#: Game.Levels.Termination.L04_Log2Double
msgid "The doubling law: ยง0 for positive ยง1."
msgstr ""

#: Game.Levels.AutomationPower
msgid "Automation Power"
msgstr ""

#. ยง0: ```lean
#. abbrev Stack (ฮฑ : Type) := List ฮฑ
#. 
#. def Stack.push (x : ฮฑ) (s : Stack ฮฑ) : Stack ฮฑ := x :: s
#. 
#. def Stack.pop : Stack ฮฑ โ Option (ฮฑ ร Stack ฮฑ)
#.   | [] => none
#.   | x :: xs => some (x, xs)
#. ```
#: Game.Levels.PrePost.L01_StackContract
msgid "Welcome to **Pre/Post Conditions**!\n"
"\n"
"A **contract** for a function says what it *guarantees* (postcondition) given what\n"
"it may *assume* (precondition). In this world we will write and prove contracts for\n"
"increasingly interesting programs.\n"
"\n"
"Let's start simple. Here is a stack, implemented as a list:\n"
"\n"
"ยง0\n"
"\n"
"The most basic contract: **pushing then popping gives back what you pushed**."
msgstr ""

#. ยง0: `simp`
#. ยง1: `True`
#: Game.Levels.DataInvariants.L02_CheckBST
msgid "ยง0 unfolded the predicates, eliminated ยง1 conjuncts, and closed the\n"
"numeric comparisons โ all in one step.\n"
"\n"
"For larger trees you'd need more work, but the structure is always the same:\n"
"unfold the predicates, check the bounds at each node."
msgstr ""

#: Game.Levels.TheGrinder
msgid "The Grinder"
msgstr ""

#. ยง0: `rfl`
#. ยง1: `safeHead (x :: xs) _`
#. ยง2: `x`
#. ยง3: `none`
#: Game.Levels.ProofsInTypes.L04_SafeHead
msgid "ยง0 works because ยง1 *definitionally equals* ยง2.\n"
"The compiler verified the precondition; we never needed to handle ยง3."
msgstr ""

#: Game.Levels.TheGrinder.L06_Victory
msgid "The full grinder: length + positivity in one shot"
msgstr ""

#. ยง0: `intro xs ys`
#. ยง1: `induction xs`
#: Game.Levels.FirstProofs.L03_ListLength
msgid "Start with ยง0, then use ยง1."
msgstr ""

#: Game.Levels.FirstProofs.L01_Double
msgid "Double or Nothing"
msgstr ""

#: Game.Levels.PrePost.L06_Composition
msgid "Contracts compose: post of f feeds into pre of g."
msgstr ""

#. ยง0: ```
#.       3
#.      / \\
#.     1   5
#. ```
#. ยง1: `.node (.node .leaf 1 .leaf) 3 (.node .leaf 5 .leaf)`
#. ยง2: `IsBST`
#. ยง3: `simp`
#. ยง4: `@[simp]`
#. ยง5: `1 < 3`
#. ยง6: `3 < 5`
#. ยง7: `omega`
#: Game.Levels.DataInvariants.L02_CheckBST
msgid "Let's verify that a concrete tree satisfies the BST invariant.\n"
"\n"
"ยง0\n"
"\n"
"This tree is ยง1.\n"
"\n"
"To show ยง2 holds, ยง3 unfolds all three predicates (since they are\n"
"marked ยง4) and reduces everything to numeric comparisons like\n"
"ยง5 and ยง6. Then ยง7 closes the arithmetic."
msgstr ""

#. ยง0: ```lean
#. termination_by <expression>   -- the measure that gets smaller
#. decreasing_by <tactic>        -- proof that it strictly decreases
#. ```
#: Game.Levels.Termination
msgid "**Welcome to World 5: Termination!**\n"
"\n"
"Every function in this game so far used *structural* recursion โ shrinking a\n"
"list or a number constructor by constructor. Lean accepted those automatically.\n"
"\n"
"Real algorithms often recurse differently:\n"
"- Division subtracts until zero (measure: the dividend)\n"
"- Logarithm halves until below 2 (measure: the value)\n"
"- Merge recurses on two shrinking lists at once (measure: combined length)\n"
"\n"
"Lean 4 handles all of these with two declarations:\n"
"ยง0\n"
"\n"
"Once Lean accepts the termination proof, the function is **total** โ you can\n"
"reason about it freely, for any input, forever.\n"
"\n"
"In each level, the function and its termination argument are already written.\n"
"Your job: prove a property *about* the function, using the same structure that\n"
"makes it terminate."
msgstr ""

#: Game.Levels.ProofsInTypes.L04_SafeHead
msgid "Safe Head: Proof-Carrying Functions"
msgstr ""

#. ยง0: `intro _`
#. ยง1: `simp [bstInsert]`
#: Game.Levels.DataInvariants.L05_InsertBST
msgid "ยง0 then ยง1 โ a single-node tree is a BST."
msgstr ""

#: Game.Levels.Termination.L05_MergeLength
msgid "Merging two lists preserves the total number of elements."
msgstr ""

#: Game.Levels.DataInvariants.L01_IsBST
msgid "A tree satisfies the BST ordering invariant."
msgstr ""

#: Game.Levels.PrePost.L01_StackContract
msgid "Stack Push/Pop Cancellation"
msgstr ""

#. ยง0: `filter`
#. ยง1: `Bool`
#. ยง2: ```lean
#. def myFilter {ฮฑ : Type} (p : ฮฑ โ Bool) : List ฮฑ โ List ฮฑ
#.   | []      => []
#.   | x :: xs => if p x then x :: myFilter p xs else myFilter p xs
#. ```
#. ยง3: `p x`
#. ยง4: `true`
#. ยง5: `x`
#. ยง6: `simp [myFilter]`
#. ยง7: `split`
#. ยง8: `p x`
#. ยง9: `simp_all`
#. ยง10: `omega`
#: Game.Levels.PurePrograms.L02_MyFilter
msgid "ยง0 keeps only the elements that satisfy a predicate (a function returning ยง1).\n"
"\n"
"ยง2\n"
"\n"
"When ยง3 is ยง4, we keep ยง5; otherwise we drop it.\n"
"\n"
"**Your goal**: prove that filtering never makes a list longer.\n"
"\n"
"*Hint*: After ยง6, use ยง7 to case-split on whether ยง8 is true or false,\n"
"then finish with ยง9 and ยง10."
msgstr ""

#. ยง0: `SortedList.insert`
#. ยง1: `.data`
#. ยง2: `insertSorted x sl.data`
#. ยง3: `insertSorted_mem`
#: Game.Levels.ProofsInTypes.L08_Victory
msgid "Unfold ยง0. The result's ยง1 is ยง2.\n"
"Then apply ยง3."
msgstr ""

#. ยง0: `t`
#. ยง1: `bound`
#: Game.Levels.DataInvariants.L01_IsBST
msgid "Every value in tree ยง0 is strictly less than ยง1."
msgstr ""

#. ยง0: `SortedList`
#. ยง1: `SortedList`
#: Game.Levels.ProofsInTypes.L06_SortedList
msgid "ยง0 bakes the invariant into the type. You get correctness for free โ\n"
"any function that takes a ยง1 can trust it's sorted, no check needed."
msgstr ""

#. ยง0: `i.isLt`
#. ยง1: `Fin`
#: Game.Levels.ProofsInTypes.L03_Fin
msgid "ยง0 is always there, always valid. That's the promise of ยง1."
msgstr ""

#. ยง0: ```lean
#. def half (n : Nat) : Nat :=
#.   if n < 2 then 0 else 1 + half (n - 2)
#. ```
#. ยง1: `n - 2`
#. ยง2: `n`
#. ยง3: `n - 2 < n`
#. ยง4: ```lean
#. def half (n : Nat) : Nat :=
#.   if n < 2 then 0 else 1 + half (n - 2)
#. termination_by n
#. decreasing_by omega
#. ```
#. ยง5: `termination_by n`
#. ยง6: `n`
#. ยง7: `decreasing_by omega`
#. ยง8: `omega`
#. ยง9: `n - 2 < n`
#. ยง10: `ยฌ(n < 2)`
#. ยง11: `half`
#. ยง12: `native_decide`
#. ยง13: `decreasing_by omega`
#. ยง14: `n โฅ 2`
#. ยง15: `n - 2 < n`
#. ยง16: `omega`
#: Game.Levels.PurePrograms.L04_Half
msgid "Until now, every recursive function you've seen has been **structurally recursive**:\n"
"each recursive call is on a smaller piece of the input (a tail, a subtree).\n"
"Lean accepts these automatically.\n"
"\n"
"But what about this?\n"
"\n"
"ยง0\n"
"\n"
"Lean **rejects** this without a termination proof! The recursive call is on ยง1,\n"
"not a structural predecessor of ยง2. Lean can't automatically verify that ยง3.\n"
"\n"
"We fix this with a **termination measure**:\n"
"\n"
"ยง4\n"
"\n"
"ยง5 says: *the measure is just ยง6 itself*.\n"
"ยง7 says: *trust ยง8 to prove ยง9 when ยง10*.\n"
"\n"
"**Your goal** has two parts:\n"
"1. Verify concrete values of ยง11 (using ยง12).\n"
"2. Prove the key arithmetic fact that makes ยง13 work: when ยง14, we have ยง15.\n"
"\n"
"The second part is exactly the inequality ยง16 closes automatically โ try it manually!"
msgstr ""

#: Game.Levels.ImperativeBoss.L01_Instr
msgid "The Stack Machine"
msgstr ""

#: Game.Levels.ImperativeIntro.L04_LinearSearch
msgid "Linear Search"
msgstr ""

#. ยง0: `myLog2 n`
#. ยง1: `myLog2_ge_two h`
#: Game.Levels.Termination.L03_MyLog2
msgid "Rewrite ยง0 using ยง1."
msgstr ""

#. ยง0: `bstInsert`
#. ยง1: `bstMember x (bstInsert x t) = true`
#. ยง2: `bstInsert`
#. ยง3: `true`
#. ยง4: ```lean
#. @[simp] def AllLt (bound : Nat) : Tree Nat โ Prop
#.   | .leaf => True
#.   | .node l x r => x < bound โง AllLt bound l โง AllLt bound r
#. 
#. @[simp] def AllGt (bound : Nat) : Tree Nat โ Prop
#.   | .leaf => True
#.   | .node l x r => bound < x โง AllGt bound l โง AllGt bound r
#. 
#. @[simp] def IsBST : Tree Nat โ Prop
#.   | .leaf => True
#.   | .node l x r => AllLt x l โง AllGt x r โง IsBST l โง IsBST r
#. ```
#. ยง5: `AllLt bound t`
#. ยง6: `t`
#. ยง7: `bound`
#. ยง8: `AllGt bound t`
#. ยง9: `t`
#. ยง10: `bound`
#. ยง11: `IsBST t`
#: Game.Levels.DataInvariants.L01_IsBST
msgid "In World 2 you built binary search trees with ยง0 and proved\n"
"ยง1. But we never checked that ยง2\n"
"actually **maintains** the BST ordering! A function might return ยง3 for\n"
"the wrong reasons if the tree's structure is broken.\n"
"\n"
"Time to define what it **means** for a tree to be a valid BST.\n"
"\n"
"Three predicates, all recursive on the tree:\n"
"\n"
"ยง4\n"
"\n"
"- ยง5: every value in ยง6 is strictly less than ยง7\n"
"- ยง8: every value in ยง9 is strictly greater than ยง10\n"
"- ยง11: left values < root < right values, recursively\n"
"\n"
"An empty tree is trivially a BST. Prove it!"
msgstr ""

#: Game
msgid "Learn to formally verify programs using Lean 4, from basic proofs to imperative algorithms."
msgstr ""

#. ยง0: `mvcgen [swap]`
#. ยง1: `do`
#. ยง2: `swap`
#. ยง3: `mvcgen`
#. ยง4: `โฆโPโโฆ prog โฆโ r => โQ rโโฆ`
#. ยง5: `mvcgen [prog]`
#. ยง6: `grind`
#: Game.Levels.ImperativeIntro.L01_Swap
msgid "ยง0 analysed the ยง1 block and discharged all verification conditions\n"
"automatically! Since ยง2 has no loops, there were no invariants needed โ ยง3\n"
"unfolded the sequential assignments and closed the resulting equalities on its own.\n"
"\n"
"For programs with loops we will need to supply a **loop invariant**, but the rest of\n"
"the workflow stays the same:\n"
"1. State the spec as ยง4.\n"
"2. Call ยง5 to generate the VCs.\n"
"3. Supply invariants and close VCs with ยง6."
msgstr ""

#. ยง0: `induction l`
#. ยง1: `simp`
#. ยง2: `cons x xs ih`
#. ยง3: `cases h : p x <;> simp_all <;> omega`
#: Game.Levels.AutomationPower.L05_FilterPartition
msgid "Use ยง0. The base case is ยง1.\n"
"For ยง2, try ยง3."
msgstr ""

#. ยง0: ```lean
#. def findMax (a : Array Nat) (default : Nat) : Id Nat := do
#.   let mut curMax := default
#.   for x in a do
#.     if x > curMax then curMax := x
#.   return curMax
#. ```
#. ยง1: `curMax`
#. ยง2: `default`
#. ยง3: `findMax`
#. ยง4: `List.foldl max default`
#. ยง5: ```
#. โฆโTrueโโฆ findMax a d โฆโ r => โr = a.toList.foldl max dโโฆ
#. ```
#. ยง6: `curMax`
#. ยง7: `curMax = xs.prefix.foldl max d`
#: Game.Levels.ImperativeIntro.L05_FindMax
msgid "A classic pattern: maintain the largest element seen so far.\n"
"\n"
"ยง0\n"
"\n"
"ยง1 starts at ยง2 and is updated whenever we see a larger element.\n"
"\n"
"**Your goal**: prove that ยง3 computes the same result as ยง4:\n"
"ยง5\n"
"\n"
"The invariant should relate ยง6 to the maximum of the prefix:\n"
"*Hint*: ยง7."
msgstr ""

#. ยง0: `.val`
#. ยง1: `.property`
#: Game.Levels.ProofsInTypes.L02_SubtypeAccess
msgid "ยง0 gives the data; ยง1 gives the proof. Both are always present."
msgstr ""

#. ยง0: `ok = true โ โ x โ xs.prefix, x โ 0`
#. ยง1: `ok`
#. ยง2: `xs.suffix = []`
#: Game.Levels.ImperativeIntro.L03_AllPositive
msgid "The invariant ยง0 is the **specification itself**,\n"
"restricted to the prefix seen so far. This is the canonical shape for boolean-flag\n"
"invariants.\n"
"\n"
"Notice the pattern: the flag ยง1 summarises everything that has been checked.\n"
"Once the loop ends (ยง2), the invariant immediately gives us the full spec."
msgstr ""

#. ยง0: `@[grind =] double_eq`
#. ยง1: `double n`
#. ยง2: `n + n`
#. ยง3: `@[grind โ] double_pos`
#. ยง4: `0 < double n`
#. ยง5: `0 < n`
#. ยง6: `@[grind] myMap_len_eq`
#. ยง7: `(myMap f l).length = l.length`
#. ยง8: ```lean
#. grinder_victory (f : Nat โ Nat) (n : Nat) (h : 0 < n) :
#.     (myMap f [n, double n]).length = 2 โง 0 < double n
#. ```
#. ยง9: `0 < double n`
#. ยง10: `@[grind โ] double_pos`
#. ยง11: `h : 0 < n`
#. ยง12: `(myMap f [n, double n]).length = 2`
#. ยง13: `@[simp]`
#. ยง14: `myMap`
#. ยง15: `simp`
#. ยง16: `constructor`
#: Game.Levels.TheGrinder.L06_Victory
msgid "All grind annotations are in scope through the import chain:\n"
"- ยง0 โ rewrites ยง1 to ยง2\n"
"- ยง3 โ derives ยง4 from ยง5\n"
"- ยง6 โ instantiates ยง7\n"
"\n"
"**The challenge**: prove a conjunction using all three engines.\n"
"\n"
"ยง8\n"
"\n"
"- **Right conjunct** ยง9: ยง10 fires on ยง11. โ\n"
"- **Left conjunct** ยง12:\n"
"  The ยง13 lemmas from World 3 unfold ยง14 and evaluate the list length to 2.\n"
"  Plain ยง15 closes this part.\n"
"\n"
"Use ยง16 to split the conjunction, then apply the right tool to each part."
msgstr ""

#: Game.Levels.ProofsInTypes.L03_Fin
msgid "Fin n: Bounded Naturals"
msgstr ""

#: Game.Levels.Termination.L06_Victory
msgid "Chaining Total Functions"
msgstr ""

#. ยง0: `l`
#. ยง1: `cons`
#. ยง2: `by_cases hxy : x โค y`
#. ยง3: `simp only [if_pos hxy]`
#. ยง4: `simp only [if_neg hxy]`
#. ยง5: `simp [Sorted]`
#: Game.Levels.ProofsInTypes.L07_InsertSorted
msgid "Induct on ยง0. For the ยง1 case, use ยง2.\n"
"Then ยง3 or ยง4 to reduce the conditional,\n"
"and ยง5 to unfold the predicate."
msgstr ""

#. ยง0: `Sorted`
#. ยง1: ```lean
#. structure SortedList where
#.   data   : List Nat
#.   sorted : Sorted data
#. ```
#. ยง2: `SortedList`
#. ยง3: ```lean
#. -- This is a type error โ Sorted [3, 1, 2] requires 3 โค 1, which omega refutes
#. -- example : SortedList := โจ[3, 1, 2], by simp [Sorted]; omegaโฉ
#. ```
#. ยง4: `List Nat + a separate boolean check`
#. ยง5: `SortedList`
#. ยง6: `trivial`
#. ยง7: `Sorted []`
#. ยง8: `Sorted []`
#. ยง9: `True`
#: Game.Levels.ProofsInTypes.L06_SortedList
msgid "We can pack the ยง0 proof directly into a structure:\n"
"\n"
"ยง1\n"
"\n"
"Now it is **impossible** to create an unsorted ยง2:\n"
"\n"
"ยง3\n"
"\n"
"Compare to ยง4: the check might be bypassed,\n"
"forgotten, or tested only in some code paths. With ยง5, there is **no bypass**.\n"
"\n"
"The empty sorted list is constructed with ยง6 for the ยง7 proof,\n"
"since ยง8 unfolds to ยง9."
msgstr ""

#. ยง0: `Expr`
#. ยง1: `eval`
#. ยง2: `mvcgen`
#. ยง3: `simp`
#. ยง4: `generalizing`
#: Game.Levels.ImperativeBoss
msgid "**World 9: Imperative Boss โ A Verified Compiler**\n"
"\n"
"The final challenge: build a **verified compiler** from arithmetic expressions to\n"
"a stack machine.\n"
"\n"
"You will:\n"
"1. Define a stack machine instruction set and executor\n"
"2. Write a compiler from ยง0 (World 2) to stack instructions\n"
"3. Prove compiler correctness: compiled code computes ยง1\n"
"4. Verify an imperative executor using ยง2\n"
"\n"
"This capstone ties together everything โ induction, ยง3 lemmas, ยง4,\n"
"and Hoare-logic verification โ into one coherent verified compilation pipeline."
msgstr ""

#: Game.Levels.PurePrograms
msgid "Pure Programs"
msgstr ""

#. ยง0: `t`
#. ยง1: `bound`
#: Game.Levels.DataInvariants.L01_IsBST
msgid "Every value in tree ยง0 is strictly greater than ยง1."
msgstr ""

#. ยง0: `grind`
#. ยง1: `@[grind =]`
#. ยง2: `grind [def]`
#. ยง3: `@[grind โ]`
#. ยง4: `@[grind]`
#. ยง5: `grind`
#: Game.Levels.TheGrinder.L06_Victory
msgid "You've mastered The Grinder!\n"
"\n"
"**What you learned:**\n"
"\n"
"- **ยง0 alone** โ congruence closure + linear arithmetic, no hints needed\n"
"- **ยง1** โ equation rewriting: replaces ยง2 hints permanently\n"
"- **ยง3** โ forward reasoning: chain implications about your functions\n"
"- **ยง4** โ E-matching: instantiate universally quantified lemmas automatically\n"
"\n"
"**The workflow**: annotate your invariants and equations once; let ยง5 verify\n"
"any downstream consequence โ in this file, in future files, forever.\n"
"\n"
"This is how industrial verification tools work: the specification is annotated once,\n"
"and the verifier checks every contract automatically."
msgstr ""

#. ยง0: `exact h`
#. ยง1: `myCoprime a b`
#. ยง2: `myGcd a b = 1`
#. ยง3: `constructor`
#. ยง4: `P โ Q`
#. ยง5: `P โง Q`
#. ยง6: `<;>`
#. ยง7: `constructor <;> intro h <;> exact h`
#. ยง8: `h`
#. ยง9: `exact h`
#. ยง10: `<;>`
#. ยง11: `induction xs <;> simp_all`
#. ยง12: `simp_all`
#: Game.Levels.FirstProofs.L06_Coprime
msgid "Both directions are proved by ยง0 โ because ยง1 is\n"
"**defined as** ยง2. They are literally the same proposition!\n"
"\n"
"ยง3 splits a goal of the form ยง4 (or ยง5) into separate subgoals.\n"
"The ยง6 combinator then applies the following tactic to **every** resulting goal.\n"
"So ยง7 means:\n"
"1. Split into two goals.\n"
"2. In each goal, introduce the hypothesis as ยง8.\n"
"3. In each goal, close with ยง9.\n"
"\n"
"You'll see ยง10 often in later worlds โ for example, ยง11\n"
"applies ยง12 to both the base case and the inductive case in one stroke."
msgstr ""

#. ยง0: `BSTSet.insert`
#. ยง1: `bstInsert`
#. ยง2: `member_after_insert`
#. ยง3: `exact member_after_insert x s.tree`
#: Game.Levels.DataInvariants.L06_BSTSet
msgid "Unfold ยง0 to reveal ยง1, then use ยง2\n"
"from World 2.\n"
"\n"
"Try ยง3."
msgstr ""

#. ยง0: `target`
#. ยง1: `a`
#. ยง2: `none`
#: Game.Levels.ImperativeIntro.L04_LinearSearch
msgid "Find the first occurrence of ยง0 in ยง1, returning ยง2 if absent."
msgstr ""

#. ยง0: `result = none โ target โ xs.prefix`
#. ยง1: `xs.prefix = a.toList`
#. ยง2: `return`
#. ยง3: `mvcgen`
#: Game.Levels.ImperativeIntro.L04_LinearSearch
msgid "The invariant ยง0 is again the specification restricted\n"
"to the prefix. Once the loop finishes, ยง1 and the invariant gives us\n"
"exactly what we want.\n"
"\n"
"Note that we used a simple accumulator rather than an early ยง2 โ ยง3 supports\n"
"early return too, but the accumulator version keeps the invariant straightforward."
msgstr ""

#. ยง0: `compile a ++ compile b ++ [.add]`
#. ยง1: ```
#. run (is1 ++ is2) s = run is2 (run is1 s)
#. ```
#. ยง2: `induction is1 generalizing s`
#. ยง3: `generalizing s`
#. ยง4: `s`
#. ยง5: `is1`
#: Game.Levels.ImperativeBoss.L04_RunAppend
msgid "The compiler concatenates instruction lists: ยง0.\n"
"To reason about this, we need a key lemma:\n"
"\n"
"**Running concatenated instructions is the same as running them sequentially.**\n"
"\n"
"ยง1\n"
"\n"
"This is the structural heart of compiler correctness โ it lets us break a compiled\n"
"program into pieces and reason about each piece independently.\n"
"\n"
"The proof uses **ยง2**. Why ยง3?\n"
"Because the inductive hypothesis must work for *any* stack, not just the original ยง4.\n"
"When we step through ยง5, the stack changes at each step โ so the IH needs to be\n"
"universally quantified over stacks."
msgstr ""

#. ยง0: `IsBST (.node l y r)`
#. ยง1: `intro hbst`
#. ยง2: `simp only [IsBST] at hbst`
#. ยง3: `obtain โจhlt_l, hgt_r, hbst_l, hbst_rโฉ := hbst`
#: Game.Levels.DataInvariants.L05_InsertBST
msgid "Introduce and destructure ยง0:\n"
"ยง1\n"
"ยง2\n"
"ยง3"
msgstr ""

#. ยง0: `Nat`
#. ยง1: `SortedList`
#. ยง2: `SortedList`
#: Game.Levels.ProofsInTypes.L08_Victory
msgid "Insert a ยง0 into a ยง1, returning a ยง2."
msgstr ""

#. ยง0: `step`
#. ยง1: `intro n s`
#. ยง2: `rfl`
#: Game.Levels.ImperativeBoss.L01_Instr
msgid "This follows directly from the definition of ยง0. Try ยง1 then ยง2."
msgstr ""

#: Game.Levels.AutomationPower.L01_SimpAll
msgid "simp_all: Turbo-Charged Simplification"
msgstr ""

#. ยง0: `Expr`
#. ยง1: `n`
#. ยง2: `[.push n]`
#. ยง3: `add a b`
#. ยง4: `compile a ++ compile b ++ [.add]`
#. ยง5: `mul a b`
#. ยง6: `compile a ++ compile b ++ [.mul]`
#. ยง7: ```lean
#. def compile : Expr โ List Instr
#.   | .num n   => [.push n]
#.   | .add a b => compile a ++ compile b ++ [.add]
#.   | .mul a b => compile a ++ compile b ++ [.mul]
#. ```
#. ยง8: `3 * (1 + 2)`
#. ยง9: `[.push 3, .push 1, .push 2, .add, .mul]`
#. ยง10: `3 * (1 + 2)`
#. ยง11: `[9]`
#: Game.Levels.ImperativeBoss.L03_Compile
msgid "Now for the star of the show: a compiler from ยง0 to stack machine instructions.\n"
"\n"
"The idea is **postfix** (reverse Polish) compilation:\n"
"- A number ยง1 compiles to ยง2\n"
"- ยง3 compiles to ยง4\n"
"- ยง5 compiles to ยง6\n"
"\n"
"ยง7\n"
"\n"
"For example, ยง8 compiles to ยง9.\n"
"\n"
"**Your goal**: verify that compiling and running ยง10 yields ยง11."
msgstr ""

#. ยง0: ```lean
#. inductive Tree (ฮฑ : Type) where
#.   | leaf : Tree ฮฑ
#.   | node : Tree ฮฑ โ ฮฑ โ Tree ฮฑ โ Tree ฮฑ
#. ```
#. ยง1: `Tree ฮฑ`
#. ยง2: `leaf`
#. ยง3: `node`
#. ยง4: ```lean
#. def treeHeight : Tree ฮฑ โ Nat
#.   | .leaf       => 0
#.   | .node l _ r => 1 + max (treeHeight l) (treeHeight r)
#. ```
#. ยง5: `treeHeight`
#. ยง6: `Tree ฮฑ`
#. ยง7: `termination_by`
#. ยง8: `node`
#: Game.Levels.PurePrograms.L05_Tree
msgid "Lists are one-dimensional. **Binary trees** branch in two directions:\n"
"\n"
"ยง0\n"
"\n"
"A ยง1 is either a ยง2 (empty) or a ยง3 with a left subtree, a value, and a right subtree.\n"
"\n"
"We can measure a tree's height recursively:\n"
"\n"
"ยง4\n"
"\n"
"Note: ยง5 is **structurally recursive** on ยง6, so Lean accepts it without\n"
"any ยง7 annotation.\n"
"\n"
"**Your goal**: prove that any non-empty tree (built with ยง8) has height โฅ 1."
msgstr ""

#. ยง0: ```
#. โ (e : Expr) (s : List Int), run (compile e) s = eval e :: s
#. ```
#. ยง1: `e`
#. ยง2: `s`
#. ยง3: `eval e`
#. ยง4: `s`
#. ยง5: `induction e generalizing s`
#. ยง6: `generalizing s`
#. ยง7: `add`
#. ยง8: `mul`
#. ยง9: `s`
#. ยง10: `compile a ++ compile b ++ [.add]`
#. ยง11: `s โ eval a :: s โ eval b :: eval a :: s โ ...`
#: Game.Levels.ImperativeBoss.L08_CompileCorrect
msgid "This is it โ the **compiler correctness theorem**:\n"
"\n"
"ยง0\n"
"\n"
"For *any* expression ยง1 and *any* initial stack ยง2, running the compiled instructions\n"
"produces a stack with ยง3 on top and ยง4 unchanged below.\n"
"\n"
"You proved each case separately in L05โL07. Now combine them using\n"
"**ยง5**.\n"
"\n"
"Why ยง6? The inductive hypotheses for ยง7 and ยง8 need to work\n"
"for *any* stack โ not just the original ยง9. When you process ยง10,\n"
"the stack changes between each piece: ยง11.\n"
"The IH must apply at each intermediate stack."
msgstr ""

#. ยง0: `merge [] ys = ys`
#: Game.Levels.Termination.L05_MergeLength
#: Game.Levels.Termination.L05_MergeLength
#: Game.Levels.Termination.L05_MergeLength
#: Game.Levels.Termination.L05_MergeLength
msgid "ยง0."
msgstr ""

#. ยง0: `bstInsert`
#. ยง1: `IsBST`
#. ยง2: `allLt_bstInsert`
#. ยง3: `allGt_bstInsert`
#. ยง4: `IsBST`
#: Game.Levels.DataInvariants.L05_InsertBST
msgid "The crown jewel of this world: **ยง0 preserves ยง1**.\n"
"\n"
"The proof assembled three ingredients:\n"
"- ยง2 โ bounds on the left subtree survive insertion\n"
"- ยง3 โ bounds on the right subtree survive insertion\n"
"- The induction hypothesis โ ยง4 on the modified subtree\n"
"\n"
"This is the classic pattern for data-structure invariants: prove helpers for\n"
"each component, then combine them for the main theorem."
msgstr ""

#. ยง0: `myGcd_self`
#. ยง1: `myLog2_pos`
#: Game.Levels.Termination.L06_Victory
msgid "Composition of ยง0 and ยง1: a chain of total functions."
msgstr ""

#. ยง0: ```lean
#. def mapInsert (k v : Nat) (m : List (Nat ร Nat)) : List (Nat ร Nat) :=
#.   (k, v) :: m
#. 
#. def mapLookup (k : Nat) : List (Nat ร Nat) โ Option Nat
#.   | [] => none
#.   | (k', v) :: rest => if k == k' then some v else mapLookup k rest
#. ```
#: Game.Levels.PrePost.L02_MapContract
msgid "Next: a simple key-value map, implemented as an association list.\n"
"\n"
"ยง0\n"
"\n"
"The contract: **looking up a key immediately after inserting it returns the\n"
"inserted value**."
msgstr ""

#: Game.Levels.TheGrinder.L04_GrindFwd
msgid "@[grind โ]: Forward Reasoning"
msgstr ""

#: Game.Levels.ImperativeBoss.L01_Instr
msgid "Execute a single instruction on a stack."
msgstr ""

#. ยง0: `simp ... at h`
#: Game.Levels.ProofsInTypes.L05_Sorted
msgid "ยง0 is the variant that simplifies *hypotheses* rather than the goal.\n"
"It's essential when you need to unfold a definition to extract information from an assumption."
msgstr ""

#. ยง0: `simp [h1, h2, bstMember, ihl]`
#. ยง1: `simp_all`
#. ยง2: `simp_all`
#. ยง3: `h : x < y`
#. ยง4: `ihl`
#. ยง5: `ihr`
#. ยง6: `h : ยฌ(x < y)`
#. ยง7: `simp_all`
#. ยง8: `h : y โค x`
#. ยง9: `if x < y then ... else ...`
#. ยง10: `simp [h, ...]`
#. ยง11: ```lean
#. by_cases h1 : x < y
#. ยท simp [h1, bstMember, ihl]        -- explicit ihl needed
#. ยท by_cases h2 : y < x
#.   ยท simp [h1, h2, bstMember, ihr]  -- explicit ihr needed
#.   ยท simp [h1, h2, bstMember]
#. ```
#. ยง12: `simp_all`
#. ยง13: ```lean
#. by_cases h1 : x < y
#. ยท simp_all [bstMember]           -- finds ihl automatically โ
#. ยท by_cases h2 : y < x
#.   ยท simp [bstMember, h1, h2, ihr]
#.   ยท simp [bstMember, h1, h2]
#. ```
#. ยง14: `simp_all`
#. ยง15: `ihl`
#. ยง16: `simp`
#: Game.Levels.AutomationPower.L06_GrindBST
msgid "In World 2, you proved BST correctness with explicit ยง0 calls.\n"
"ยง1 can improve this โ but with a catch.\n"
"\n"
"**The key insight**: ยง2 works best with *positive* hypotheses like ยง3.\n"
"It can search the context for ยง4 and ยง5 automatically. However, when you have\n"
"ยง6, ยง7 normalizes it to ยง8, which prevents the standard\n"
"ยง9 reduction. For those branches, plain ยง10 is safer.\n"
"\n"
"**World 2 proof**:\n"
"ยง11\n"
"\n"
"**World 3 proof** โ ยง12 handles the positive branch automatically:\n"
"ยง13\n"
"\n"
"The first branch is now cleaner. The ยง14 found ยง15 in the context without\n"
"being told. The other branches still use ยง16 with explicit hints."
msgstr ""

#: Game.Levels.FirstProofs.L06_Coprime
msgid "Coprime Numbers"
msgstr ""

#: Game.Levels.DataInvariants.L01_IsBST
msgid "An empty tree is a BST โ there are no elements to violate the ordering!\n"
"\n"
"This is the base case for every BST proof. Next: checking a non-trivial tree."
msgstr ""

#. ยง0: `[]`
#. ยง1: `([] ++ ys).length = ys.length = 0 + ys.length`
#. ยง2: `x :: xs`
#. ยง3: `ih`
#: Game.Levels.FirstProofs.L03_ListLength
msgid "You proved a fundamental list theorem by structural induction!\n"
"\n"
"The induction had two cases:\n"
"- **Base case** (ยง0): ยง1, trivial.\n"
"- **Inductive case** (ยง2): used the induction hypothesis ยง3 and\n"
"  Lean's built-in list lemmas to reduce to arithmetic.\n"
"\n"
"This is the essence of verification by induction."
msgstr ""

#. ยง0: `grind`
#. ยง1: `omega`
#. ยง2: `cap โค 1024`
#. ยง3: `written`
#. ยง4: `remaining`
#. ยง5: `written + remaining = cap`
#. ยง6: ```lean
#. buffer_bound (written remaining cap : Nat)
#.     (h1 : written + remaining = cap) (h2 : cap โค 1024) :
#.     written < 1025
#. ```
#. ยง7: `h1`
#. ยง8: `h2`
#. ยง9: `written โค written + remaining = cap โค 1024 < 1025`
#. ยง10: `grind`
#: Game.Levels.TheGrinder.L02_Arith
msgid "ยง0 combines congruence closure with a built-in **linear arithmetic** solver โ\n"
"think of it as ยง1 integrated with the equality engine.\n"
"\n"
"**The scenario**: you're writing bytes into a buffer of capacity ยง2.\n"
"You've written ยง3 bytes and have ยง4 bytes left to write, with\n"
"ยง5. You need to prove the write-pointer stays in bounds.\n"
"\n"
"ยง6\n"
"\n"
"From ยง7 and ยง8: ยง9.\n"
"ยง10 chains these inequalities without guidance."
msgstr ""

#. ยง0: ```lean
#. def sumArray (a : Array Nat) : Id Nat := do
#.   let mut s := 0
#.   for x in a do
#.     s := s + x
#.   return s
#. ```
#. ยง1: `mvcgen`
#. ยง2: `invariants`
#. ยง3: ```
#. mvcgen [sumArray] invariants
#. ยท <your invariant here>
#. with grind
#. ```
#. ยง4: `s`
#. ยง5: `a`
#. ยง6: `s`
#. ยง7: `i`
#. ยง8: `List.Cursor`
#. ยง9: `xs`
#. ยง10: `s`
#. ยง11: ```
#. mvcgen [sumArray] invariants
#. ยท โโจxs, sโฉ => โ<your invariant about xs and s>โ
#. with grind
#. ```
#. ยง12: `xs.prefix`
#. ยง13: `xs.prefix.foldl (ยท + ยท) 0`
#: Game.Levels.ImperativeIntro.L02_Sum
msgid "Time to add a loop! Here is a classic accumulator:\n"
"\n"
"ยง0\n"
"\n"
"For loop proofs, ยง1 needs a **loop invariant** โ a property that holds at the\n"
"start of every loop iteration. You supply it with the ยง2 keyword:\n"
"\n"
"ยง3\n"
"\n"
"The invariant here should relate the running sum ยง4 to the elements of ยง5 seen so far.\n"
"Think: *what does ยง6 equal after processing the first ยง7 elements?*\n"
"\n"
"The loop variable is a ยง8 named ยง9 (tracking which elements have been seen),\n"
"and ยง10 is the running sum. Use:\n"
"ยง11\n"
"*Hint*: ยง12 is the list of elements processed so far.\n"
"ยง13 is their sum."
msgstr ""

#: Game.Levels.ImperativeIntro.L03_AllPositive
msgid "Check whether all elements of an array are non-zero."
msgstr ""

#. ยง0: ```lean
#. def allPositive (a : Array Nat) : Id Bool := do
#.   let mut ok := true
#.   for x in a do
#.     if x = 0 then ok := false
#.   return ok
#. ```
#. ยง1: `ok`
#. ยง2: `true`
#. ยง3: `false`
#. ยง4: `allPositive a = true`
#. ยง5: `Nat`
#. ยง6: ```
#. โฆโTrueโโฆ allPositive a โฆโ r => โr = true โ โ x โ a.toList, x โ 0โโฆ
#. ```
#. ยง7: `ok`
#. ยง8: ```
#. mvcgen [allPositive] invariants
#. ยท โโจxs, okโฉ => โ<your invariant>โ
#. with grind
#. ```
#. ยง9: `ok = true โ โ x โ xs.prefix, x โ 0`
#: Game.Levels.ImperativeIntro.L03_AllPositive
msgid "Here is a loop that checks whether every element of an array is positive:\n"
"\n"
"ยง0\n"
"\n"
"The mutable flag ยง1 starts as ยง2 and flips to ยง3 the moment we see a zero.\n"
"\n"
"**Your goal**: prove that ยง4 exactly when every element is positive\n"
"(i.e. non-zero in ยง5):\n"
"ยง6\n"
"\n"
"The invariant should relate ยง7 to what has been seen so far:\n"
"ยง8\n"
"*Hint*: ยง9."
msgstr ""

#. ยง0: `x = y`
#. ยง1: `simp [hxy, hyx, hy, hbl, hbr]`
#: Game.Levels.DataInvariants.L04_BoundsInsert
msgid "ยง0, so the tree is unchanged. ยง1."
msgstr ""

#: Game.Levels.FirstProofs.L04_GcdBase
msgid "Euclidean GCD algorithm."
msgstr ""

#: Game.Levels.DataInvariants
msgid "Data Invariants"
msgstr ""

#. ยง0: `myFilter`
#. ยง1: `split`
#. ยง2: `if`
#. ยง3: `simp_all`
#. ยง4: `omega`
#: Game.Levels.PurePrograms.L02_MyFilter
msgid "ยง0 can only shrink (or preserve) a list โ it can never grow it.\n"
"Notice how ยง1 handled the ยง2 expression cleanly, letting ยง3 and ยง4\n"
"close each branch."
msgstr ""

#: Game.Levels.PurePrograms.L05_Tree
msgid "Height of a binary tree (0 for leaf, 1 + max of children for node)."
msgstr ""

#. ยง0: `simp_all`
#. ยง1: `simp`
#. ยง2: `simp_all`
#. ยง3: `ih`
#. ยง4: `simp [ih]`
#. ยง5: `simp_all`
#. ยง6: ```lean
#. -- World 1 (manual):
#. induction xs with
#. | nil          => simp
#. | cons x xs ih => simp [ih]; omega
#. 
#. -- World 3 (automated):
#. induction xs <;> simp_all <;> omega
#. ```
#. ยง7: `induction xs`
#. ยง8: `simp_all`
#: Game.Levels.AutomationPower.L01_SimpAll
msgid "**Welcome to World 3: Automation Power!**\n"
"\n"
"You've proven programs correct one tactic at a time. In this world we hand\n"
"more work to Lean's automation โ the same proofs that took five lines will\n"
"often collapse to one or two.\n"
"\n"
"Our first new tool is **ยง0**. You already know ยง1, which simplifies\n"
"the *goal*. ยง2 goes further: it simplifies both the *goal* **and every\n"
"hypothesis** in the context, then uses those simplified hypotheses to simplify\n"
"further โ repeating until nothing changes.\n"
"\n"
"The big win comes during **induction**: the induction hypothesis ยง3 is\n"
"automatically incorporated. You never need to write ยง4 again โ just\n"
"ยง5.\n"
"\n"
"**Compare the World 1 proof of this same theorem:**\n"
"ยง6\n"
"\n"
"Your goal is to prove that concatenating two lists produces a list whose\n"
"length is the sum of the parts. Use ยง7 and let ยง8\n"
"handle the inductive step automatically."
msgstr ""

#. ยง0: `SortedList`
#. ยง1: ```lean
#. structure BSTSet where
#.   tree : Tree Nat
#.   valid : IsBST tree
#. ```
#. ยง2: `BSTSet`
#. ยง3: `Tree Nat`
#. ยง4: ```lean
#. def BSTSet.empty : BSTSet := โจ.leaf, by simpโฉ
#. 
#. def BSTSet.insert (x : Nat) (s : BSTSet) : BSTSet :=
#.   โจbstInsert x s.tree, isBST_bstInsert x s.tree s.validโฉ
#. ```
#. ยง5: `BSTSet.insert`
#. ยง6: `isBST_bstInsert`
#: Game.Levels.DataInvariants.L06_BSTSet
msgid "Time to bundle everything into a **verified type**, just like ยง0\n"
"from World 4.\n"
"\n"
"ยง1\n"
"\n"
"A ยง2 is a ยง3 paired with a proof that it satisfies the BST\n"
"invariant. You cannot construct an invalid BST โ the type system prevents it.\n"
"\n"
"We also define:\n"
"ยง4\n"
"\n"
"ยง5 uses ยง6 (your theorem from Level 5!) to prove\n"
"the result is still a valid BST.\n"
"\n"
"For the final proof: show that the inserted element can always be found."
msgstr ""

#: Game.Levels.Termination
msgid "Termination"
msgstr ""

#. ยง0: `โฆโPโโฆ prog โฆโ r => โQ rโโฆ`
#. ยง1: `mvcgen`
#: Game.Levels.PrePost.L06_Composition
msgid "Congratulations โ you have completed **Pre/Post Conditions**!\n"
"\n"
"What you learned:\n"
"- **Postconditions**: what a function guarantees (Levels 1โ2)\n"
"- **Preconditions**: what a function requires (Level 3)\n"
"- **Hoare triples**: ยง0 (Level 4)\n"
"- **Mutable state**: same verification workflow (Level 5)\n"
"- **Composition**: postcondition of one = precondition of next (Level 6)\n"
"\n"
"This is the foundation of **formal program verification**. In the next world,\n"
"you will verify imperative programs with loops โ using loop invariants and\n"
"the same ยง1 workflow.\n"
"\n"
"Onward to **Imperative Intro**!"
msgstr ""

#. ยง0: `intro instrs`
#. ยง1: `mvcgen [exec] invariants`
#. ยง2: `sumArray`
#. ยง3: `countOcc`
#: Game.Levels.ImperativeBoss.L09_Exec
msgid "Try ยง0 then use ยง1 with a foldl-over-prefix\n"
"invariant, just like ยง2 and ยง3 from the Imperative Intro world."
msgstr ""

#: Game.Levels.PrePost
msgid "Pre/Post Conditions"
msgstr ""

#: Game.Levels.DataInvariants.L05_InsertBST
msgid "Inserting into a BST yields a BST."
msgstr ""

#. ยง0: `โฆโpreconditionโโฆ prog โฆโ r => โpostcondition rโโฆ`
#. ยง1: `mvcgen [prog]`
#. ยง2: `grind`
#. ยง3: `for x in a do ...`
#. ยง4: `xs`
#. ยง5: ```lean
#. mvcgen [myFunc] invariants
#. ยท โโจxs, myVarโฉ => โ<relationship between myVar and xs.prefix>โ
#. with grind
#. ```
#: Game.Levels.ImperativeIntro
msgid "**Welcome to Imperative Verification!**\n"
"\n"
"So far you have proved properties of *pure* functions.\n"
"Now we verify programs that use **mutable state** and **loops** โ code that *looks*\n"
"imperative while remaining 100% verified.\n"
"\n"
"## The workflow\n"
"\n"
"Every imperative proof follows the same three steps:\n"
"\n"
"1. **Write the spec** as a Hoare triple: ยง0\n"
"2. **Call ยง1** to generate verification conditions (VCs) from the do-block.\n"
"3. **Supply a loop invariant** and close VCs with ยง2.\n"
"\n"
"For a loop ยง3, the invariant is stated over the *loop cursor* ยง4\n"
"(tracking which elements have been processed) and the current mutable variables:\n"
"ยง5\n"
"\n"
"The key insight: **the invariant is usually the specification restricted to the prefix\n"
"seen so far**.\n"
"\n"
"Let's verify some programs!"
msgstr ""

#. ยง0: `grind`
#. ยง1: `grind [def]`
#. ยง2: `grind`
#. ยง3: `grind`
#. ยง4: `grind`
#. ยง5: `grind`
#. ยง6: `a = b`
#. ยง7: `f a = f b`
#. ยง8: `f`
#. ยง9: `id1 = keyId`
#. ยง10: `id2 = keyId`
#. ยง11: `id1 = id2`
#. ยง12: `hashFn id1 = hashFn id2`
#. ยง13: `keyId`
#: Game.Levels.TheGrinder.L01_Congr
msgid "**Welcome to The Grinder โ your advanced ยง0 dojo.**\n"
"\n"
"You learned ยง1 in World 3: pass a definition hint and let ยง2 close the goal.\n"
"Here we go deeper. This world has six levels, each unlocking a new ยง3 capability.\n"
"\n"
"First: ยง4 without any hints at all.\n"
"\n"
"ยง5 has a built-in **congruence closure** engine. Given equalities in the context,\n"
"it automatically derives all consequences โ including function application:\n"
"\n"
"> If ยง6, then ยง7 for any function ยง8.\n"
"\n"
"This rule chains: if ยง9 and ยง10, then ยง11,\n"
"so ยง12.\n"
"\n"
"**The scenario**: two software components produce IDs that must hash to the same bucket.\n"
"You're given that both IDs equal the same canonical ยง13. Prove the hash values match."
msgstr ""

#: Game.Levels.PurePrograms.L07_Expr
msgid "Evaluate an expression to an integer."
msgstr ""

#: Game.Levels.ImperativeBoss.L02_Run
msgid "Running Instructions"
msgstr ""

#. ยง0: `simp [double]`
#: Game.Levels.FirstProofs.L01_Double
msgid "Now ยง0 will unfold the definition and close the goal."
msgstr ""

#. ยง0: `x`
#. ยง1: `hx : P x`
#. ยง2: `hf x hx`
#. ยง3: `Q (f x)`
#. ยง4: `hg (f x) ...`
#. ยง5: `R (g (f x))`
#. ยง6: `intro x hx`
#. ยง7: `exact hg (f x) (hf x hx)`
#: Game.Levels.PrePost.L06_Composition
msgid "Introduce ยง0 and ยง1, then chain the hypotheses:\n"
"ยง2 gives ยง3, and ยง4 gives ยง5.\n"
"\n"
"Try ยง6 then ยง7."
msgstr ""

#. ยง0: `grind`
#. ยง1: `double_pos`
#. ยง2: `n`
#. ยง3: `double n`
#: Game.Levels.TheGrinder.L04_GrindFwd
msgid "Just ยง0. It applies ยง1 twice: first to ยง2, then to ยง3."
msgstr ""

#. ยง0: `@[simp]`
#. ยง1: `cases h : p (f x)`
#. ยง2: `simp_all [Function.comp_apply]`
#. ยง3: `(p โ f) x = p (f x)`
#. ยง4: `simp_all`
#. ยง5: `@[simp]`
#. ยง6: `grind`
#. ยง7: `cases h : expr`
#. ยง8: `simp_all`
#: Game.Levels.AutomationPower.L07_FilterMap
msgid "You've completed **World 3: Automation Power**!\n"
"\n"
"The ยง0 investment made both the filter and map cases automatic.\n"
"ยง1 split the proof cleanly, and ยง2\n"
"tied together ยง3, the filter branches, and the IH.\n"
"\n"
"What you've mastered:\n"
"- **ยง4**: simplifies goals *and* hypotheses; IH is automatic\n"
"- **ยง5**: tag your equations once, benefit everywhere\n"
"- **ยง6**: equality reasoning + arithmetic in one call\n"
"- **ยง7**: case-split and name the result for ยง8\n"
"\n"
"These tools will power every world that follows."
msgstr ""

#. ยง0: ```
#. โฆ precondition โฆ  program  โฆ postcondition โฆ
#. ```
#. ยง1: ```lean
#. โฆโPโโฆ prog โฆโ r => โQ rโโฆ
#. ```
#. ยง2: `P`
#. ยง3: `prog`
#. ยง4: `Id`
#. ยง5: `r`
#. ยง6: `Q r`
#. ยง7: ```lean
#. def pureSwap (a b : Nat) : Id (Nat ร Nat) := do
#.   return (b, a)
#. ```
#. ยง8: `mvcgen`
#. ยง9: `do`
#: Game.Levels.PrePost.L04_HoareTriple
msgid "Time for the big idea: **Hoare triples**.\n"
"\n"
"A Hoare triple has three parts:\n"
"ยง0\n"
"\n"
"It says: *if the precondition holds before the program runs, then the\n"
"postcondition holds after it finishes*.\n"
"\n"
"In Lean's Std library, we write:\n"
"ยง1\n"
"\n"
"where ยง2 is the precondition, ยง3 is an ยง4 computation, ยง5 is the\n"
"return value, and ยง6 is the postcondition.\n"
"\n"
"Here is a trivially simple program:\n"
"ยง7\n"
"\n"
"The **ยง8** tactic (*modular verification condition generator*) analyses\n"
"a ยง9 block and generates proof obligations automatically. Try it!"
msgstr ""

#: Game.Levels.DataInvariants.L03_InsertLeaf
msgid "Inserting into an Empty Tree"
msgstr ""

#. ยง0: ```lean
#. myFilter p (myMap f l) = myMap f (myFilter (p โ f) l)
#. ```
#. ยง1: `myMap f l`
#. ยง2: `p โ f`
#. ยง3: `@[simp]`
#. ยง4: `myMap`
#. ยง5: `myFilter`
#. ยง6: `simp_all`
#. ยง7: ```lean
#. induction l with
#. | nil => simp
#. | cons x xs ih =>
#.   simp only [myMap_cons, myFilter_cons]
#.   cases h : p (f x) <;> simp_all [Function.comp_apply]
#. ```
#. ยง8: `simp only [myMap_cons, myFilter_cons]`
#. ยง9: `cases h : p (f x)`
#. ยง10: `simp_all [Function.comp_apply]`
#. ยง11: `(p โ f) x`
#. ยง12: `p (f x)`
#. ยง13: `if`
#: Game.Levels.AutomationPower.L07_FilterMap
msgid "The payoff level. This theorem appears in compilers, query optimizers, and\n"
"functional programming textbooks: **filter-map fusion**.\n"
"\n"
"ยง0\n"
"\n"
"Filtering after mapping equals mapping after filtering with a composed\n"
"predicate. Instead of building an intermediate list (ยง1) and then\n"
"filtering it, you can filter the *original* list by the composed predicate\n"
"ยง2 and map only the elements that pass.\n"
"\n"
"Without our automation tools, this would take 6+ manual lines. With\n"
"ยง3 on both ยง4 and ยง5, and ยง6 finding the IH:\n"
"\n"
"ยง7\n"
"\n"
"- ยง8 expands both sides one step.\n"
"- ยง9 splits on whether the element passes the filter.\n"
"- ยง10 connects ยง11 to ยง12,\n"
"  simplifies the ยง13 branches, and uses the IH."
msgstr ""

#. ยง0: `xs.prefix`
#. ยง1: `stack`
#. ยง2: `foldl step`
#. ยง3: `sumArray`
#. ยง4: `run_eq_foldl`
#. ยง5: `run`
#. ยง6: `compile_correct`
#. ยง7: `foldl`
#. ยง8: `for`
#: Game.Levels.ImperativeBoss.L09_Exec
msgid "The imperative executor is verified! The invariant says:\n"
"\n"
"> After processing ยง0 (the instructions seen so far), ยง1 equals\n"
"> ยง2 over that prefix.\n"
"\n"
"This is exactly the same pattern as ยง3: the invariant is the spec restricted\n"
"to the prefix.\n"
"\n"
"The ยง4 lemma bridges the two worlds:\n"
"- ยง5 (recursive, used in ยง6)\n"
"- ยง7 (what the ยง8 loop computes)\n"
"\n"
"One more level to bring it all together!"
msgstr ""

#. ยง0: `2 * n โฅ 2`
#. ยง1: `h`
#. ยง2: `rw [myLog2_ge_two (by omega)]`
#: Game.Levels.Termination.L04_Log2Double
msgid "The argument ยง0 follows from ยง1. Use ยง2."
msgstr ""

#. ยง0: `SortedList`
#. ยง1: `Sorted data`
#: Game.Levels.ProofsInTypes.L06_SortedList
msgid "The empty ยง0 has ยง1."
msgstr ""

#. ยง0: `is1 = i :: is1`
#. ยง1: `simp [run, ih]`
#: Game.Levels.ImperativeBoss.L04_RunAppend
msgid "Inductive case: ยง0. Try ยง1."
msgstr ""

#. ยง0: `double n = 2 * n`
#: Game.Levels.TheGrinder.L03_GrindEq
msgid "ยง0 (proved with annotated grind)"
msgstr ""

#. ยง0: `e = .add a b`
#. ยง1: `iha`
#. ยง2: `ihb`
#: Game.Levels.ImperativeBoss.L08_CompileCorrect
msgid "Inductive case: ยง0. Same proof as L06, but ยง1/ยง2 come\n"
"from the induction principle instead of being given as assumptions."
msgstr ""

#. ยง0: `rw [myLog2_ge_two h]`
#. ยง1: `0 < myLog2 (n / 2) + 1`
#. ยง2: `omega`
#. ยง3: `n`
#. ยง4: `n โฅ 2`
#. ยง5: `myLog2`
#: Game.Levels.Termination.L03_MyLog2
msgid "After ยง0, the goal became ยง1.\n"
"Any natural number plus 1 is positive, which ยง2 handles in one step.\n"
"\n"
"Notice how the termination measure (ยง3) guided the proof structure:\n"
"the interesting case is ยง4, exactly when ยง5 recurses."
msgstr ""

#. ยง0: `myDiv n n = 1`
#. ยง1: `n`
#: Game.Levels.Termination.L02_MyDiv
msgid "ยง0 for positive ยง1: dividing a number by itself gives 1."
msgstr ""

#: Game.Levels.ProofsInTypes
msgid "Proofs Packed in Types"
msgstr ""

#: Game.Levels.PurePrograms.L06_BST
msgid "Search for a value in a BST."
msgstr ""

#. ยง0: `simp [isEven, double]`
#: Game.Levels.FirstProofs.L02_IsEven
msgid "Try ยง0 to unfold both definitions."
msgstr ""

#: Game.Levels.AutomationPower.L05_FilterPartition
msgid "Filter Partitions a List"
msgstr ""

#. ยง0: `n % n = 0`
#: Game.Levels.Termination.L01_GcdSelf
msgid "ยง0 for any natural number."
msgstr ""

#: Game.Levels.ImperativeIntro.L06_CountOcc
msgid "Count Occurrences"
msgstr ""

#. ยง0: ```lean
#. def safeMod (n d : Nat) (h : d โ 0) : Nat := n % d
#. ```
#. ยง1: `h : d โ 0`
#. ยง2: `safeMod`
#: Game.Levels.PrePost.L03_Precondition
msgid "So far our contracts had no preconditions โ they held for *all* inputs.\n"
"But some operations are only valid under certain assumptions.\n"
"\n"
"Division by zero is undefined. We can encode this as a **precondition**:\n"
"\n"
"ยง0\n"
"\n"
"The caller must supply a proof ยง1 to call ยง2. In exchange,\n"
"the function guarantees the result is less than the divisor."
msgstr ""

#: Game.Levels.Termination.L03_MyLog2
msgid "Logarithm by Repeated Halving"
msgstr ""

#. ยง0: `@[simp]`
#. ยง1: `myMap`
#. ยง2: `simp_all`
#. ยง3: `@[simp]`
#. ยง4: `@[simp]`
#. ยง5: `simp`
#. ยง6: `simp_all`
#: Game.Levels.AutomationPower.L02_SimpAttr
msgid "ยง0 turned ยง1's equation lemmas into permanent simplification rules.\n"
"ยง2 then used them (plus the IH) to close both the base and inductive cases\n"
"without any manual guidance.\n"
"\n"
"This is the ยง3 workflow:\n"
"1. Tag your function's equations with ยง4.\n"
"2. From then on, use plain ยง5 or ยง6 โ no hints needed."
msgstr ""

#: Game.Levels.DataInvariants.L02_CheckBST
msgid "A concrete 3-node tree is a valid BST."
msgstr ""

#. ยง0: `bstInsert`
#. ยง1: `simp [hxy, hyx, hy, hbl, ihr hbst_r hx hbr]`
#: Game.Levels.DataInvariants.L04_BoundsInsert
msgid "ยง0 goes right. ยง1."
msgstr ""

#: Game.Levels.PrePost.L04_HoareTriple
msgid "Swap two values (pure version)."
msgstr ""

#. ยง0: `let mut`
#. ยง1: `do`
#. ยง2: ```lean
#. def swap (a b : Nat) : Id (Nat ร Nat) := do
#.   let mut x := a
#.   let mut y := b
#.   let t := x
#.   x := y
#.   y := t
#.   return (x, y)
#. ```
#. ยง3: `Id`
#. ยง4: `Id.run`
#. ยง5: ```
#. โฆ precondition โฆ  program  โฆ postcondition โฆ
#. ```
#. ยง6: `swap`
#. ยง7: `โฆโTrueโโฆ swap a b โฆโ r => โr = (b, a)โโฆ`
#. ยง8: `swap a b`
#. ยง9: `(b, a)`
#. ยง10: `mvcgen [swap]`
#: Game.Levels.ImperativeIntro.L01_Swap
msgid "Welcome to **Imperative Verification**!\n"
"\n"
"So far you have proved properties of *pure* functions โ functions with no mutable state.\n"
"Now we will verify programs that look imperative: they use ยง0 variables and\n"
"reassign them inside ยง1 blocks.\n"
"\n"
"Here is a tiny example: swapping two values.\n"
"\n"
"ยง2\n"
"\n"
"ยง3 is Lean's *identity monad* โ it runs imperatively but has no side effects beyond\n"
"tracking mutable locals. ยง4 extracts the value.\n"
"\n"
"**Hoare triples** let us specify what a program guarantees:\n"
"ยง5\n"
"For ยง6: ยง7 says: starting from *any* state,\n"
"ยง8 returns the pair ยง9.\n"
"\n"
"The new tactic **ยง10** breaks this triple into simple proof obligations\n"
"(*verification conditions*) automatically โ you just need to close them."
msgstr ""

#: Game.Levels.ProofsInTypes.L07_InsertSorted
msgid "insertSorted: Preserving the Invariant"
msgstr ""

#: Game.Levels.ImperativeBoss.L05_CompileNum
msgid "Compiler Correctness: Numbers"
msgstr ""

#: Game.Levels.Termination.L05_MergeLength
msgid "Sorted merge of two lists."
msgstr ""

#. ยง0: `native_decide`
#. ยง1: `run [.push 2, .push 3, .add] []`
#. ยง2: `โ run [.push 3, .add] [2]`
#. ยง3: `โ run [.add] [3, 2]`
#. ยง4: `โ run [] [5]`
#. ยง5: `โ [5]`
#. ยง6: `run`
#. ยง7: `Expr`
#. ยง8: `List Instr`
#: Game.Levels.ImperativeBoss.L02_Run
msgid "ยง0 evaluated the entire execution trace:\n"
"1. ยง1\n"
"2. ยง2\n"
"3. ยง3\n"
"4. ยง4\n"
"5. ยง5\n"
"\n"
"With ยง6 in hand, we can execute any sequence of stack machine instructions.\n"
"Next: we will write a **compiler** that translates ยง7 into ยง8."
msgstr ""

#. ยง0: `ยฌx โค y`
#. ยง1: `have key := merge_cons_gt x y xs' ys' h`
#. ยง2: `simp [key, ihys]`
#. ยง3: `omega`
#: Game.Levels.Termination.L05_MergeLength
msgid "In the ยง0 branch: ยง1, then ยง2 and ยง3."
msgstr ""

#. ยง0: `simp [myGcd]`
#. ยง1: `| 0 => a`
#. ยง2: `a`
#. ยง3: `termination_by b`
#. ยง4: `a % (b' + 1) < b' + 1`
#: Game.Levels.FirstProofs.L04_GcdBase
msgid "ยง0 matched the ยง1 case of the definition and immediately\n"
"returned ยง2. The base case is proved!\n"
"\n"
"Notice ยง3: this tells Lean that the second argument decreases at each\n"
"recursive call (since ยง4). Without this, Lean would reject the definition."
msgstr ""

#: Game.Levels.AutomationPower.L06_GrindBST
msgid "A binary tree: either a leaf or a node with left subtree, value, and right subtree."
msgstr ""

#: Game.Levels.ProofsInTypes.L08_Victory
msgid "World 4 complete! You've packed proofs into types:\n"
"\n"
"- **EvenNat** โ only even numbers can be constructed\n"
"- **Fin n** โ indices that are provably in-bounds\n"
"- **safeHead** โ a head function that cannot be called on empty lists\n"
"- **Sorted** โ a predicate encoding a list's invariant\n"
"- **SortedList** โ a type where sortedness is enforced at construction\n"
"- **SortedList.insert** โ insertion that preserves sortedness, verified once for all time\n"
"\n"
"Onward to World 5: Termination!"
msgstr ""

#: Game.Levels.AutomationPower.L03_Grind
msgid "grind: The Automated Prover"
msgstr ""

#: Game.Levels.TheGrinder.L03_GrindEq
msgid "@[grind =]: Teaching grind to Rewrite"
msgstr ""

#. ยง0: `compile (.num n) = [.push n]`
#. ยง1: `run [.push n] s = n :: s = eval (.num n) :: s`
#. ยง2: `add`
#. ยง3: `mul`
#: Game.Levels.ImperativeBoss.L05_CompileNum
msgid "The base case is straightforward: ยง0, and\n"
"ยง1.\n"
"\n"
"Next: the inductive cases for ยง2 and ยง3."
msgstr ""

#. ยง0: `intro a`
#. ยง1: `simp [myGcd]`
#: Game.Levels.FirstProofs.L04_GcdBase
#: Game.Levels.ImperativeIntro.L01_Swap
msgid "Try ยง0 then ยง1."
msgstr ""

#. ยง0: `grind`
#. ยง1: `grind [def]`
#. ยง2: `grind`
#. ยง3: `grind`
#. ยง4: `grind`
#. ยง5: `omega`
#. ยง6: `@[grind =]`
#. ยง7: `@[grind โ]`
#. ยง8: `@[grind]`
#. ยง9: `double`
#. ยง10: `myMap`
#. ยง11: `myFilter`
#. ยง12: `grind`
#: Game.Levels.TheGrinder
msgid "**Welcome to The Grinder โ your advanced ยง0 dojo.**\n"
"\n"
"In World 3 you learned ยง1: pass a definition hint and let ยง2 close the goal.\n"
"Here we go deeper: teach ยง3 your own rules so it needs *no* hints at all.\n"
"\n"
"ยง4 is an automated prover with three cooperating engines:\n"
"\n"
"- **Congruence closure** โ derives equalities from equalities (levels 1โ2)\n"
"- **Linear arithmetic** โ like ยง5, integrated with the other engines (level 2)\n"
"- **E-matching** โ instantiates annotated lemmas when patterns appear (levels 3โ5)\n"
"\n"
"And three annotation tools you'll master here:\n"
"\n"
"- ยง6 โ your equation becomes an automatic rewrite rule (level 3)\n"
"- ยง7 โ your implication becomes an automatic forward rule (level 4)\n"
"- ยง8 โ your theorem is registered for E-matching instantiation (level 5)\n"
"\n"
"All examples reuse definitions from Worlds 1โ3 (ยง9, ยง10, ยง11).\n"
"\n"
"Annotate your invariants once. Let ยง12 verify any consequence โ forever."
msgstr ""

#: Game.Levels.ImperativeBoss.L06_CompileAdd
msgid "Compiler Correctness: Addition"
msgstr ""

#. ยง0: `b = b' + 1`
#. ยง1: `simp [myGcd]`
#: Game.Levels.FirstProofs.L05_GcdStep
msgid "Now ยง0. Try ยง1 to apply the recursive equation."
msgstr ""

#. ยง0: `IsBST .leaf`
#. ยง1: `True`
#. ยง2: `simp`
#: Game.Levels.DataInvariants.L01_IsBST
msgid "ยง0 unfolds to ยง1. Use ยง2 to close it."
msgstr ""

#. ยง0: `v`
#. ยง1: `a`
#: Game.Levels.ImperativeIntro.L06_CountOcc
msgid "Count the number of times ยง0 appears in array ยง1."
msgstr ""

#. ยง0: `intro _ hx _`
#. ยง1: `simp [bstInsert, hx]`
#: Game.Levels.DataInvariants.L04_BoundsInsert
msgid "For the leaf case: ยง0 then ยง1."
msgstr ""

#. ยง0: `use expr`
#. ยง1: `โข โ x, P x`
#. ยง2: `P expr`
#: Game.Levels.ProofsInTypes.L01_Subtype
msgid "Supply a witness for an existential goal: ยง0 closes ยง1 when ยง2 holds."
msgstr ""

#. ยง0: `myGcd`
#. ยง1: ```
#. def myCoprime (a b : Nat) : Prop := myGcd a b = 1
#. ```
#. ยง2: `myCoprime a b`
#. ยง3: `myGcd a b = 1`
#. ยง4: `constructor`
#. ยง5: `โ`
#. ยง6: `<;>`
#. ยง7: ```
#. constructor <;> intro h <;> exact h
#. ```
#. ยง8: `exact h`
#: Game.Levels.FirstProofs.L06_Coprime
msgid "Two numbers are **coprime** (or relatively prime) if their GCD equals 1.\n"
"This is a key concept in number theory and cryptography โ for example,\n"
"RSA encryption requires finding large coprime numbers.\n"
"\n"
"We define coprimality using ยง0:\n"
"ยง1\n"
"\n"
"Prove that ยง2 is logically equivalent to ยง3.\n"
"\n"
"*Tip*: Use ยง4 to split the ยง5 into two implications. Both directions\n"
"are symmetric, so you can use the **ยง6** combinator to apply the same tactic to\n"
"all remaining goals at once:\n"
"ยง7\n"
"reads as: split, then introduce the hypothesis in *every* subgoal, then close\n"
"*every* subgoal with ยง8."
msgstr ""

#: Game
msgid "# Welcome to the Program Verification Game!\n"
"\n"
"In this game you will learn **formal program verification** โ the art of\n"
"proving mathematical theorems about programs to guarantee they are correct.\n"
"\n"
"You will use **Lean 4**, a proof assistant that checks every step of your reasoning.\n"
"\n"
"## The Worlds\n"
"\n"
"| # | World | Theme |\n"
"|---|-------|-------|\n"
"| 1 | **First Proofs** | Core tactics, GCD algorithm, primality |\n"
"| 2 | **Pure Programs** | Pure recursive programs + termination |\n"
"| 3 | **Automation Power** | simp_all, grind, and @[simp] |\n"
"| 3โ | **The Grinder** (optional) | Advanced grind: @[grind =], @[grind โ], E-matching |\n"
"| 4 | **Proofs in Types** | Subtypes, Fin, proof-carrying functions |\n"
"| 5 | **Termination** | Proving programs always terminate |\n"
"| 6 | **Data Invariants** | Sorted lists, balanced trees, invariant maintenance |\n"
"| 7 | **Pre/Post Conditions** | Hoare-style contracts |\n"
"| 8 | **Imperative Intro** | Verifying mutable state and loops |\n"
"| 9 | **Imperative Boss** | Verified mini-compiler (capstone) |\n"
"\n"
"Start with **World 1** to learn the basics!"
msgstr ""

#: Game.Levels.ImperativeBoss.L09_Exec
msgid "The Imperative Executor"
msgstr ""

#: Game.Levels.PurePrograms.L03_MyFoldr
msgid "Folding a List"
msgstr ""

#. ยง0: `simp [bstInsert]`
#. ยง1: `.node .leaf x .leaf`
#. ยง2: `IsBST`
#. ยง3: `True`
#: Game.Levels.DataInvariants.L03_InsertLeaf
msgid "ยง0 unfolds the insertion into a leaf, giving ยง1.\n"
"Since all subtrees are leaves, the ยง2 conditions reduce to ยง3."
msgstr ""

#. ยง0: `IsBST`
#. ยง1: `bstInsert`
#. ยง2: `BSTSet`
#. ยง3: `AllLt`
#. ยง4: `AllGt`
#. ยง5: `IsBST`
#. ยง6: `allLt_bstInsert`
#. ยง7: `allGt_bstInsert`
#. ยง8: `isBST_bstInsert`
#. ยง9: `BSTSet`
#. ยง10: `insert`
#: Game.Levels.DataInvariants.L06_BSTSet
msgid "Congratulations โ you have completed **World 6: Data Invariants**!\n"
"\n"
"You defined the BST invariant (ยง0) and proved that ยง1 preserves it.\n"
"Then you bundled the tree and its proof into ยง2 โ a type where the invariant\n"
"is **enforced by construction**.\n"
"\n"
"What you built:\n"
"- ยง3, ยง4 โ bound predicates for subtrees\n"
"- ยง5 โ the full BST ordering invariant\n"
"- ยง6 โ bounds survive insertion\n"
"- ยง7 โ symmetric bound preservation\n"
"- ยง8 โ **the main theorem**: insertion preserves BST\n"
"- ยง9 โ a verified BST type, closed under ยง10\n"
"\n"
"The same pattern works for *any* data structure with an invariant:\n"
"1. Define the invariant as a predicate\n"
"2. Prove each operation preserves it\n"
"3. Bundle the data and proof into a structure\n"
"\n"
"No runtime check. No test suite. The compiler guarantees correctness for all inputs.\n"
"\n"
"Onward to **World 7: Pre/Post Conditions**!"
msgstr ""

#: Game.Levels.DataInvariants.L06_BSTSet
msgid "Insert into a BST, preserving the invariant."
msgstr ""

#: Game.Levels.PurePrograms.L06_BST
msgid "Insert a value into a BST."
msgstr ""

#: Game.Levels.PrePost.L05_MutableSwap
msgid "Swap two values using mutable locals."
msgstr ""

#: Game.Levels.DataInvariants.L06_BSTSet
msgid "The Verified BST"
msgstr ""

#: Game.Levels.PrePost.L01_StackContract
msgid "Push an element onto a stack."
msgstr ""

#. ยง0: `xs.prefix`
#. ยง1: `mvcgen โ invariant โ grind`
#: Game.Levels.ImperativeIntro.L06_CountOcc
msgid "The invariant is the specification itself, restricted to ยง0.\n"
"This is the hallmark of a clean imperative proof: the invariant is so natural\n"
"that it almost writes itself.\n"
"\n"
"You have now verified 6 imperative programs โ from a simple swap to a counting loop โ\n"
"all using the same ยง1 workflow.\n"
"\n"
"**Congratulations โ you've completed the Imperative Intro world!**\n"
"\n"
"The reversal algorithm and more advanced patterns await in the next world."
msgstr ""

#. ยง0: `.val`
#. ยง1: `.1`
#. ยง2: `.property`
#. ยง3: `.2`
#. ยง4: `e : EvenNat`
#. ยง5: `e.val : Nat`
#. ยง6: `e.property : e.val % 2 = 0`
#. ยง7: `EvenNat`
#: Game.Levels.ProofsInTypes.L02_SubtypeAccess
msgid "Every subtype value carries two pieces:\n"
"- ยง0 (or ยง1): the underlying value\n"
"- ยง2 (or ยง3): the proof\n"
"\n"
"For ยง4:\n"
"- ยง5 โ the number itself\n"
"- ยง6 โ the proof it's even\n"
"\n"
"The type system **guarantees** this proof exists. You cannot construct an ยง7 without\n"
"providing a proof of evenness."
msgstr ""

#. ยง0: `grind [double]`
#. ยง1: `grind`
#. ยง2: `grind [def1, lemma2, ...]`
#. ยง3: `[double]`
#. ยง4: `grind`
#: Game.Levels.AutomationPower.L03_Grind
msgid "ยง0 unfolded the definition, rewrote the hypothesis, and\n"
"closed the goal with linear arithmetic โ all in one call.\n"
"\n"
"When ยง1 needs a push, you can give it more lemma hints:\n"
"ยง2. Here, ยง3 was enough.\n"
"\n"
"ยง4 is particularly useful when you have hypotheses relating\n"
"computed values and need to derive new equalities or inequalities."
msgstr ""

#. ยง0: `simp [myDiv]`
#. ยง1: `myDiv (n+1) (n+1)`
#. ยง2: `myDiv 0 (n+1) + 1`
#. ยง3: `myDiv 0 (n+1)`
#. ยง4: `0`
#. ยง5: `n+1 โค 0`
#. ยง6: `0 + 1 = 1`
#: Game.Levels.Termination.L02_MyDiv
msgid "ยง0 unfolds the definition. It reduces ยง1\n"
"to ยง2, then ยง3 to ยง4 (the condition ยง5\n"
"is false), giving ยง6."
msgstr ""

#: Game.Levels.AutomationPower.L06_GrindBST
msgid "Test whether a value is a member of a binary search tree."
msgstr ""

#: Game.Levels.DataInvariants.L01_IsBST
msgid "The BST Invariant"
msgstr ""

#. ยง0: `IsBST`
#. ยง1: `bstInsert`
#. ยง2: `BSTSet`
#: Game.Levels.DataInvariants
msgid "**World 6: Data Invariants**\n"
"\n"
"A data structure is only useful if its **invariant** holds after every operation.\n"
"A binary search tree must stay ordered after every insert. A sorted list must\n"
"stay sorted after every addition.\n"
"\n"
"In this world you will:\n"
"- Define the BST invariant (ยง0) using bound predicates\n"
"- Prove that ยง1 preserves the invariant\n"
"- Bundle everything into ยง2 โ a verified BST type\n"
"\n"
"The key insight: once you prove an operation preserves an invariant, the\n"
"compiler enforces it forever. No runtime check needed."
msgstr ""

#. ยง0: `native_decide`
#: Game.Levels.ImperativeBoss.L03_Compile
msgid "Another concrete computation โ ยง0 handles it."
msgstr ""

#: Game.Levels.ImperativeBoss.L09_Exec
msgid "Imperative stack machine executor using a for loop."
msgstr ""

#. ยง0: `simp`
#. ยง1: `@[simp]`
#. ยง2: `@[simp]`
#. ยง3: `simp`
#. ยง4: `simp_all`
#. ยง5: `simp [myMap]`
#. ยง6: `myMap`
#. ยง7: ```lean
#. @[simp] theorem myMap_nil (f : ฮฑ โ ฮฒ) :
#.     myMap f [] = [] := rfl
#. 
#. @[simp] theorem myMap_cons (f : ฮฑ โ ฮฒ) (x : ฮฑ) (xs : List ฮฑ) :
#.     myMap f (x :: xs) = f x :: myMap f xs := rfl
#. ```
#. ยง8: `rfl`
#. ยง9: `myMap`
#. ยง10: `simp`
#. ยง11: `myMap`
#. ยง12: `myMap`
#. ยง13: `myMap g (myMap f l) = myMap (g โ f) l`
#. ยง14: `f`
#. ยง15: `g`
#. ยง16: `induction l <;> simp_all [Function.comp_apply]`
#: Game.Levels.AutomationPower.L02_SimpAttr
msgid "ยง0 has a built-in library of rewrite rules. You can extend it permanently\n"
"by tagging your own theorems with the **ยง1 attribute**.\n"
"\n"
"After marking a theorem ยง2, plain ยง3 (and ยง4) uses it\n"
"automatically โ you never need to write ยง5 again.\n"
"\n"
"The equation lemmas of ยง6 make great simp rules:\n"
"ยง7\n"
"\n"
"Both are proved by ยง8 because they follow directly from ยง9's definition.\n"
"\n"
"With these in place, ยง10 knows how ยง11 behaves on every list shape.\n"
"Now prove a brand-new theorem: **ยง12 respects function composition**.\n"
"\n"
"ยง13\n"
"\n"
"Mapping ยง14 then ยง15 is the same as mapping their composition in one pass.\n"
"Try ยง16."
msgstr ""

#. ยง0: `allPositive a = true`
#. ยง1: `a`
#: Game.Levels.ImperativeIntro.L03_AllPositive
msgid "ยง0 iff every element of ยง1 is non-zero."
msgstr ""

#. ยง0: `grind`
#. ยง1: `h1`
#. ยง2: `h2`
#. ยง3: `written < 1025`
#: Game.Levels.TheGrinder.L02_Arith
msgid "ยง0 has a built-in linear arithmetic solver. It combines ยง1 and ยง2\n"
"automatically to derive ยง3 โ no hints needed."
msgstr ""

#. ยง0: `mvcgen`
#. ยง1: `let mut x := a; let mut y := b`
#. ยง2: `let t := x; x := y; y := t`
#. ยง3: `return (x, y)`
#. ยง4: `(b, a)`
#. ยง5: `mvcgen`
#. ยง6: `let`
#: Game.Levels.PrePost.L05_MutableSwap
msgid "The exact same proof! ยง0 tracks the mutable assignments step by step:\n"
"- After ยง1: x = a, y = b\n"
"- After ยง2: x = b, y = a\n"
"- At ยง3: the result is ยง4\n"
"\n"
"Mutable local variables are just syntactic sugar in Lean โ ยง5 handles\n"
"them the same way as pure ยง6 bindings. The verification is identical."
msgstr ""

#: Game.Levels.PrePost.L05_MutableSwap
msgid "Mutable State"
msgstr ""

#: Game.Levels.DataInvariants.L05_InsertBST
msgid "Insert Preserves BST"
msgstr ""

#: Game
#: Game
msgid "Program Verification Game"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! ๐"
msgstr ""

#. ยง0: `is1 = []`
#. ยง1: `simp [run]`
#: Game.Levels.ImperativeBoss.L04_RunAppend
msgid "Base case: ยง0. Try ยง1."
msgstr ""

#: Game.Levels.ProofsInTypes.L04_SafeHead
msgid "Return the head of a non-empty list, with non-emptiness proved at call site."
msgstr ""

#: Game.Levels.Termination.L02_MyDiv
msgid "Division by repeated subtraction."
msgstr ""

#. ยง0: `n = 0`
#. ยง1: `h : 0 < 0`
#. ยง2: `omega`
#. ยง3: `n = k+1`
#. ยง4: `simp [myDiv]`
#. ยง5: `k+1 - (k+1) = 0`
#. ยง6: `myDiv 0 (k+1)`
#. ยง7: `k+1 โค 0`
#. ยง8: `simp [myDiv]`
#. ยง9: `1`
#. ยง10: `myDiv`
#: Game.Levels.Termination.L02_MyDiv
msgid "The proof mirrors the termination argument:\n"
"- **Base case** (ยง0): impossible since ยง1, so ยง2 closes it.\n"
"- **Step case** (ยง3): ยง4 unfolds one step, uses ยง5,\n"
"  then unfolds again at ยง6 where the condition ยง7 is false.\n"
"\n"
"The ยง8 terminates here because the RHS is just ยง9 โ there is no\n"
"ยง10 on the right side for simp to endlessly expand."
msgstr ""

#. ยง0: `omega`
#. ยง1: `0 < myLog2 (n / 2) + 1`
#: Game.Levels.Termination.L03_MyLog2
msgid "ยง0 closes ยง1 since any Nat plus 1 is positive."
msgstr ""

#. ยง0: `simp [myGcd, Nat.mod_self]`
#. ยง1: `Nat.mod_self`
#. ยง2: `n % n = 0`
#: Game.Levels.Termination.L01_GcdSelf
msgid "ยง0 should close this. ยง1 says ยง2."
msgstr ""

#: Game.Levels.PrePost.L01_StackContract
msgid "Pushing then popping returns the pushed element and original stack."
msgstr ""

#: Game.Levels.ProofsInTypes.L01_Subtype
msgid "Subtypes: A Value With a Proof Inside"
msgstr ""

#. ยง0: `simp`
#. ยง1: `IsBST`
#. ยง2: `AllLt`
#. ยง3: `AllGt`
#. ยง4: `@[simp]`
#. ยง5: `1 < 3`
#. ยง6: `3 < 5`
#: Game.Levels.DataInvariants.L02_CheckBST
msgid "ยง0 unfolds ยง1, ยง2, and ยง3 (all marked ยง4),\n"
"reduces the numeric comparisons ยง5 and ยง6, and closes the goal."
msgstr ""

#. ยง0: ```
#. compile (.mul a b) = compile a ++ compile b ++ [.mul]
#. ```
#. ยง1: `add`
#: Game.Levels.ImperativeBoss.L07_CompileMul
msgid "Same pattern as addition โ now for multiplication.\n"
"\n"
"ยง0\n"
"\n"
"The proof is structurally identical to the ยง1 case. See if you can do it\n"
"without the hint!"
msgstr ""

#. ยง0: `x โค y`
#. ยง1: `insertSorted x (y :: ys) = x :: y :: ys`
#: Game.Levels.ProofsInTypes.L07_InsertSorted
#: Game.Levels.ProofsInTypes.L07_InsertSorted
msgid "When ยง0: ยง1"
msgstr ""

#: Game.Levels.ImperativeIntro
msgid "Imperative Intro"
msgstr ""

#. ยง0: `e`
#. ยง1: `s`
#. ยง2: `eval e :: s`
#. ยง3: `run_append`
#. ยง4: `induction e generalizing s`
#. ยง5: `simp`
#: Game.Levels.ImperativeBoss.L08_CompileCorrect
msgid "**The compiler is correct!**\n"
"\n"
"For any expression ยง0, the compiled instruction sequence, when run on any stack ยง1,\n"
"produces ยง2. The key ingredients:\n"
"- ยง3 (L04) โ splits concatenated programs\n"
"- ยง4 โ gives universally quantified IH\n"
"- ยง5 with the right lemmas โ closes each case\n"
"\n"
"This is a theorem about *all* expressions โ infinitely many programs, all verified\n"
"with one proof."
msgstr ""

#. ยง0: `[.push 3, .push 1, .push 2, .add, .mul]`
#. ยง1: `[9]`
#. ยง2: `eval (.mul (.num 3) (.add (.num 1) (.num 2))) = 9`
#: Game.Levels.ImperativeBoss.L03_Compile
msgid "The compiler produced ยง0, and the stack machine\n"
"executed it to get ยง1 โ matching ยง2.\n"
"\n"
"But can we prove this works for **all** expressions, not just this example? That is the\n"
"compiler correctness theorem, and the next few levels build up to it piece by piece."
msgstr ""

#. ยง0: `myMap`
#. ยง1: `f`
#: Game.Levels.PurePrograms.L01_MyMap
msgid "Nice work! ยง0 always produces a list of the same length โ regardless of what\n"
"function ยง1 does. This is a simple structural property that follows directly from\n"
"how the recursion is structured."
msgstr ""

#. ยง0: ```
#. Expr  โโcompileโโโถ  List Instr  โโrun/execโโโถ  result = eval e
#. ```
#. ยง1: `compile_correct`
#. ยง2: `run (compile e) s = eval e :: s`
#. ยง3: `exec_correct`
#. ยง4: `foldl step`
#. ยง5: `run_eq_foldl`
#. ยง6: `run`
#. ยง7: `foldl`
#. ยง8: `verified_compiler`
#. ยง9: `run (compile e) [] = [eval e]`
#. ยง10: `generalizing`
#. ยง11: `@[simp]`
#. ยง12: `mvcgen`
#. ยง13: `double n = n + n`
#: Game.Levels.ImperativeBoss.L10_Victory
msgid "**Congratulations โ you have built a verified compiler!**\n"
"\n"
"Let's look back at what you accomplished:\n"
"\n"
"**The compilation pipeline:**\n"
"ยง0\n"
"\n"
"**The theorems:**\n"
"- ยง1 (L08): ยง2\n"
"- ยง3 (L09): the imperative executor matches ยง4\n"
"- ยง5 (L09): bridges recursive ยง6 and iterative ยง7\n"
"- ยง8 (L10): ยง9\n"
"\n"
"**The techniques you used:**\n"
"- Structural induction with ยง10 (L04, L08)\n"
"- Building up ยง11 lemmas for compositional reasoning (L01, L04)\n"
"- Hoare triples and ยง12 for imperative verification (L09)\n"
"- Connecting functional and imperative implementations (L09)\n"
"\n"
"You started this game proving ยง13, and now you have verified\n"
"an end-to-end compilation pipeline. That is the power of formal verification:\n"
"**mathematical certainty that your software is correct**.\n"
"\n"
"Thank you for playing the Program Verification Game!"
msgstr ""

#. ยง0: `cases n with`
#. ยง1: `n = 0`
#. ยง2: `n = k + 1`
#: Game.Levels.Termination.L02_MyDiv
msgid "Use ยง0 to split on whether ยง1 or ยง2."
msgstr ""

#: Game.Levels.ImperativeBoss.L05_CompileNum
msgid "Compiler correctness for number literals."
msgstr ""

#. ยง0: `s = xs.prefix.foldl (ยท + ยท) 0`
#. ยง1: `s`
#. ยง2: `xs.prefix`
#. ยง3: `mvcgen`
#. ยง4: `s = 0 = foldl of []`
#. ยง5: `xs.suffix = []`
#. ยง6: `grind`
#. ยง7: `mvcgen [sumArray] invariants?`
#: Game.Levels.ImperativeIntro.L02_Sum
msgid "The invariant ยง0 captures exactly what the\n"
"accumulator ยง1 equals after the loop has processed ยง2.\n"
"\n"
"ยง3 checked three things for you:\n"
"- **Initialisation**: ยง4 before the loop starts.\n"
"- **Preservation**: if the invariant holds before an iteration, it holds after.\n"
"- **Postcondition**: when the loop ends (ยง5), the invariant implies the spec.\n"
"\n"
"ยง6 proved all three automatically once you stated the right invariant.\n"
"\n"
"*Tip*: If you are unsure what invariant to write, use ยง7\n"
"and Lean will suggest a skeleton!"
msgstr ""

#: Game.Levels.DataInvariants.L03_InsertLeaf
msgid "Inserting into an empty tree yields a valid BST."
msgstr ""

#: Game.Levels.PrePost.L01_StackContract
msgid "Pop the top element from a stack."
msgstr ""

#. ยง0: `cases h : p x`
#. ยง1: `p x = true`
#. ยง2: `p x = false`
#. ยง3: `h`
#. ยง4: `simp_all`
#. ยง5: `myFilter`
#. ยง6: `x :: xs`
#. ยง7: `h`
#. ยง8: `(fun x => !p x) x`
#. ยง9: `!p x`
#. ยง10: `!true`
#. ยง11: `!false`
#. ยง12: `omega`
#. ยง13: `k + (j+1) = 1+n`
#. ยง14: `@[simp]`
#. ยง15: `myMap`
#. ยง16: `myFilter`
#: Game.Levels.AutomationPower.L05_FilterPartition
msgid "ยง0 splits on whether ยง1 or ยง2,\n"
"naming the result ยง3 for use in subsequent tactics.\n"
"\n"
"ยง4 then:\n"
"- Unfolds ยง5 on ยง6 using ยง7\n"
"- Beta-reduces ยง8 to ยง9\n"
"- Simplifies ยง10 or ยง11 to resolve the complementary filter case\n"
"\n"
"ยง12 closes the remaining arithmetic (ยง13 style goals).\n"
"\n"
"With ยง14 on both ยง15 and ยง16, we're ready for the\n"
"grand finale."
msgstr ""

#. ยง0: `myLog2_pos n h`
#: Game.Levels.Termination.L06_Victory
msgid "Now apply ยง0 to close the goal."
msgstr ""

#. ยง0: `grind`
#. ยง1: `id1 = keyId`
#. ยง2: `id2 = keyId`
#. ยง3: `hashFn`
#: Game.Levels.TheGrinder.L01_Congr
msgid "ยง0 needs no hints here. It tracks ยง1 and ยง2,\n"
"merges all three into one equivalence class, then applies congruence:\n"
"equal inputs to ยง3 give equal outputs."
msgstr ""

#. ยง0: `node`
#: Game.Levels.PurePrograms.L05_Tree
msgid "Every ยง0 has height at least 1 โ because we add 1 to the maximum of its children's heights.\n"
"\n"
"Trees open the door to efficient data structures. In the next level, we'll build a\n"
"**Binary Search Tree** and prove its core correctness property."
msgstr ""

#. ยง0: `SortedList.insert`
#. ยง1: `SortedList`
#. ยง2: `List Nat`
#. ยง3: ```lean
#. def SortedList.insert (x : Nat) (sl : SortedList) : SortedList :=
#.   โจinsertSorted x sl.data, insertSorted_sorted x sl.data sl.sortedโฉ
#. ```
#. ยง4: `insertSorted_sorted x sl.data sl.sorted`
#. ยง5: `obtain`
#. ยง6: `h : A โง B`
#. ยง7: `โจh1, h2โฉ`
#: Game.Levels.ProofsInTypes.L08_Victory
msgid "The payoff: a ยง0 that **returns a ยง1**, not a bare ยง2.\n"
"\n"
"ยง3\n"
"\n"
"The proof ยง4 is baked into the return type.\n"
"You cannot call this function incorrectly, and its result is guaranteed sorted for\n"
"**all** inputs โ verified once at compile time.\n"
"\n"
"No unit test. No runtime assertion. No documentation that might drift. The type says it all.\n"
"\n"
"First, a helper lemma: the inserted element is always in the result.\n"
"Use ยง5 to destructure hypotheses of the form ยง6 into ยง7."
msgstr ""

#: Game
msgid "## About this Game\n"
"\n"
"**Program Verification Game** teaches formal program verification using Lean 4.\n"
"\n"
"The curriculum covers an 8-world progression from basic functional proofs\n"
"through imperative verification with loop invariants.\n"
"\n"
"**Version**: 0.2.0 (All 9 worlds playable)\n"
"\n"
"**Source**: https://github.com/your-org/pvgame"
msgstr ""

#. ยง0: `decreasing_by omega`
#: Game.Levels.PurePrograms.L04_Half
msgid "The second part is the exact inequality ยง0 proves\n"
"automatically. Can you prove it manually?"
msgstr ""

#. ยง0: `Nat`
#: Game.Levels.ProofsInTypes.L06_SortedList
msgid "A list of ยง0 paired with a proof that it is sorted."
msgstr ""

#. ยง0: `simp`
#. ยง1: `omega`
#. ยง2: `induction`
#. ยง3: `decide`
#: Game.Levels.FirstProofs
msgid "Welcome to **World 1: First Proofs**!\n"
"\n"
"In this world you will:\n"
"- Write your first verified programs in Lean 4\n"
"- Learn the core proof tactics: ยง0, ยง1, ยง2, ยง3\n"
"- Build and verify the **Euclidean GCD algorithm** from scratch\n"
"- Use your verified GCD to check primality\n"
"\n"
"By the end, you'll understand what it means to formally verify a program โ\n"
"and you'll have done it yourself."
msgstr ""

#. ยง0: `simp_all`
#. ยง1: `grind`
#. ยง2: `grind`
#. ยง3: `grind [lemma, ...]`
#. ยง4: `grind`
#. ยง5: `double n = n + n`
#. ยง6: `double`
#. ยง7: `double n = double m`
#. ยง8: `n = m`
#. ยง9: ```lean
#. double_injective : โ (n m : Nat), double n = double m โ n = m
#. ```
#. ยง10: `intro n m h; grind [double]`
#. ยง11: `grind [double]`
#. ยง12: `double`
#. ยง13: `h : double n = double m`
#. ยง14: `n + n = m + m`
#. ยง15: `n = m`
#: Game.Levels.AutomationPower.L03_Grind
msgid "ยง0 is great for simplification. But some goals need more:\n"
"they require combining **equality reasoning** with **arithmetic**.\n"
"\n"
"Enter **ยง1** โ an automated prover that handles both at once.\n"
"ยง2 performs *congruence closure* (equality reasoning) and integrates\n"
"linear arithmetic. Feed it lemmas with ยง3 and it hunts\n"
"for a proof automatically.\n"
"\n"
"Let's put ยง4 to work on a new theorem from World 1 material.\n"
"\n"
"You know ยง5. Now prove that ยง6 is **injective**:\n"
"if ยง7, then ยง8.\n"
"\n"
"ยง9\n"
"\n"
"Try ยง10.\n"
"ยง11 tells the prover to use ยง12's definition as a rule.\n"
"It then rewrites ยง13 to ยง14 and deduces\n"
"ยง15 via arithmetic โ all automatically."
msgstr ""
